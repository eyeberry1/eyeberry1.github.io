{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-01-21T06:33:28.741Z","updated":"2022-01-21T06:33:28.733Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"email: zhengbw7@mail2.sysu.edu.cn QQ: 1031266377"},{"title":"tags","date":"2022-01-20T16:16:45.000Z","updated":"2022-01-20T16:29:06.691Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"talk","date":"2022-01-20T09:14:15.000Z","updated":"2022-09-25T14:01:31.741Z","comments":true,"path":"talk/index.html","permalink":"http://example.com/talk/index.html","excerpt":"","text":"还不知道跟各位说什么呢？：）"}],"posts":[{"title":"The Impact of Increasing Proportion of Elderly Population","slug":"IELTS/writing/大作文范文2","date":"2024-03-19T09:21:53.373Z","updated":"2024-03-19T10:25:48.366Z","comments":true,"path":"2024/03/19/IELTS/writing/大作文范文2/","link":"","permalink":"http://example.com/2024/03/19/IELTS/writing/%E5%A4%A7%E4%BD%9C%E6%96%87%E8%8C%83%E6%96%872/","excerpt":"","text":"Q In many countries, the proportion of older people is steadily increasing. Does this trend have positive or negative effects on society. A In numerous countries, there is a noticeable and consistent rise in the proportion of elderly individuals. This trend has sparked debates regarding its potential positive or negative effects on society. This essay delves into the possible ramifications of this phenomenon and arrives at a conclusion. To begin with, the growing elderly population could yield several positive effects on society. Firstly, advancements in medical technology have made high-quality healthcare services more accessible, leading to extended lifespans. This implies that a greater number of elderly individuals can continue contributing to society by imparting knowledge and experience, thus fostering societal stability and development. Furthermore, elderly individuals can play vital caregiving roles within families and communities, supporting the growth and development of the younger generation. However, the increase in the elderly population may also bring about certain negative repercussions. Primarily, it could exert pressure on governments and social welfare systems, as they would need to provide more pensions and medical services. This might lead to issues such as increased fiscal burdens and uneven resource allocation. Additionally, aging could result in labor market strains, as the decrease in labor supply might lead to decreased productivity and slowed economic growth. In conclusion, the increasing elderly population has both positive and negative impacts on society. Nevertheless, through prudent planning and policy formulation, it is possible to maximize the potential of the elderly demographic and promote the sustained development of society. Therefore, I believe that the impact of this trend on society is twofold, contingent upon how we address and harness the opportunities and challenges posed by the growth of the elderly population. two-edged sword Good phase and sentence S1 This trend has sparked debates regarding its potential positive or negative effects on society. S2 This essay delves into the possible ramifications of this phenomenon and arrives at a conclusion. S3 Firstly, advancements in medical technology have made high-quality healthcare services more accessible, leading to extended lifespans life expectancy lifespan[C.] S4 Furthermore, elderly individuals can play vital caregiving roles within families and communities, supporting the growth and development of the younger generation. S5 Primarily, it could exert pressure on governments and social welfare systems, as they would need to provide more pensions and medical services. S6 This might lead to issues such as increased fiscal burdens and uneven resource allocation. S7 Additionally, aging could result in labor market strains, as the decrease in labor supply might lead to decreased productivity and slowed economic growth. S8 Nevertheless, through prudent planning and policy formulation, it is possible to maximize the potential of the elderly and promote the sustained development of society. 社会持续发展 S9 Therefore, I believe that the impact of this trend on society is twofold, contingent upon how we address and harness the opportunities and challenges posed by the growth of the elderly population. contingent upon ： depending on something else in the future in order to happen P yield several positive effects impart knowledge and experience, thus fostering societal stability and development. foster societal bring about certain negative repercussions. repercussions：the effect that an action, event, or decision has on something, especially a bad effect fiscal burdens and uneven resource allocation fiscal 财政的，国库的 connected with (public) money labor market strains prudent planing prudent: sensible and careful when you make judgements and decisions; avoiding unnecessary risks prudent finance prudent investment prudent shopping policy formulation 政策规划；政策制定；政策形成 address and harness","categories":[{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/categories/IELTS/"}],"tags":[{"name":"writing task2","slug":"writing-task2","permalink":"http://example.com/tags/writing-task2/"}]},{"title":"政府是否该支持本土电影","slug":"IELTS/writing/大作文范文1","date":"2024-03-17T13:47:45.209Z","updated":"2024-03-17T13:53:02.411Z","comments":true,"path":"2024/03/17/IELTS/writing/大作文范文1/","link":"","permalink":"http://example.com/2024/03/17/IELTS/writing/%E5%A4%A7%E4%BD%9C%E6%96%87%E8%8C%83%E6%96%871/","excerpt":"","text":"Q Many people prefer to watch foreign films rather than locally produced films. Why could this be? Should governments give more financial support to local film industries? A ​ It is true that foreign films are more popular in many countries than domestically produced films. There could be several reasons why this is the case, and I believe that governments should promote local film-making by subsidising the industry. ​ There are various reasons why many people find foreign films more enjoyable than the films produced in their own countries. Firstly, the established film industries in certain countries have huge budgets for action, special effects and to shoot scenes in spectacular locations. Hollywood blockbusters like ‘Avatar’ or the James Bond films are examples of such productions and the global appeal that they have. Another reason why these big-budget films are so successful is that they often star the most famous actors and actresses, and they are made by the most accomplished producers and directors. The poor quality, low-budget filmmaking in many countries suffers in comparison. ​ In my view, governments should support local film industries financially. In every country, there may be talented amateur film-makers who just need to be given the opportunity to prove themselves. To compete with big-budget productions from overseas, these people need money to pay for film crews, actors and a host of other costs related to producing high-quality films. If governments did help with these costs, they would see an increase in employment in the film industry, income from film sales, and perhaps even a rise in tourist numbers. New Zealand, for example, has seen an increase in tourism related to the 'Lord of the Rings' films, which were partly funded by government subsidies. ​ In conclusion, I believe that increased financial support could help to raise the quality of locally made films and allow them to compete with the foreign productions that currently dominate the market.","categories":[{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/categories/IELTS/"}],"tags":[{"name":"writing task2","slug":"writing-task2","permalink":"http://example.com/tags/writing-task2/"}]},{"title":"inverse design of grating coupler -- process presentation","slug":"Lumerical/inverse design过程展示(详细)","date":"2022-10-20T11:35:03.690Z","updated":"2022-10-20T12:19:39.806Z","comments":true,"path":"2022/10/20/Lumerical/inverse design过程展示(详细)/","link":"","permalink":"http://example.com/2022/10/20/Lumerical/inverse%20design%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA(%E8%AF%A6%E7%BB%86)/","excerpt":"","text":"preliminary_design_lms 修改为所需的结构 其次需要修改preliminary_design_lsf内的参数 可修改的参数有 入射角度 波导的厚度 waveguide_thickness 蚀刻深度 etch(主要) 初始的占空比(主要) 材料的折射率 光栅开始的起始位置 变迹系数R base.fsp 扫描光源位置的设置 光源的设置 基本结构的设置 base.lsf参数修改 可以通过中断python的过程在base文件中加入波导结构 apodized.fsp 运行apodized.py的脚本，将波导结构确定保存到apodized.fsp内 final.fsp 运行etch.py的脚本","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"inverse design","slug":"inverse-design","permalink":"http://example.com/tags/inverse-design/"}]},{"title":"柯西公式","slug":"数学物理方法/柯西公式","date":"2022-10-05T08:54:43.427Z","updated":"2022-10-05T10:54:47.954Z","comments":true,"path":"2022/10/05/数学物理方法/柯西公式/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E6%9F%AF%E8%A5%BF%E5%85%AC%E5%BC%8F/","excerpt":"","text":"单连通区域 复连通区域 例题 无界区域内的柯西公式 高阶导数 例题","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"柯西公式","slug":"柯西公式","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%85%AC%E5%BC%8F/"}]},{"title":"不定积分","slug":"数学物理方法/不定积分","date":"2022-10-05T08:40:20.967Z","updated":"2022-10-05T08:54:07.130Z","comments":true,"path":"2022/10/05/数学物理方法/不定积分/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/","excerpt":"","text":"例题","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"不定积分","slug":"不定积分","permalink":"http://example.com/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"}]},{"title":"柯西定理","slug":"数学物理方法/柯西定理","date":"2022-10-05T08:32:46.247Z","updated":"2022-10-05T08:54:51.194Z","comments":true,"path":"2022/10/05/数学物理方法/柯西定理/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%86/","excerpt":"","text":"重要例题","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"柯西定理","slug":"柯西定理","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%86/"}]},{"title":"复变函数--积分","slug":"数学物理方法/复变函数积分","date":"2022-10-05T08:08:02.730Z","updated":"2022-10-05T08:32:33.162Z","comments":true,"path":"2022/10/05/数学物理方法/复变函数积分/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86/","excerpt":"","text":"计算方法一 计算方法二 积分性质 例题","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"","slug":"Lumerical/参数设置记录","date":"2022-10-04T07:04:13.563Z","updated":"2022-10-04T08:49:49.674Z","comments":true,"path":"2022/10/04/Lumerical/参数设置记录/","link":"","permalink":"http://example.com/2022/10/04/Lumerical/%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"title: 参数设置记录 categories: Lumerical tags: Lumerical Grating Coupler 入射角度固定为15° 刻蚀深度固定为0.8um","categories":[],"tags":[]},{"title":"汇率","slug":"stock stares/汇率","date":"2022-09-30T16:53:25.302Z","updated":"2022-09-30T17:02:23.715Z","comments":true,"path":"2022/10/01/stock stares/汇率/","link":"","permalink":"http://example.com/2022/10/01/stock%20stares/%E6%B1%87%E7%8E%87/","excerpt":"","text":"定制汇率 购买力平价理论 一篮子商品的价格进行加权平均 金平价 货币中的金属价值 进出口的贸易顺差和逆差 影响汇率 货币政策的自主和依赖 金融市场的开放与封闭 蒙代尔不可能三角形 资本自由流动 货币政策独立 汇率的固定 三选二 中国是选的后两个 泰国的金融危机","categories":[{"name":"汇率","slug":"汇率","permalink":"http://example.com/categories/%E6%B1%87%E7%8E%87/"}],"tags":[{"name":"汇率","slug":"汇率","permalink":"http://example.com/tags/%E6%B1%87%E7%8E%87/"}]},{"title":"薛定谔方程","slug":"量子力学/W2/薛定谔方程","date":"2022-09-12T06:44:34.940Z","updated":"2022-09-12T06:45:37.158Z","comments":true,"path":"2022/09/12/量子力学/W2/薛定谔方程/","link":"","permalink":"http://example.com/2022/09/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W2/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"量子力学","slug":"量子力学","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"薛定谔方程","slug":"薛定谔方程","permalink":"http://example.com/tags/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B/"}]},{"title":"多值函数","slug":"数学物理方法/多值函数","date":"2022-09-11T08:15:07.465Z","updated":"2022-09-11T08:57:23.320Z","comments":true,"path":"2022/09/11/数学物理方法/多值函数/","link":"","permalink":"http://example.com/2022/09/11/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0/","excerpt":"","text":"初等解析函数举例 单值函数 整数幂函数\\(Z^n\\) 指数函数e^z 三角函数 双曲函数 多值函数 根式函数 黎曼面 对数函数","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"多值函数","slug":"多值函数","permalink":"http://example.com/tags/%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0/"},{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}]},{"title":"量子力学第一章作业","slug":"量子力学/W1/第一章作业","date":"2022-09-11T07:33:01.889Z","updated":"2024-03-17T13:46:51.485Z","comments":true,"path":"2022/09/11/量子力学/W1/第一章作业/","link":"","permalink":"http://example.com/2022/09/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"Q1 波长为λ= 1Å的X光，求光子的质量? 解: 根据德布罗意波长公式 \\[ \\lambda=\\frac{h}{\\sqrt{2Em}}\\tag{1} \\] \\[ \\begin{align} E&amp;=hv\\\\ &amp;=h\\frac{c}{\\lambda}\\tag{2} \\end{align} \\] 综合(1)式(2)式 \\[ \\begin{align} \\lambda&amp;=\\frac{h}{\\sqrt{2Em}}\\\\ &amp;=\\frac{h}{\\sqrt{2hvm}}\\\\ m&amp;=\\frac{h}{2v\\lambda^2}\\\\ &amp;=\\frac{h}{2c\\lambda}\\\\ &amp;=\\frac{6.63\\times10^{-34}}{2\\times2.99792\\times10^8\\times1\\times10^{-10}}kg\\\\ &amp;=1.106\\times10^{-32}kg \\end{align} \\] Q2. 某金属产生光电效应的红限频率为v0 ，当用频率为v(v &gt;v0 )的单色光照射该金属时，求从金属中逸出的光电子(质量为m)的德布罗意波长? 解: 根据红限频率为\\(v_0\\) \\[ \\text{束缚能}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ A=hv_0\\tag{1} \\] 由光电效应方程 \\[ E_k=hv-A\\tag{2} \\] 根据 \\[ p^2=2mE_k\\tag{3} \\] 德布罗意波长 \\[ \\lambda=\\frac{h}{p}\\tag{4} \\] 由(1)(2)(3)(4)式可得 \\[ \\lambda=\\sqrt{\\frac{h}{2m(v-v_0)}} \\] Q3. 两个光子在一定条件下可以转化成正负电子对，如果两光子能量相等，求要实现转化的光子波长最大是多少? 解: 根据能动量关系: \\[ E^2=(m_ec^2)^2+(p_ec)^2 \\] 为了使转化的光子波长最大，则要求产生的电子对的动量为0 由质能方程 \\[ E=hv=m_ec^2\\tag{1} \\] 光子的能动量关系 \\[ E=pc=\\frac{hc}{\\lambda}\\tag{2} \\] 综合(1)(2)式可得 \\[ \\begin{align} \\lambda&amp;=\\frac{h}{m_ec}\\\\ &amp;=\\frac{6.63\\times10^{-34}J\\cdot s}{0.911\\times 10^{-30}Kg\\times 3\\times10^8m\\cdot s^{-1}}\\\\ &amp;=2.426\\times 10^{-12}m \\end{align} \\] Q4. 按玻尔理论，当电子轰击基态氢原子时，如果仅产生一条光谱线，求该电子的能量范围? 解: 根据题意,电子的能量能够满足一级到二级轨道的能量而不满足一级到三级轨道的能量 因此 \\[ \\begin{align} E&amp;=T+V\\\\ &amp;=-\\frac{k^2me^4}{2n^2\\hbar^2}\\\\ &amp;=-\\frac{me^4}{2\\varepsilon^2h^2}\\cdot \\frac{1}{n^2}\\\\ &amp;=E_n\\ \\ \\ \\ \\ \\ \\ \\ \\ &amp;\\text{第n轨道电子总能量} \\end{align} \\] 电子能量范围 \\[ E_2-E_1&lt;E_e&lt;E_3-E_1 \\] 即 \\[ 8.2275\\times10^6J&lt;E_e&lt;9.59875\\times10^6J \\] Q4. 射至光阴极上的光，其波长从4000Å变至3000Å，求发射出的光电子的遏制电压变化? 解: \\[ \\begin{align} \\Delta Ue&amp;=\\frac{hc}{\\lambda_1}-\\frac{hc}{\\lambda_2}\\\\ \\Delta U&amp;=\\frac{hc}{e}(\\frac{1}{\\lambda_1}-\\frac{1}{\\lambda_2})\\\\ &amp;=\\frac{6.63\\times 10^{-34}\\times 3\\times 10^8}{1.6\\times10^{-19}}(\\frac{1}{3\\times10^{-7}}-\\frac{1}{4\\times 10^{-7}})\\\\ &amp;=1.04V \\end{align} \\]","categories":[{"name":"量子力学","slug":"量子力学","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"量子力学作业","slug":"量子力学作业","permalink":"http://example.com/tags/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%BD%9C%E4%B8%9A/"}]},{"title":"德布罗意波","slug":"量子力学/W1/粒子的波粒二象性","date":"2022-09-10T15:19:38.504Z","updated":"2022-09-10T15:46:20.538Z","comments":true,"path":"2022/09/10/量子力学/W1/粒子的波粒二象性/","link":"","permalink":"http://example.com/2022/09/10/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E7%B2%92%E5%AD%90%E7%9A%84%E6%B3%A2%E7%B2%92%E4%BA%8C%E8%B1%A1%E6%80%A7/","excerpt":"","text":"德布罗意关系 \\[ E=hv\\rightarrow v=E/h \\] \\[ P=h/\\lambda\\rightarrow \\lambda=h/p \\] 德布罗意波 物质波不是通常的波，它产生于任何运动的 物质，具有客观实在性。它能在绝对真空中 传播，因此不是机械波；它产生于所有的物 体，包括不带电的物质，因此不是电磁波。 波函数(重点) 沿单位矢量 n 方向传播频率ω和波矢R的平面波可表示为: \\[ \\psi=A\\cos{(\\vec k\\cdot\\vec r-\\omega t)} =Ae^{i(\\vec k\\cdot\\vec r-\\omega t)} \\] \\[ \\vec k =\\frac{2\\pi}{\\lambda}\\vec n,\\ \\ \\omega=2\\pi v \\] 由于 \\[ \\vec k=\\frac{\\vec p}{\\hbar},\\ \\ \\ \\omega=\\frac{E}{\\hbar} \\] \\[ \\psi=Ae^{i(\\frac{\\vec P}{\\hbar}\\cdot\\vec r-\\frac{E}{\\hbar}t)}=Ae^{\\frac{i}{\\hbar}(\\vec P\\vec r-Et)} \\] 德布罗意波长 非相对论条件下\\(E=\\frac{P^2}{2m}\\) \\[ \\begin{align} P&amp;=\\frac{h}{\\lambda}\\\\ \\lambda&amp;=\\frac{h}{p}=\\frac{h}{\\sqrt{2mE}} \\end{align} \\] 驻波条件 德布罗意波实验证明 常用物理常数","categories":[{"name":"量子力学","slug":"量子力学","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"德布罗意波","slug":"德布罗意波","permalink":"http://example.com/tags/%E5%BE%B7%E5%B8%83%E7%BD%97%E6%84%8F%E6%B3%A2/"}]},{"title":"玻尔理论","slug":"量子力学/W1/原子结构的玻尔理论","date":"2022-09-10T12:31:22.613Z","updated":"2022-09-10T15:19:17.323Z","comments":true,"path":"2022/09/10/量子力学/W1/原子结构的玻尔理论/","link":"","permalink":"http://example.com/2022/09/10/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84%E7%9A%84%E7%8E%BB%E5%B0%94%E7%90%86%E8%AE%BA/","excerpt":"","text":"玻尔假定 原子具有能量不连续的定态的概念 量子跃迁的概念 量子化条件 电子的角动量\\(L\\)只能取\\(\\hbar\\)的整数倍 \\[ \\begin{align} L&amp;=n\\hbar\\\\ \\text{其中},n&amp;=1,2,3,... \\end{align} \\] 频率条件 \\[ V_{mn}=[E_n-E_m]/h \\] 氢原子线光谱的解释 库仑定律 \\[ F_c=\\frac{mv^2}{r}=\\frac{ke^2}{r^2}\\tag{1} \\] 由\\((1)\\)式化简可得 \\[ v^2=\\frac{ke^2}{mr}\\tag{2} \\] 角动量 \\[ L=|L\\times r|=rmv=n\\hbar\\tag{3} \\] 联立\\((1)\\text{式}(2)\\)式消去\\(v^2\\) \\[ r=\\frac{n^2\\hbar^2}{kme^2}\\tag{4} \\] 当\\(n=1\\)时，得到 \\[ r_0=\\frac{\\hbar^2}{kme^2}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{第一玻尔轨道半径} \\] 电子的能量 \\[ \\begin{align} T&amp;为电子动能\\ \\ \\ \\ \\ \\ \\ \\ \\ V为电子势能\\\\ E&amp;=T+V\\\\ &amp;=\\frac{1}{2}mv^2-\\frac{ke^2}{r}\\ \\ \\ \\ \\ &amp;\\text{代入(1)式}\\\\ &amp;=\\frac{1}{2}m\\frac{ke^2}{mr}-\\frac{ke^2}{r}\\\\ &amp;=-\\frac{ke^2}{2r}\\ \\ \\ \\ \\ &amp;\\text{代入(4)式}\\\\ &amp;=-\\frac{k^2me^4}{2n^2\\hbar^2}\\\\ &amp;=E_n\\ \\ \\ \\ \\ \\ \\ \\ \\ &amp;\\text{第n轨道电子总能量} \\end{align} \\] 根据量子跃迁概念 \\[ \\begin{align} v=&amp;\\frac{[E_n-E_m]}{h}\\\\ &amp;=\\frac{k^2}{2\\pi \\hbar}[-\\frac{me^4}{2n^2\\hbar^2}+\\frac{k^2me^4}{2m^2\\hbar^2}]\\\\ &amp;=-\\frac{k^2me^4}{4\\pi\\hbar^3}[\\frac{1}{m^2}-\\frac{1}{n^2}]\\\\ &amp;=R_Hc[\\frac{1}{m^2}-\\frac{1}{n^2}]\\\\ \\end{align} \\] 得Rydberg 常数 \\[ R_H=\\frac{k^2me^4}{4\\pi\\hbar^3c} \\] 量子化条件的推广 玻尔量子论的局限性","categories":[{"name":"量子力学","slug":"量子力学","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"波尔理论","slug":"波尔理论","permalink":"http://example.com/tags/%E6%B3%A2%E5%B0%94%E7%90%86%E8%AE%BA/"}]},{"title":"量子力学基础","slug":"量子力学/W1/量子力学基础","date":"2022-09-08T10:38:01.531Z","updated":"2022-09-10T13:51:22.873Z","comments":true,"path":"2022/09/08/量子力学/W1/量子力学基础/","link":"","permalink":"http://example.com/2022/09/08/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"普朗克黑体辐射定律 研究内容 辐射与周围物质处于平衡时能量分布规律。 黑体：能够全部吸收而不反射投射其上面的辐射称为绝对黑体，简称黑体。 黑体辐射： 由这样的空腔小孔发出的辐射就称为黑体辐射 平衡辐射的性质 平衡辐射：单位面积上，单位时间内辐射与吸收的能量相等。 平衡辐射时，辐射能量只与黑体的绝对温度有关。 两个假定 （1）原子的性能和谐振子一样，以给定的频率 v 振荡； （2）黑体只能以 E = hv 为能量单位不连续的发射和吸收辐射能量 ，而不是像经典理论所要求的那样可以连续的发射和吸收辐射能量 \\[ \\rho =\\frac{8\\pi hv^3}{C^3}(\\frac {1}{e^{\\frac {hv}{KT}}-1}) \\] 三点讨论 当频率很大时，普朗克定律转化为维恩（Wien）公式。 当频率很小时，普朗克定律转化为瑞利-金斯公式 光量子和光电效应理论 光子概念 光不仅是是电磁波，而且还是由一个个粒子组成。 由相对论光的动量与能量关系$ P=E/C=hv/C=h/λ$提出了光子动量P与辐射波长的关系。 光电效应理论 \\[ \\frac{1}{2}\\mu V^2=hv-A \\] 两个典型特点 临界频率\\(v_0\\) 光电子动能只决定于光子的频率,光的强度只决定光子的数目,从而决定光电子的数目 光子动量 \\(m_0\\)和\\(\\mu_0\\)都是粒子质量 速度为V运动的粒子的能量: \\[ E=\\frac{\\mu_0C^2}{\\sqrt{1-\\frac{V^2}{C^2}}} (1) \\] \\(\\mu_0\\)是粒子的静止质量 \\(m_e=\\frac{m_0}{\\sqrt{1-\\frac{V^2}{C^2}}}\\)，静止质量和运动时的质量的关系 相对论中能量动量关系式： \\[ E_e^2=m_0^2C^4+P_e^2C^2(2) \\] 对于光子，速度为光速，为了使（1）式有意义，光子的静止质量为0 因此光子的能动量关系： \\[ E=pC \\] 光子能量、动量关系式： \\[ \\left\\{ \\begin{array}{**lr**} E=hv=\\hbar\\omega\\\\ \\vec p=\\frac{E}{c}\\vec n=\\frac{hv}{c}\\vec n=\\frac{h}{\\lambda}\\vec n=\\frac{\\hbar}{\\bar\\lambda}\\vec n=\\hbar\\vec k \\end{array} \\right. \\] \\[ \\hbar=\\frac{h}{2\\pi} \\] \\[ \\bar \\lambda=\\frac{\\lambda}{2\\pi} \\] \\[ 波矢\\vec k=\\frac{\\vec n}{\\bar \\lambda} \\] 相对论中的动能公式和经典力学的公式的统一 康普顿效应 X射线被轻元素如白蜡、石墨中的电子散射后出现的效应。该效应 有如下 2 个特点： 散射光中，除了原来X光的波长λ外，增加了一个新的波长为\\(λ&#39;\\)的X光，且\\(λ&#39; &gt;λ\\)； 波长增量 $Δλ=λ’ –λ $随散射角增大而增大。这一现象称为康普顿效应。 把 X射线被电子散射的过程看成是光子与电子的碰撞过程 康普顿效应证明 证明: img \\[ \\Delta \\lambda = \\lambda − \\lambda_0 = 2\\lambda_𝒄 \\sin^2 {\\frac{𝝋}{2} } \\] \\[ \\lambda_0:光子入射波长 \\] \\[ \\lambda:光子散射波长 \\] \\[ \\lambda_c:电子的康普顿波长 \\] \\[ φ:光子的散射角 \\] 根据能量守恒定律: \\[ h(v_0-v)+m_0c^2=m_ec^2\\tag{1} \\] \\(m_0\\) : 电子的绝对静止质量；\\(m_e\\): 电子和光子碰撞后的电子质量； \\(v_0\\)是光子入射频率;\\(v\\)是光子散射频率 根据动量守恒定律:(余弦定理) \\[ \\vec P_e=\\vec P_0-\\vec P\\tag{2} \\] 电子的能动量关系(用到了质能方程) \\[ (m_ec^2)^2=(m_0c^2)^2+(\\vec P_ec)^2 \\tag{3} \\] 由\\((2)\\)式可以推得: \\[ P_e^2=P_0^2+P^2-2P_0P\\cos \\varphi\\tag{4} \\] 根据光子的能动量关系 \\[ Pc=E=hv\\tag{5} \\] 将\\((5)\\)式代入\\((4)\\)式中得到 \\[ P_e^2=(\\frac{hv_0}{c})^2+(\\frac{hv}{c})^2-2(\\frac{hv_0}{c})(\\frac{hv}{c})\\cos \\varphi\\tag{6} \\] 将(6)式和(1)式代入(3)式得到 \\[ (h(v_0-v)+m_0c^2)^2=(m_0c^2)^2+\\\\((\\frac{hv_0}{c})^2+(\\frac{hv}{c})^2-2(\\frac{hv_0}{c})(\\frac{hv}{c})\\cos \\varphi)c^2 \\] 展开化简可得 \\[ (\\frac{1}{v}-\\frac{1}{v_0})=\\frac{h}{m_0c^2}(1-\\cos \\varphi) \\] \\[ \\lambda-\\lambda_0=\\frac{2h}{m_0c}\\sin^2 {\\frac{\\varphi}{2}} \\] 证毕 总结 \\[ \\Delta \\lambda = \\lambda − \\lambda_0 = 2\\lambda_𝒄 \\sin^2 {\\frac{𝝋}{2} } \\] 电子的康普顿波长 \\[ \\lambda_c=\\frac{h}{m_0c}=\\frac{2\\pi\\hbar }{m_0c} \\] 其中 \\[ \\hbar=\\frac{h}{2\\pi} \\] \\[ \\bar \\lambda=\\frac{\\lambda}{2\\pi} \\]","categories":[{"name":"量子力学","slug":"量子力学","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"黑体辐射\\光电效应\\康普顿散射","slug":"黑体辐射-光电效应-康普顿散射","permalink":"http://example.com/tags/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84-%E5%85%89%E7%94%B5%E6%95%88%E5%BA%94-%E5%BA%B7%E6%99%AE%E9%A1%BF%E6%95%A3%E5%B0%84/"}]},{"title":"复变函数--解析函数","slug":"数学物理方法/解析函数","date":"2022-09-07T14:26:45.888Z","updated":"2022-09-08T10:23:52.040Z","comments":true,"path":"2022/09/07/数学物理方法/解析函数/","link":"","permalink":"http://example.com/2022/09/07/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0/","excerpt":"","text":"解析函数的概念 定义：若函数\\(f(z)\\)在点\\(z_0\\)的某邻域内处处可导，则称函数\\(f(z)\\)在点\\(z_0\\)处解析;又若\\(f(z)\\)在区域\\(B\\)内的每一点解析，则称\\(f(z)\\)在区域\\(B\\)内是解析函数。 解析与可导不等价 解析和可导不等价:函数在某点解析，则必在该点可导；反之不然 在区域\\(B\\)内的解析函数必在\\(B\\)内可导 函数的奇点 解析的充分必要条件 设函数\\(f(z)=u(x,y)+iv(x,y)\\)在区域\\(B\\)内解析当且仅当： (1)实部和虚部在\\(B\\)内可导（可微）； (2)实部和虚部在\\(B\\)内每一点满足柯西—黎曼条件 解析函数与调和函数的关系 概念 调和函数:如果二元函数\\(f(x,y)\\)在区域\\(B\\)内有二阶连续的偏导数,而且满足拉普拉斯方程: \\[ \\Delta f=\\frac{\\partial^2 f}{\\partial x^2}+\\frac{\\partial^2 f}{\\partial y^2} \\] 则称\\(f(x,y)\\)为区域\\(B\\)内的调和函数,其中\\(\\Delta=\\frac{\\partial^2 }{\\partial x^2}+\\frac{\\partial^2 }{\\partial y^2}\\)称为拉普拉斯算符。 共轭调和函数：若两实函数\\(u(x,y)\\)以及\\(v(x,y)\\)均为区域\\(B\\)内的调和函数，且满足C-R条件，即 \\[ \\frac {\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y}，\\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x} \\] 则称\\(u(x,y)\\)为\\(v(x,y)\\)的共轭调和函数 性质一 任何在区域\\(B\\)内的解析的函数\\(f(z)=u(x,y)+iv(x,y)\\)其实部和虚部都是\\(B\\)内的调和函数,且虚部是实部的共轭调和函数. 性质二 解析函数的构造方法 例题 解析函数的构造方法(极坐标) 例题 已知解析函数\\(f(z)\\)的虚部\\(v(x,y)=\\sqrt{-x+\\sqrt{x^2+y^2}}\\)求实部\\(u(x,y)\\)和这个解析函数\\(f(z)\\) 解析函数的保角性 保角性证明 解析函数的性质 共轭性 调和性 保角性","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"复变函数--导数","slug":"数学物理方法/复变函数的导数","date":"2022-09-03T09:24:06.765Z","updated":"2022-09-03T10:36:25.585Z","comments":true,"path":"2022/09/03/数学物理方法/复变函数的导数/","link":"","permalink":"http://example.com/2022/09/03/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/","excerpt":"","text":"函数的连续性 例题 求导公式 柯西-黎曼方程(复变函数可导的必要条件) 可导的充分必要条件","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"复变函数","slug":"数学物理方法/复变函数","date":"2022-09-03T07:28:49.114Z","updated":"2022-09-07T14:30:19.779Z","comments":true,"path":"2022/09/03/数学物理方法/复变函数/","link":"","permalink":"http://example.com/2022/09/03/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/","excerpt":"","text":"基本概念 邻域 内点外点边界点 区域 区域边界方向 单连通区域和复连通区域 联通阶数 聚点 单值函数和多值函数 常见复变函数 \\(\\sin z\\)和\\(\\cos z\\) \\[ e^z=e^{x+iy}=e^x(\\cos y+i\\sin y) \\] \\[ \\sin z=\\frac{1}{2i}(e^{iz}-e^{-iz}) \\] \\[ \\cos z=\\frac{1}{2}(e^{iz}+e^{-iz}) \\] sinz和cosz的模可以大于1,\\(2\\pi\\)为周期 \\[ \\begin{aligned} &amp;|\\sin z|=\\frac{1}{2} \\sqrt{\\left(e^{2 y}+e^{-2 y}\\right)+2\\left(\\sin ^2 x-\\cos ^2 x\\right)} \\end{aligned} \\] \\[ \\begin{aligned} &amp;|\\cos z|=\\frac{1}{2} \\sqrt{\\left(e^{2 y}+e^{-2 y}\\right)+2\\left(\\cos ^2 x-\\sin ^2 x\\right)} \\end{aligned} \\] \\(\\operatorname{sh}z\\)和\\(\\operatorname{ch}z\\) \\[ \\operatorname{sh}z=\\frac {1}{2}(e^z-e^{-z}) \\] \\[ \\operatorname{ch}x=\\frac {1}{2}(e^z+e^{-z}) \\] \\(\\operatorname{sh}x\\),\\(\\operatorname{ch}x\\),\\(e^z\\)具有纯虚数周期\\(2\\pi i\\) \\(\\ln z\\)和\\(e^z\\) \\[ \\ln z=\\ln \\left(|z| e^{i A r g z}\\right)=\\ln |z|+i \\operatorname{Arg} z\\\\ \\] \\[ z^s=e^{s \\ln z} ( s 为复数 ) \\] 例题 复变函数的极限 类似二元函数的极限 极限例题","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"复变函数--基本运算","slug":"数学物理方法/复数与复变运算","date":"2022-09-02T12:54:05.207Z","updated":"2022-09-03T07:29:24.422Z","comments":true,"path":"2022/09/02/数学物理方法/复数与复变运算/","link":"","permalink":"http://example.com/2022/09/02/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E6%95%B0%E4%B8%8E%E5%A4%8D%E5%8F%98%E8%BF%90%E7%AE%97/","excerpt":"","text":"复数基本概念 \\[ z=x+iy \\] 实部记作\\(Rez=x\\),虚部记作\\(Imz=y\\) 复数无法比较大小，但复数可以相等 共轭复数表示为 \\[ z^*=x-iy \\] 三种表示方法 代数式 \\[ z=x+iy \\] 三角式 \\[ z=x+iy=\\rho cos\\varphi+i\\rho sin\\varphi \\] \\[ \\lvert {z}\\rvert=\\rho=\\sqrt{x^2+y^2} \\] 复数的辐角 \\(Argz=\\varphi+2k\\pi\\) z=0时,辐角不能确定 辐角主值的定义:把满足\\(0\\leq \\varphi\\textless 2\\pi\\)的\\(\\varphi\\)称为\\(Arg z\\)的主值， 记作\\(\\varphi=argz\\) 指数式 \\[ z=\\rho e^{i\\varphi} \\] 复数基本运算 加减法 三角形两边之和大于第三边 \\[ \\lvert {z_1+z_2}\\rvert \\leq\\lvert {z1}\\rvert+\\lvert {z_2}\\rvert \\] 乘法 两个复数相乘等于它们 的模相乘，幅角相加 \\[ z_1z_2=\\rho_1\\rho_2[cos(\\varphi_1+\\varphi_2)+isin(\\varphi_1+\\varphi_2)]\\\\ =\\rho_1\\rho_2e^{[i(\\varphi_1+\\varphi_2)]} \\] 乘方 可由乘法规则得到，用 个 相乘 \\[ z^n=\\rho^ne^{in\\varphi} \\] 棣莫弗(De Moivre)公式 \\[ (\\cos \\varphi+i\\sin \\varphi)^n=\\cos n\\varphi+i\\sin n\\varphi \\] 除法 \\[ \\frac{z_1}{z_2}=\\frac{\\rho_1}{\\rho_2} e^{i(\\varphi_1-\\varphi_2)} \\] n次根式 \\[ \\sqrt[n]{z}=\\sqrt[n]{\\rho}(\\cos\\frac{\\varphi}{n}+i\\sin\\frac{\\varphi}{n})=\\sqrt[n]{\\rho}e^{i\\frac{\\varphi}{n}} \\] 共轭复数计算 \\[ zz^*=\\lvert {z}\\rvert^2 \\] \\[ z^2=\\lvert {z}\\rvert^2=\\lvert {z^2}\\rvert \\] \\[ \\lvert {e^{ik\\varphi}}\\rvert=1 \\]","categories":[{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"复变函数","slug":"复变函数","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"python api -- script learning","slug":"Lumerical/python api的语法","date":"2022-07-15T09:49:03.330Z","updated":"2022-07-21T13:18:02.784Z","comments":true,"path":"2022/07/15/Lumerical/python api的语法/","link":"","permalink":"http://example.com/2022/07/15/Lumerical/python%20api%E7%9A%84%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Session management - Python API – Ansys Optics 本文将演示Lumerical工具与Python集成开发以完成复杂的自动化工作流程，并且执行高级数据处理以及绘画。 使用Python API可以实现互联，Python API是一个称为\\(lumapi\\)的Python库。 建议将Lumerical和Python的文件放在统一文件夹 启用Lumerical-Python API关键需要连接lumapi.py文件的连接。 使用脚本命令和传递数据,可以参考Script commands as methods - Python API,和Passing Data - Python API. import module 导入lumapi lumerical的solver已经附带了Python3发行版。 1import lumapi 导入前先导入python 使用\\(sys.path.append()\\)方法将\\(lumapi\\)目录临时添加到路径中。 1234import sys, ossys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v222\\\\api\\\\python\\\\&quot;) #Default windows lumapi pathsys.path.append(&quot;/opt/lumerical/v222/api/python/lumapi.py&quot;) #Default linux lumapi pathsys.path.append(os.path.dirname(__file__)) #Current directory starting a session 调用构造函数 1fdtd = lumapi.FDTD() You can create multiple sessions of the same product and different products at once, as long as they all have unique names. 123mode1 = lumapi.MODE()mode2 = lumapi.MODE()device = lumapi.DEVICE() 构造函数支持以下可选参数： hide（默认为False）：在启动的时候显示或者隐藏lumeric GUI/CAD 环境 filename(默认为空)：如果新的应用程序时空的，则启动这个应用程序，如果提供lsf文件，则运行脚本。如果提供了项目文件名，将尝试加载项目 12# loads and runs script.lsf while hiding the application windowinc = lumapi.INTERCONNECT(filename=&quot;script.lsf&quot;, hide=True) Import Methods 除了在Python中定义函数，用户还可以使用lumapi的自动同步函数功能，并且导入Lumerical脚本文件中预定义的函数。使用“eval”命令执行脚本后，可以在 lumapi 中将这些方法称为预定义的方法。 下面是从脚本文件“testScript.lsf”和script format string导入函数的示例。 123456789fdtd = lumapi.FDTD()# import function defined in script format stringfdtd .eval(&quot;function helloWorld() &#123; return \\&quot;hello world\\&quot;; &#125;\\nfunction returnFloat() &#123; return 1.; &#125;\\nfunction addTest(a, b)&#123; return a*b; &#125;&quot;)print(fdtd .helloWorld())# import function defined in the script file &quot;testScript.lsf&quot;code = open(&#x27;C:/XXX/testScript.lsf&#x27;, &#x27;r&#x27;).read()fdtd .eval(code) 该脚本还可以作为构造函数中的参数传递，以定义方法： 12345678def testAddingMethodsFromConstructor(self):app = self.appConstructor(script=&quot;any_product_script_workspace_functions_available_in_python_test.lsf&quot;)expectedMethods = &#123;&#x27;helloWorld&#x27;&#125;expectedResults = [&#x27;hello world from script file&#x27;]results = []results.append(app.helloWorld())self.assertEqual(results, expectedResults)app.close() Advanced session management 当变量超过了作用域之后，他们将会被自动删除，当所有指向它的变量引用被删除时，Lumerical 会话将自动关闭。 Wrapping the session in a function 在Python中，如果需要运行大量类似的实例，可以使用函数；比如，在扫描一些可选的参数的时候，有关如何返回重要结果，请参阅passing data - Python API 1234def myFunction(someOptionalParameter): fdtd = lumapi.FDTD() ... return importantResult Using the \"with\" context manager 我们可以通过Python中的\"with\"语句，来给出一个良好的entrance and exit behavior 来打开Lumerical session。在\"with\"语句块中,有任何的错误，这会话依旧可以被成功地关闭。任何平常在Lumerical script environment能看到的报错，会将在Python的环境中显示出来。 123456with lumapi.FDTD(hide=True) as fdtd: fdtd.addfdtd() fdtd.setnamed(&quot;bad name&quot;) ## you will see LumApiError: &quot;in setnamed, no items matching the name &#x27;bad name&#x27; can be found.&quot; ...## fdtd still successfully closes hide (default to False): Shows or hides the lumerical GUI/CAD environment on startup filename (default empty): Launches a new application if it is empty, and will run the script if an lsf file is provided. If a project filename is provided; it will try and load the project if it can be found in the path. See the section setting the python path before importing to add folder or use the full path to load files from other directories. 此示例演示如何从优化中访问数据。 1234567891011121314151617181920212223242526m=&quot;thickness_optimization&quot;;?getsweepdata(m);genVec = getsweepdata(m,&quot;genVec&quot;); # Generation vector (1D vector, Ng)memberVec = getsweepdata(m,&quot;memberVec&quot;); # Generation member vector (1D vector, Nm)fomTrend = getsweepdata(m,&quot;fomTrend&quot;); # Best of each generation, same as shown in Opt. GUI window (1D vector, Ng)paramsTrend = getsweepdata(m,&quot;paramsTrend&quot;); # Parameters corresponding to FOM trend (3D matrix, 1 x Np x Ng)bestFom = getsweepdata(m,&quot;bestFom&quot;); # Global best FOMbestParams = getsweepdata(m,&quot;bestParams&quot;); # Parameters corresponding to global best FOM (1D vector, Np)fomHistory = getsweepdata(m,&quot;fomHistory&quot;); # Every FOM calculated in optimization (2D maxtrix, Nm x Ng)paramHistory = getsweepdata(m,&quot;paramHistory&quot;); # Every parameter set used in optimization (3D maxtrix, Np x Nm x Ng)plot(genVec,fomTrend,&quot;generation number&quot;,&quot;fom Trend&quot;,&quot;best FOM of each generation&quot;); ?&quot;Best FOM: &quot;+num2str(bestFom);?&quot;Best Params: &quot;+num2str(bestParams);?&quot;Total number of simulations run: &quot;+num2str(length(genVec)*length(memberVec));image(memberVec,genVec,fomHistory,&quot;member&quot;,&quot;generation&quot;,&quot;All FOM&#x27;s obtained&quot;);&gt; genVec&gt; memberVec&gt; paramsTrend&gt; fomTrend&gt; paramHistory&gt; fomHistory&gt; bestParams&gt; bestFom&gt; Best FOM: 0.00187328&gt; Best Params: 5.96041e-008&gt; Total number of simulations run: 50 Simulation Objects 添加对象时，其构造函数可用于在创建时设置属性的值。 1fdtd.addfdtd(dimension=&quot;2D&quot;, x=0.0e-9, y=0.0e-9, x_span=3.0e-6, y_span=1.0e-6) 在Python中，字典排序不能保证，因此，如果存在依赖于其他属性的属性，则需要有序字典。例如，在Python的以下行中，“覆盖全局监视器设置”必须为true，然后才能设置“frequency points”。 123props = OrderedDict([(&quot;name&quot;, &quot;power&quot;),(&quot;override global monitor settings&quot;, True),(&quot;x&quot;, 0.),(&quot;y&quot;, 0.4e-6), (&quot;monitor type&quot;, &quot;linear x&quot;),(&quot;frequency points&quot;, 10.0)])fdtd.addpower(properties=props) 如果您没有具有依赖项的属性，则可以使用常规的Python字典。 12345props = &#123;&quot;name&quot;: &quot;power&quot;, &quot;x&quot; : &quot;0.0&quot;, &quot;y&quot; : 0.4e-6&quot;, &quot;monitor type&quot; : &quot;linear x&quot;&#125;fdtd.addpower(properties=props) simulation objection 将新对象添加到 Lumerical 文件时，将返回一个representative Python 对象。此对象可用于对 Lumerical 产品中的相应对象进行更改。 123rectangle = fdtd.addrect(x = 2e-6, y = 0.0, z = 0.0)rectangle.x = -1e-6rectangle.x_span = 10e-6 Parent and children access The tree of objects可以使用对象的父类或子项进行遍历 1234567891011121314device.addstructuregroup(name=&quot;A&quot;)device.addrect(name=&quot;in A&quot;)device.addtogroup(&quot;A&quot;)device.addstructuregroup(name=&quot;B&quot;)device.addtogroup(&quot;A&quot;)bRect = device.addrect(name=&quot;in B&quot;)device.addtogroup(&quot;A::B&quot;)# Go up two parents from the rectangle in &quot;B&quot; groupaGroup = bRect.getParent().getParent()# Print the names of all members of &quot;A&quot; groupfor child in aGroup.getChildren(): print child[&quot;name&quot;]","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"script","slug":"script","permalink":"http://example.com/tags/script/"}]},{"title":"High-effciency grating-couplers:demonstration of a new design  strategy","slug":"文献阅读记录/文献阅读-三-反向设计","date":"2022-07-14T12:38:42.038Z","updated":"2022-07-21T13:48:33.105Z","comments":true,"path":"2022/07/14/文献阅读记录/文献阅读-三-反向设计/","link":"","permalink":"http://example.com/2022/07/14/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB-%E4%B8%89-%E5%8F%8D%E5%90%91%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"Abstract 一种简单且实用的设计光栅耦合器的方法 基于两个方面优化，变迹光栅的参数和刻蚀深度 变迹光栅的参数有两个，光栅周期与占空比 在260nm的SOI硅平台上进行优化 仿真耦合效率达到了0.8db（83%），实际制造后的结果为0.9db（81%） 不使用反射结构 Body 背景 如何将光纤中的光耦合进波导中——边缘耦合，光栅耦合 边缘耦合的优缺点： 耦合效率高，能够达到0.5dB 对工艺要求高 光栅耦合的优缺点： 可放置于芯片的任意位置；对准容差较高；可量产 耦合效率低（通常低于61%；光栅方向性低，模场失配），带宽窄（一般为30-40nm） 均匀光栅的光强分布主要以指数衰减，不能很好地匹配高斯分布的入射光 光栅方向性低： 增加DBR反射镜或者金属反射镜（工艺困难） 模场失配： 采用变迹光栅 变迹光栅的设计 在标准SOI上的GC，刻蚀区域的长度为\\(L_E\\)，刻蚀深度为\\(e\\)，周期为\\(Λ\\)，占空比为\\(F\\)，我们就可以得到有效折射率\\(n_{eff}\\)的公式: \\[ n_{eff}=F\\cdot n_O+(1-F)\\cdot n_E \\] \\(n_O\\)和\\(n_E\\)分别是初始硅薄片以及刻蚀过的硅薄片的有效折射率。刻蚀区域和未刻蚀区域的有效折射率的周期性变化，这使得光学mode在硅波导被衍射到free space。根据布拉格条件，光栅周期可以这样子计算： \\[ Λ=\\frac{λ_c}{n_{eff}-n_{bg}sin\\theta} \\] 其中，\\(\\lambda_c\\)是中心耦合波长，\\(\\theta\\)是入射角度，\\(n_{eff}\\) 是光栅单元的有效折射率。从一个标准的光栅耦合器的基本结构，我们决定引入线性变迹的结构。通过线性地改变占空比，可以实现两个积极的效果，提高波导与光栅部分的光阻抗匹配（有点不太清楚），降低光栅第一元件的辐射的光功率量。 \\[ F(x)=F_0-R \\cdot x \\] R是切趾系数，x是每个光栅单元到光栅起始点的距离 变迹光栅以前常常是使用numerical techniques,比如遗传算法 第一算力要求大,耗时长 第二这种方法不能给出物理含义上的那种最高耦合效率(只是单纯计算,并没有从原理去分析) $$ $$ 以前优化方案是将周期固定，占空比调整，现在的优化方案是周期和占空比都不固定。 固定周期会阻止了所有的光栅元件同时满足布拉格条件","categories":[{"name":"大创文献","slug":"大创文献","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"}],"tags":[{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"}]},{"title":"inverse design of grating coupler -- process presentation","slug":"Lumerical/inverse design 过程展示","date":"2022-07-13T10:46:09.671Z","updated":"2022-10-02T16:39:42.871Z","comments":true,"path":"2022/07/13/Lumerical/inverse design 过程展示/","link":"","permalink":"http://example.com/2022/07/13/Lumerical/inverse%20design%20%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA/","excerpt":"","text":"步骤1：定义基本仿真参数 在mode下打开模拟文件 pid_grating_coupler_preliminary_design.lms 修改所需的基本仿真参数，保存文件。 打开脚本文件 pid_grating_coupler_preliminary_design.lsf 修改参数并运行脚本 结果展示 第一个是所需的中心波长 第二个是\\(X_0\\)，光栅的起始点 第三个是切趾系数R 第四个是 neff_thin - index_SiO2*sin(theta)(具体叫什么我也不太清楚) 第五个是有效折射率的差值(neff_thick - neff_thin) 脚本pid_grating_coupler_preliminary_grating_design.lsf 将会计算这些初始参数，并将结果保存在pid_grating_coupler_initial_params.json文件中，以便下一步使用。 步骤二：使用2D FDYD优化切趾光栅 我们首先需要找到光纤的最佳位置。 用FDTD的编译器打开python脚本pid_grating_coupler_sweep_2D.py 如果需要的话，可以修改参数。 运行脚本 这个脚本会进行一个光源位置的扫描 pid_grating_coupler_sweep_2D.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&quot;&quot;&quot; Copyright (c) 2020 Ansys Inc. &quot;&quot;&quot; ######## IMPORTS ######### General purpose importsimport os,syssys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v211\\\\api\\\\python\\\\&quot;)import scipy as spimport numpy as npimport jsonfrom lumjson import LumEncoder, LumDecoderimport lumapi######## OPTIMIZABLE GEOMETRY ########lambda_c = 1.55e-6 bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401data_file = &quot;pid_grating_coupler_initial_params.json&quot;base_file = &quot;pid_grating_coupler_2D_TE_base.fsp&quot;def grating_params_pos(params, n_grates): y0 = 0 y3 = y0+height y1 = y3-etch_depth x_start = params[0]*1e-6 #&lt; First parameter is the starting position R = params[1]*1e6 #&lt; second parameter (unit is 1/um) a = params[2] #&lt; Third parameter (dim-less) b = params[3] #&lt; Fourth parameter (dim-less) x0 = x_start verts = np.array( [[x_begin,y0],[x_begin,y3],[x0,y3],[x0,y1]] ) ## Iterate over all but the last tooth for i in range(n_grates-1): F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region x2 = x0 + Lambda #&lt; Rest of cell verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x2,y3],[x2,y1]])),axis=0) x0 = x2 ## Last tooth is special F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x_end,y3],[x_end,y0]])),axis=0) return vertsif __name__ == &quot;__main__&quot;: with open(data_file) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;][0] # Alternate starting point # initial_params = [ -2.5, 0.03, 2.4, 0.5369] vtx = grating_params_pos(initial_params, 25) if os.path.exists(base_file): with lumapi.FDTD(filename=base_file) as fdtd: fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.setglobalsource(&quot;center wavelength&quot;, lambda_c) fdtd.setglobalsource(&quot;wavelength span&quot;, 0) fdtd.save() fdtd.runsweep(&quot;sweep source position&quot;) sweep_pos = fdtd.getsweepdata(&quot;sweep source position&quot;, &quot;x&quot;) sweep_T = fdtd.getsweepdata(&quot;sweep source position&quot;, &quot;T&quot;) Tmax = np.amax(sweep_T) Tpos = sweep_pos[np.where(sweep_T == np.amax(sweep_T))[0][0]][0] print(&quot;Max transmission:&quot;, Tmax*100, &quot;%&quot;) print(&quot;Position&quot;, Tpos*1e6, &quot;um&quot;) fdtd.setnamed(&quot;source&quot;, &quot;x&quot;, Tpos) fdtd.select(&quot;polygon&quot;) fdtd.delete() fdtd.save() else: print(&quot;base file doesn&#x27;t exist...&quot;) 运行扫描 导入的标准库 import os,sys 是导入标准库os和sys os --- 操作系统接口模块 — Python 3.7.13 文档 5. import sys — Python 3.10.5 文档 Python、Numpy 教程 | NumPy 中文 sys.path.append Adding the Python Before Importing To temporarily add the lumapi directory to your path, you can use the sys.path.append() method. This is the case if you have not yet added lumapi to your search path, and it is also useful when adding directories of other helpful lsf, fsp, py files. The following code adds the lumapi folder and current file directory. 123456import sys, ossys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v222\\\\api\\\\python\\\\&quot;) #Default windows lumapi pathsys.path.append(&quot;/opt/lumerical/v222/api/python/lumapi.py&quot;) #Default linux lumapi pathsys.path.append(os.path.dirname(__file__)) #Current directoryimport sys sys.path.append(’需要引用模块的地址&#x27;)# sys.path.append(&quot;..&quot;) # 这代表添加当前路径的上一级目录 np.concentrate 拼接功能 python中numpy.concatenate()函数的使用 - shufeixue - 博客园 (cnblogs.com) open with as 进行文件操作 Python with as用法详解 (biancheng.net) __name__ 内置变量 【Python】name 是什么？ - 知乎 (zhihu.com) json.load json — JSON 编码器和解码器 — Python 3.10.5 文档 json.``load(fp， ， cls=None， object_hook=None， parse_float=None， parse_int=None， parse_constant=None， object_pairs_hook=None， kw*)¶ addpoly 将多边形添加到模拟文件中。多边形对象使用一组x，y坐标（顶点）在xy平面中定义一个多边形，然后在z方向上拉伸该多边形以创建3D几何图形。 Syntax Description addpoly; Adds a polygon primitive to the simulation environment.This function does not return any data. 样例 以下的脚本创建一个2D矩阵来存储多边形的顶点，并且使用它来创建多边形基元 12345vtx = [1,0;2,2;4,2;4,1;3,1]*1e-6; # micronsaddpoly;set(&quot;name&quot;,&quot;random_polygon&quot;);set(&quot;vertices&quot;,vtx);set(&quot;z span&quot;,2e-6); setglobalsource 设置全局光源的属性。这个命令将返回analysis mode的error Syntax Description ?setglobalsource; Returns a list of the global source properties setglobalsource(\"property\",value); Set the global source property named \"property\" to a value.This function does not return any data. 样例 将全局的起始波长设置400nm，然后确定值是否正确 1234setglobalsource(&quot;wavelength start&quot;,400e-9);?getglobalsource(&quot;wavelength start&quot;);result: 4e-007 save 保存项目文件。如果模拟已经运行，则该文件还将包含模拟结果，例如扫描和优化数据。 Syntax Description save; Open a file browser to save the file.This function does not return any data. save(filename); Save with the specified name to the current working directory. A path can be specified. 例子 保存当前的文件 12save(&quot;project_name&quot;); # saves the file in the current working directorysave(&quot;C:\\Downloads\\project_name.fsp&quot;) # saves the file in a path specified getsweepdata Gets raw data from a parameter sweep/optimization/Monte Carlo analysis. 在大多数情况下，使用getsweeoresult获取完整的数据集比getsweeodata获取单个数据元素更方便。 Syntax Description ?getsweepdata; Returns names of all sweep, optimization, and Monte Carlo analysis objects. ?getsweepdata(\"sweep_name\"); Returns all the names of the available data which is stored in the sweep, optimization, or Monte Carlo analysis object. out = getsweepdata(\"sweep_name\", \"data\"); Returns parameter sweep, optimization, or Monte Carlo analysis data.The following data can be obtained from an optimization:fomTrend - Figure of merit as a function of generationfomHistory - Figure of merit history (for each generation there will be generation size number)bestFom - Best figure of merit obtained during sweepbestParameter - Parameter which corresponds to bestFomparamHistory - Parameter historyFor a parameter sweep and Monte Carlo analysis, this command returns both parameters and results. 例子 12345678m=&quot;thickness_sweep&quot;;?getsweepdata(m);th = getsweepdata(m,&quot;thickness&quot;); # get parameter from sweepR = getsweepdata(m,&quot;R&quot;);# get result from sweepplot(th*1e6,R,&quot;thickness (microns)&quot;,&quot;Reflection&quot;);&gt; R&gt; T&gt; thickness setnamed Syntax Description ?setnamed(\"name\"); Returns a list of the properties of the objects called name. setnamed(\"name\", \"property\", value); The same as set, but acts on objects with a specific name, instead of selected objects. setnamed(\"name\", struct); A struct can be accepted in place of \"property\"-value pair of arguments. setnamed(\"name\", \"property\", value,i); This form can be used to set the property of the ith named object when multiple objects have the same name.The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. setnamed(\"groupname::name\", \"property\", value); The same as set, but acts on objects within the group named \"groupname\" that are named \"name\", instead of selected objects. setnamed(\"groupname::name\", \"property\", value,i); This form can be used to set the property of the ith object with the name \"name\" in the group \"groupname\" when multiple objects have the same name.The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. Examples Set the radius of the object called \"circle\" to 10nm: 1setnamed(&quot;circle&quot;,&quot;radius&quot;,10e-9); 用FDTD脚本编辑器,打开python 脚本 pid_grating_coupler_2D_apodized.py 如果需要的话,更新参数,并且运行脚本 打开脚本pid_grating_coupler_2D_1etch.py 运行脚本 pid_grating_coupler_2D_apodized.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125##&quot;&quot;&quot; ## Copyright (c) 2020 Ansys Inc. &quot;&quot;&quot;######## IMPORTS ######### General purpose importsimport os,sysimport numpy as npimport scipy as spimport jsonsys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v211\\\\api\\\\python\\\\&quot;)from lumjson import LumEncoder, LumDecoder# Optimization specific importsfrom lumopt.utilities.load_lumerical_scripts import load_from_lsffrom lumopt.utilities.wavelengths import Wavelengthsfrom lumopt.geometries.parameterized_geometry import ParameterizedGeometryfrom lumopt.geometries.polygon import FunctionDefinedPolygonfrom lumopt.figures_of_merit.modematch import ModeMatchfrom lumopt.optimizers.generic_optimizers import ScipyOptimizersfrom lumopt.optimization import Optimizationfrom lumopt.utilities.materials import Materialimport lumapicur_path = os.path.dirname(os.path.realpath(__file__))# Optimization global parameterslambda_c = 1.55e-6 bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401params_file = &quot;pid_grating_coupler_initial_params.json&quot;base_sim_2d = &quot;pid_grating_coupler_2D_TE_base.fsp&quot;base_sim_apodized_2d = &quot;pid_grating_coupler_2D_TE_base_apodized.fsp&quot;base_script_2d = &#x27;pid_grating_coupler_2D_TE_base.lsf&#x27;params_file_apod = &quot;pid_optim_1.json&quot;def grating_params_pos(params): y3 = y0+height y1 = y3-etch_depth x_start = params[0]*1e-6 #&lt; First parameter is the starting position R = params[1]*1e6 #&lt; second parameter (unit is 1/um) a = params[2] #&lt; Third parameter (dim-less) b = params[3] #&lt; Fourth parameter (dim-less) x0 = x_start verts = np.array( [[x_begin,y0],[x_begin,y3],[x0,y3],[x0,y1]] ) ## Iterate over all but the last tooth for i in range(n_grates-1): F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region x2 = x0 + Lambda #&lt; Rest of cell verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x2,y3],[x2,y1]])),axis=0) x0 = x2 ## Last tooth is special F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x_end,y3],[x_end,y0]])),axis=0) return verts def get_vertices_from_distances(self, x_start, distances): #x_start = params[0]*1e-6 #&lt; First parameter is the starting position #R = params[1]*1e6 #&lt; second parameter (unit is 1/um) #a = params[2] #&lt; Third parameter (dim-less) #b = params[3] #&lt; Fourth parameter (dim-less) x_begin = self.x_min-2e-6 x = np.cumsum(np.concatenate(([x_start],distances))) y0 = 0 y3 = y0+self.wg_height y1 = y3-self.etch_depth verts = np.array( [[x_begin,y0],[x_begin,y3],[x[0],y3]] ) ## Iterate over all but the last tooth for i in range(1,len(x),2): verts = np.concatenate((verts,np.array([[x[i-1],y1],[x[i],y1],[x[i],y3],[x[i+1],y3]])),axis=0) ## Close off the polygon verts = np.concatenate((verts,np.array([[x[-1],y0]])),axis=0) return vertsif __name__ == &quot;__main__&quot;: with open(os.path.join(cur_path, params_file)) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;][0] with lumapi.FDTD(filename = os.path.join(cur_path, base_sim_2d), hide = True) as fdtd: vtx = grating_params_pos(initial_params) fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.save(os.path.join(cur_path, base_sim_apodized_2d)) # extracting the distsnces from vertices vx=np.array(vtx) vertsx=vx[2:(len(vx)-2):2,0] vert_x = np.concatenate(([np.array(vx[2,0])],(vertsx[1:]-vertsx[0:len(vertsx)-1]))) vert_x = vert_x *1e6 with open(os.path.join(cur_path, params_file_apod), &quot;w&quot;) as fh: json.dump(&#123; &quot;initial_params&quot;: vert_x &#125;, fh, cls=LumEncoder, indent = 4) os.path.dirname 语法：os.path.dirname(path) 功能：去掉文件名，返回目录 123print(os.path.dirname(&quot;E:/Read_File/read_yaml.py&quot;))#结果：E:/Read_File os.path.dirname(__file__) 123print(__file__)#结果E:/Read_File/read_yaml.py 可以看出__file__表示了当前文件的path 那么就可以了解到os.path.dirname((__file__)和os.path.dirname(“E:/Read_File/read_yaml.py”)是一个意思 再根据os.path.dirname(path)的用法，得出os.path.dirname((__file__)就是得到当前文件的绝对路径 123print(os.path.dirname(__file__))#结果：E:/Read_File set 设置当前选中对象的属性 当求解器处于分析模式时,无法修改 Syntax Description ?set; Returns a list of the properties of the selected object(s). set(\"property\",value); This will set the properties of a currently selected object, including pull-downs and check boxes. It cannot be used to set the value of a selected object in a group.Value can be a number or string. This function does not return any data. set(struct); A struct can be accepted in place of \"property\"-value pair of arguments. set(\"property\",value,i); This form can be used to set the property of the ith selected object when multiple objects are selected. It cannot be used to set the value of a selected object in a group.The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. 多边形的搭建 一个典型的多边形结构可以由如下代码生成： 123456789101112um=1e-6;nm=1e-9;vtx=[2,0;1,1;-1,1; -2,0;-1,-1;1,-1]*um; #向量组addpoly;set(&quot;name&quot;,&quot;poly&quot;);#名称set(&quot;index&quot;,1.5);#折射率set(&quot;vertices&quot;,vtx);#控制向量组set(&quot;x&quot;,0.5*um);#中心坐标set(&quot;y&quot;,1*um);set(&quot;z&quot;,-0.5*um);set(&quot;z span&quot;,0.4*um);#z方向宽度 addpoly：添加一个参数随机的多边形结构。 set(“index”,1.5)：折射率。多边形材料为介电材料，折射率为1.5 set(“vertices”,vtx)：向量组。设置多边形的xy面二维形状，由传入的向量组vtx中的参数控制 关于vtx中的参数解释： vtx是一个n*2的矩阵，每一行都是多边形上一个顶点的相对坐标，以设置的\"x\",“y”,\"z\"参数作为相对坐标原点，按在矩阵中的顺序顺次连接成多边形。 os.path.join os.path.join()函数用于路径拼接文件路径，可以传入多个路径 如果不存在以‘’/’开始的参数，则函数会自动加上 123&gt;&gt;&gt; import os&gt;&gt;&gt; print(os.path.join(&#x27;path&#x27;,&#x27;abc&#x27;,&#x27;yyy&#x27;))path\\abc\\yyy 存在以‘’/’’开始的参数，从最后一个以”/”开头的参数开始拼接，之前的参数全部丢弃。 1234567891011121314&gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;aaa&#x27;,&#x27;/bbb&#x27;,&#x27;ccc.txt&#x27;))1 /bbb\\ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;/bbb&#x27;,&#x27;ccc.txt&#x27;))1 /bbb\\ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;/bbb&#x27;,&#x27;/ccc.txt&#x27;))1 /ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc.txt&#x27;))1 /aaa\\bbb\\ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;bbb&#x27;,&#x27;/ccc.txt&#x27;))1 /ccc.txt (106条消息) os.path.join()函数用法详解_swan777的博客-CSDN博客_os.path.join函数 os.path.realpath(__file__) 获得当前脚本的绝对路径 np.array (106条消息) numpy.array函数详解_双木青橙的博客-CSDN博客_numpy.array python 数组操作 (106条消息) numpy 对二维数组的常用操作_地球被支点撬走啦的博客-CSDN博客_numpy二维数组 py的切片索引是start : end : step python数组切片 [(106条消息) python中 x:,0]和x[:,1] 理解和实例解析_jobschu的博客-CSDN博客_x[:,0] x[m,n]是通过numpy库引用数组或矩阵中的某一段数据集的一种写法 json.dump jsonPython模块中的模块提供了一种称为dump()它将Python对象转换为适当的json对象。它是dumps()方法。 dump()及其参数 1用法： json.dump(d, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None) Python json.dump()用法及代码示例 - 纯净天空 (vimsky.com) np.cumsum Numpy.cumsum（） 用法 ( np.cumsum) - 简书 (jianshu.com) 累加 pid_grating_coupler_2D_1etch.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#&quot;&quot;&quot;#Copyright (c) 2020 Ansys Inc. &quot;&quot;&quot;######## IMPORTS ######### General purpose importsimport os,sysimport numpy as npimport scipy as spimport jsonsys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v211\\\\api\\\\python\\\\&quot;)from lumjson import LumEncoder, LumDecoder# Optimization specific importsfrom lumopt.utilities.load_lumerical_scripts import load_from_lsffrom lumopt.utilities.wavelengths import Wavelengthsfrom lumopt.geometries.parameterized_geometry import ParameterizedGeometryfrom lumopt.geometries.polygon import FunctionDefinedPolygonfrom lumopt.figures_of_merit.modematch import ModeMatchfrom lumopt.optimizers.generic_optimizers import ScipyOptimizersfrom lumopt.optimization import Optimizationfrom lumopt.utilities.materials import Materialimport lumapicur_path = os.path.dirname(os.path.realpath(__file__))# Optimization global parameterslambda_c = 1.55e-6bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401params_file_apod = &quot;pid_optim_1.json&quot;params_final = &quot;pid_optim_final.json&quot;base_sim_2d = &quot;pid_grating_coupler_2D_TE_base.fsp&quot;base_sim_apodized_2d = &quot;pid_grating_coupler_2D_TE_base_apodized.fsp&quot;base_script_2d = &#x27;pid_grating_coupler_2D_TE_base.lsf&#x27;sim_2d_final = &quot;pid_grating_coupler_2D_final.fsp&quot;# Minimal feature size in um. Set to 0.1 to enforce 100nm min features size!min_feature_size = 0.1def etched_grating(params, fdtd, update_only = False): verts = grating_params_pos(params) if not update_only: fdtd.addpoly() fdtd.set(&quot;name&quot;, &quot;grating_poly&quot;) fdtd.setnamed(&quot;grating_poly&quot;, &quot;vertices&quot;, verts) fdtd.setnamed(&quot;grating_poly&quot;, &quot;x&quot;, 0) fdtd.setnamed(&quot;grating_poly&quot;, &quot;y&quot;, y0) fdtd.setnamed(&quot;grating_poly&quot;, &quot;index&quot;, indexSi)def grating_params_pos(params, output_waveguide_length = 0.5e-6): y3 = y0+height y1 = y3-etch_depth x0 = params[0]*1e-6 #&lt; First parameter is the starting position verts = np.array( [ [x_begin,y0],[x_begin,y3],[x0,y3],[x0,y1] ] ) ## Iterate over all but the last for i in range(n_grates-1): x1 = x0 + params[i*2+1]*1e-6 #&lt; Width of the etch x2 = x1 + params[i*2+2]*1e-6 #&lt; Width up verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x2,y3],[x2,y1]])),axis=0) x0 = x2 x1 = x0 + params[(n_grates-1)*2+1]*1e-6 #&lt; Width of the etch # x_end = x1+output_waveguide_length verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x_end,y3],[x_end,y0]])),axis=0) return vertsdef runGratingOptimization(bandwidth_in_nm, etch_depth, n_grates, initial_params, min_feature_size, working_dir):### Yet another parametrization which allows to enforce minimum feature size when the optimizer only supports box constraints### params = [x0, a1, b1, ..., aN] if initial_params is None: params = np.zeros(2*n_grates) for i in range(n_grates): params[i*2] = 0.2 #&lt; Width up params[i*2+1] = 0.4*((i+1)/(n_grates+1)) #&lt; Width of the deep etch params[0] = 0 #&lt; Overwrite the first since it has a special meaning: Start of the grating at x=0 else: params = initial_params bounds = [(min_feature_size, 1)]*(2*n_grates) bounds[0] = (-3,3) #&lt; Bounds for the stating position# geometry = ParameterizedGeometry(func = etched_grating,# initial_params = params,# bounds = bounds,# dx = 1e-5) geometry = FunctionDefinedPolygon(func = grating_params_pos, initial_params = params, bounds = bounds, z = 0.0, depth = height, eps_out = indexSiO2 ** 2, eps_in = indexSi ** 2, edge_precision = 5, dx = 1e-5)######## DEFINE FIGURE OF MERIT ######## fom = ModeMatch(monitor_name = &#x27;fom&#x27;, mode_number = 1, direction = &#x27;Backward&#x27;, target_T_fwd = lambda wl: np.ones(wl.size), norm_p = 1) ######## DEFINE OPTIMIZATION ALGORITHM ######## optimizer = ScipyOptimizers(max_iter = 250, method = &#x27;L-BFGS-B&#x27;, scaling_factor = 1, pgtol = 1e-6) ######## DEFINE BASE SIMULATION ######## base_script = load_from_lsf(os.path.join(os.path.dirname(__file__), base_script_2d))######## PUT EVERYTHING TOGETHER ######## lambda_start = lambda_c*1e9 - bandwidth_in_nm/2 lambda_end = lambda_c*1e9 + bandwidth_in_nm/2 lambda_pts = int(bandwidth_in_nm/10)+1 wavelengths = Wavelengths(start = lambda_start*1e-9, stop = lambda_end*1e-9, points = lambda_pts) opt = Optimization(base_script = base_script, wavelengths = wavelengths, fom = fom, geometry = geometry, optimizer = optimizer, use_var_fdtd = False, hide_fdtd_cad = False, use_deps = True, plot_history = True, store_all_simulations = True, save_global_index = False, label = None)######## RUN THE OPTIMIZER ######## result = opt.run(working_dir=working_dir) return resultif __name__ == &quot;__main__&quot;: params_file = params_file_apod result_file = params_final sim_file = sim_2d_finalwith open(os.path.join(cur_path, params_file)) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;]cur_path = os.path.dirname(os.path.realpath(__file__))working_dir = os.path.join(cur_path,&#x27;FreeGrating_1etch&#x27;)opt_result_2D = runGratingOptimization(bandwidth_in_nm=bandwidth_in_nm,etch_depth=etch_depth,n_grates = n_grates,initial_params=initial_params,min_feature_size=min_feature_size,working_dir=working_dir)opt_params_2D = opt_result_2D[1]with open(os.path.join(cur_path, result_file), &quot;w&quot;) as fh: json.dump(&#123; &quot;initial_params&quot;: opt_params_2D &#125;, fh, cls=LumEncoder, indent = 4)np.savetxt(os.path.join(cur_path, &quot;apod_2D_params.txt&quot;), opt_params_2D)######## 2-D SIMULATION WITH OPTIMIZED STRUCTURE ########with lumapi.FDTD(filename = os.path.join(cur_path, base_sim_2d), hide = True) as fdtd: vtx = grating_params_pos(opt_params_2D) fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.save(os.path.join(cur_path, sim_file)) np.zero 用法：zeros(shape, dtype=float, order='C') 返回：返回来一个给定形状和类型的用0填充的数组； 参数：shape:形状 ​ dtype:数据类型，可选参数，默认numpy.float64 ​ dtype类型：t ,位域,如t4代表4位 ​ b,布尔值，true or false ​ i,整数,如i8(64位） ​ u,无符号整数，u8(64位） ​ f,浮点数，f8（64位） ​ c,浮点负数， ​ o,对象， ​ s,a，字符串，s24 ​ u,unicode,u24 ​ order:可选参数，c代表与c语言类似，行优先；F代表列优先 例子 np.zeros(5) array([ 0., 0., 0., 0., 0.]) geometry parameterizedGeometry 在此示例中，我们使用函数 FunctionDefinedPolygon 将光栅耦合器几何图形设置为多边形。或者，我们可以改用函数ParametrizedGeometry，从而在几何形状的设置方式上提供更大的灵活性。 12bounds = [(min_feature_size, 1)]*(2*n_grates)bounds[0] = (-3,3) #&lt; Bounds for the stating position 1234# geometry = ParameterizedGeometry(func = etched_grating,# initial_params = params,# bounds = bounds,# dx = 1e-5) FunctionDefinedPolygon 123456789geometry = FunctionDefinedPolygon(func = grating_params_pos,initial_params = params,bounds = bounds,z = 0.0,depth = height,eps_out = indexSiO2 ** 2,eps_in = indexSi ** 2,edge_precision = 5,dx = 1e-5) dx 是最小网格 bounds是每个参数的取值范围。 eps_out = indexSiO2 ** 2, eps_in = indexSi ** 2, # 有效折射率的平方 : eps_in: float 多边形材料的介电常数。 : eps_out: float 多边形周围材料的介电常数。 dx: float &gt; 0.0 使用介电常数扰动计算 FOM 梯度的步长。 Default = 1e-5 ** 幂 - 返回x的y次幂 : edge_precision: int Number of quadrature(正交) points along each edge for computing the FOM gradient using the shape derivative approximation method. 不太知道为什么是5 沿每条边的正交点数，用于使用形状导数近似方法计算 FOM 梯度。 fom设置 Lumerical Python API学习（七）——可视化几何 - it610.com 12345678from lumopt.figures_of_merit.modematch import ModeMatchclass ModeMatch(monitor_name, mode_number, direction, target_T_fwd, norm_p, target_fom) 12345fom = ModeMatch(monitor_name = &#x27;fom&#x27;,mode_number = 1,direction = &#x27;Backward&#x27;,target_T_fwd = lambda wl: np.ones(wl.size),norm_p = 1) mode_number = 1 意味着TE mode direction = backward 方向 monitor_name: str 文件中 FOM 监视器的名称。 mode_number : str or int 用于指定模式。 如果使用 varFDTD 求解器： • ‘fundamental mode’ • int - 用户选择模式号 If the FDTD solver is used: • ‘fundamental mode’ • ‘fundamental TE mode’ • ‘fundamental TM mode’ • int - user select mode number : direction : str 方向由FDTD坐标确定； 对于在正方向传播的模式，方向是向前（forward）的。 • ‘Backward’ • ‘Forward’ : multi_freq_source: boolean（布尔值）, optional 只能由高级用户启用. See frequency Frequency dependent mode profile for more info. Default = False : target_T_fwd: float or function 一个函数，它将获取波长点的数量并返回值 [0,1]。 通常作为 lambda 函数（lambda function）或单波长 FOM 的单个浮点值传递。 要指定更高级的频谱，可以定义一个函数，使用 numpy windows作为模板可能会有所帮助。 : norm_p: float 是 FOM 计算中使用的广义 p 范数（generalized p-norm）。 p 范数（p≥1）允许用户增加误差的权重。 由于 p=1 提供了此函数的下限，因此更高的 p 数将增加误差项的权重。 默认 p =1.0 : target_fom: float 品质因数的目标值。 这只会改变打印和绘图的行为。 如果启用此功能，则通过设置 0.0 以外的值，将给出当前 FOM 的距离。 默认 = 0.0 target_T_fwd: float or function A function which will take the number of Wavelengths points and return values [0,1]. Usually passed as a lambda function or a single float value for single wavelength FOM. To specify a more advanced spectrum one can define a function, it may be helpful to use, numpy windows as a template. : norm_p: float Is the generalized p-norm used in the FOM calculation. The p-norm, with p≥1p≥1 allows the user to increase the weight of the error. Since p=1p=1 provides a lower bound on this function, a higher p-number will increase the weight of the error term. Default p =1.0 numpy.ones（） 函数参数 (numpy.ones() function arguments) numpy.ones（）函数的语法为： 1ones(shape, dtype=None, order=&#x27;C&#x27;) 1.shape：一个整数类型或者一个整数元组，用于定义数组的大小。如果仅指定一个整数类型变量，则返回一维数组。如果指定的是整数元组，则返回给定形状的数组。 2.dtype：可选参数，默认值为float。用于指定数组的数据类型。 3.order：指定内存重以行优先(‘C’)还是列优先(‘F’)顺序存储多维数组。 lambda 函数 细说Python的lambda函数用法，建议收藏 - 知乎 (zhihu.com) 1lambda argument_list:expersion optimizer 1234optimizer = ScipyOptimizers(max_iter = 250,method = &#x27;L-BFGS-B&#x27;,scaling_factor = 1,pgtol = 1e-6) : method: str Chosen minimization algorithm; experimenting with this option should only be done by advanced users. Default = ‘L-BFGS-B' : scaling_factor: none, float, np.array None, scalar or a vector the same length as the optimization parameters. This is used to scale the optimization parameters. As of 2021R1.1, the default behavior in shape optimization is to automatically map the parameters the range [0,1] within the optimization routines; which was always the case in topology. The bounds, defined in the geometry class, or eps_min/eps_max are used for this. Default = None : pgtol: float The iteration will stop when max(|proj gi| i = 1, ..., n)&lt;=pgtol|max(|proj gi| i = 1, ..., n)&lt;=pgtol| where gigi is the i-th component of the projected gradient. Default = 1.0e-5 仿真设置 1base_script = load_from_lsf(os.path.join(os.path.dirname(__file__), base_script_2d)) 合并 1234567891011121314151617######## PUT EVERYTHING TOGETHER ######## lambda_start = lambda_c*1e9 - bandwidth_in_nm/2 lambda_end = lambda_c*1e9 + bandwidth_in_nm/2 lambda_pts = int(bandwidth_in_nm/10)+1 wavelengths = Wavelengths(start = lambda_start*1e-9, stop = lambda_end*1e-9, points = lambda_pts) opt = Optimization(base_script = base_script, wavelengths = wavelengths, fom = fom, geometry = geometry, optimizer = optimizer, use_var_fdtd = False, hide_fdtd_cad = False, use_deps = True, plot_history = True, store_all_simulations = True, save_global_index = False, label = None) 运行 1234######## RUN THE OPTIMIZER ######## result = opt.run(working_dir=working_dir) return result 主函数 12345678910111213141516171819202122232425262728293031323334353637if __name__ == &quot;__main__&quot;: params_file = params_file_apod result_file = params_final sim_file = sim_2d_finalwith open(os.path.join(cur_path, params_file)) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;]cur_path = os.path.dirname(os.path.realpath(__file__))working_dir = os.path.join(cur_path,&#x27;FreeGrating_1etch&#x27;)opt_result_2D = runGratingOptimization(bandwidth_in_nm=bandwidth_in_nm,etch_depth=etch_depth,n_grates = n_grates,initial_params=initial_params,min_feature_size=min_feature_size,working_dir=working_dir)opt_params_2D = opt_result_2D[1]with open(os.path.join(cur_path, result_file), &quot;w&quot;) as fh: json.dump(&#123; &quot;initial_params&quot;: opt_params_2D &#125;, fh, cls=LumEncoder, indent = 4)np.savetxt(os.path.join(cur_path, &quot;apod_2D_params.txt&quot;), opt_params_2D)######## 2-D SIMULATION WITH OPTIMIZED STRUCTURE ########with lumapi.FDTD(filename = os.path.join(cur_path, base_sim_2d), hide = True) as fdtd: vtx = grating_params_pos(opt_params_2D) fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.save(os.path.join(cur_path, sim_file)) np.savetxt np.savetxt()——将array保存到txt文件，并保持原格式 - 深度学习1 - 博客园 (cnblogs.com)","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"inverse design","slug":"inverse-design","permalink":"http://example.com/tags/inverse-design/"}]},{"title":"inverse design of grating coupler -- script learning","slug":"Lumerical/mode 脚本","date":"2022-07-13T08:44:10.741Z","updated":"2022-07-22T01:28:33.116Z","comments":true,"path":"2022/07/13/Lumerical/mode 脚本/","link":"","permalink":"http://example.com/2022/07/13/Lumerical/mode%20%E8%84%9A%E6%9C%AC/","excerpt":"","text":"mode 脚本学习 pid_grating_coupler_preliminar_design.lsf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748## Calculate the optimal grating pitch from the effective## indices of the slab modes using the FDE solver in MODE.clear;load(&quot;pid_grating_coupler_preliminary_design&quot;);# ------------------# Design Parameters:# ------------------mode_num = 1; # TMtheta_deg = 5.0;theta = theta_deg*pi/180;setanalysis(&#x27;wavelength&#x27;,1.55e-6);?lambda = getanalysis(&quot;wavelength&quot;);index_SiO2 = 1.44401;waveguide_thickness = 220e-9;etch = 80e-9;# -----------# Slab Modes:# -----------# slab mode on thinest part of the gratingswitchtolayout;setnamed(&quot;::model&quot;, &quot;thickness&quot;, waveguide_thickness);setnamed(&quot;::model&quot;, &quot;etch_depth&quot;, etch);findmodes;neff_thin = real(getresult(&quot;FDE::data::mode&quot;+num2str(mode_num),&quot;neff&quot;));# slab mode on thickest part of the gratingswitchtolayout;setnamed(&quot;::model&quot;, &quot;thickness&quot;, waveguide_thickness);setnamed(&quot;::model&quot;, &quot;etch_depth&quot;, 0);findmodes; # first mode should be TEz slab mode confined to the gratingneff_thick = real(getresult(&quot;FDE::data::mode&quot;+num2str(mode_num),&quot;neff&quot;));# ---------------------------------# Grating Pitch Initial Parameters:# ---------------------------------F0 = 0.95;?x0 = -2.5;?R = 0.03;?a = neff_thin - index_SiO2*sin(theta);?b = neff_thick - neff_thin;initial_params = [ x0, R, a, b ];jsonsave(&quot;pid_grating_coupler_initial_params.json&quot;, initial_params); setanalysis Sets calculation parameters in MODE' FDE and FEEM analysis window. Syntax Description ?setanalysis; Lists all the parameters in the analysis window. setanalysis(\"property\", value); Sets\"property\" to value. getanalysis Syntax Description ?getanalysis; Lists all the parameters in the analysis window. getanalysis(\"property\"); Returns the current value for the particular property on the analysis window findmodes - Script command MODE Calculates the modes supported by the structure using the current calculation settings. This function is the script equivalent to the \"Calculate Modes\" button. Each mode will be saved as a D-CARD named \"modeX\", where X is the xth mode found. The D-CARD saves data such as effective index and mode profile. Syntax Description n=findmodes; n will be equal to the number of modes found. Example To perform a frequency sweep on the first mode and plot the dispersion: 1234switchtolayout;findmodes;selectmode(1);setanalysis(&quot;track selected mode&quot;,1);setanalysis(&quot;detailed dispersion calculation&quot;,1);frequencysweep;D=getdata(&quot;frequencysweep&quot;,&quot;D&quot;);f=getdata(&quot;frequencysweep&quot;,&quot;f_D&quot;);plot(c/f*1e6,D*1e6,&quot;Wavelength (um)&quot;, &quot;Dispersion (ps/nm/km)&quot;); ? ?: Display output on screen. getresult Get results from simulation objects. Results will be returned as datasets. Syntax Description ?getresult(\"monitor_name\"); Returns the names of all the results for the monitor. All the dataset and scalar matrix results will be returned in this case. R = getresult(\"monitor_name\",\"T\"); Returns the result T from the monitor. T is a dataset. Examples This example shows how to get the electric field dataset from a monitor. We then apply a number of operations to the dataset, such as finding the maximum |E|^2 value, viewing the dataset with the visualizer, and creating a plot of Ex at the first frequency point. Note that E is a dataset, rather than a simple matrix based variable. Data within the dataset can be accessed with the '.' operator, as shown below. 123456789101112131415161718192021# get Electric field datasetE=getresult(&quot;monitor&quot;,&quot;E&quot;);# output dataset value to prompt?E;# check size of position vectors and data matrices?size(E.f);?size(E.Ex);# find maximum |E|^2 value ?max(E.E2);# view dataset with visualizervisualize(E);# select first frequency point of Ex data, then create plotEx = pinch(E.Ex,4,1); image(E.x*1e6,E.y*1e6,Ex,&quot;x (um)&quot;,&quot;y (um)&quot;,&quot;Ex&quot;); E vs x, y, z, lambda/f result: 5 1 result: 343 255 1 5 result: 3.223651 num2str Converts an integer, floating point number, or matrix into a string. Matrices can only be 1D or 2D. Users can use the format script command to change the precision of the output or since the 2019b r6 releases, users can specify the format by providing a second argument to the command. Syntax Description out = num2str(x); Converts the number x into a string. x can also be a 1D or 2D matrix. The tab character (rather than space) will be used as delimiter(分隔符) between columns. out = num2str(x, format); Converts the number x into a string. x can also be a 1D or 2D matrix. The format type options include: integers : %u: unsigned integer, takes the absolute value of the input %d: decimal signed integer, rounds the input %i: decimal signed integer, rounds the input floating point : %f: double %g: double %G: double, capital 'E' used for the exponential notation exponential : %e: double %E: double, capital 'E' used for the exponential notationWith the above format type options, both width and precision can be defined for the conversion. Boost formatting can also be used. These flags appear directly after the \"%\" in the format argument: flags : +: shows sign for all numbers 0: pad to full width with leading zero","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"script","slug":"script","permalink":"http://example.com/tags/script/"}]},{"title":"Inverse Design of Grating Coupler","slug":"Lumerical/光栅耦合器的逆设计","date":"2022-07-08T09:21:04.277Z","updated":"2022-10-22T12:36:01.053Z","comments":true,"path":"2022/07/08/Lumerical/光栅耦合器的逆设计/","link":"","permalink":"http://example.com/2022/07/08/Lumerical/%E5%85%89%E6%A0%85%E8%80%A6%E5%90%88%E5%99%A8%E7%9A%84%E9%80%86%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"Inverse Design of Grating Coupler (2D) – Ansys Optics 在这个例子中，我们将会使用逆向设计工具箱（lumopt）来设计一个SOI光栅耦合器。相比于粒子群算法（particle swarm optimization，PSO），这种优化算法能够在几次迭代后就能获得最佳结果。最佳设计将被导出到GDS文件中，以进行进一步的模拟或制造。 OVERVIEW Lumerical的逆设计功能通过将基于梯度的优化例程的强大功能与麦克斯韦方程组基本属性中的效率相结合，提供了无与伦比的优化性能。此示例将演示如何使用逆向设计方法生成具有最大耦合效率的TE绝缘体硅（SOI）光栅耦合器设计。此外，我们将演示如何使用参数修改示例，以便您可以将此方法重用于自己的设计。 此示例广泛借鉴了 LumOpt 框架： Photonic Inverse Design Overview - Python API Getting Started with lumopt - python API Optimizable Geometry - Python APIhttps://support.lumerical.com/hc/en-us/articles/360052044913) 步骤一：在 MODE 中定义初始仿真 这一初始步骤的目标是为优化找到一个良好的起点。使用MODE FDE求解器，我们根据优化参数（中心波长，蚀刻深度，光纤角度）确定初始线性趾形光栅。 步骤二：使用2D FDTD 线性优化切趾光栅 第二步是使用一组有限的参数来优化光栅。我们使用步骤 1 中定义的切趾光栅作为起点。光栅的数量固定在25个，蚀刻深度固定在80nm。从步骤1获得的一组4个参数，作为光栅切趾的函数，用于提取初始参数集以最大化传输/耦合。 从上一步中找到的初始条件开始，我们现在使用光栅壁的x坐标作为自由参数（2x 25个参数）来运行优化。 包括制造约束 我们运行2D优化，设置最小特征尺寸约束（设置为100nm），以确保设备可制造。 步骤3：提取3D设计和GDS文件（还不太懂） 带有弯曲光栅的优化光栅耦合器组件形状将导出为GDS II格式，并导出为3D模拟文件，可用于进一步的模拟和/或制造（掩模设计）。我们使用覆盖源区域的圆形光栅来确保收集所有光纤光。我们还使用短线性锥度连接到450nm宽波导。光栅和锥度的几何形状可以由设计人员进一步优化。 Photonic Inverse Design: Grating Coupler (3D) 运行和结果(运行模型的说明和关键结果的讨论) 步骤1：定义基本仿真参数 如果要按案例运行，则不需要执行此步骤，但是，根据需要修改初始模拟文件需要执行此步骤。 12341.在模式下打开模拟文件 pid_grating_coupler_preliminary_design.lms2.修改所需的基本仿真参数，保存文件。3.打开脚本文件 pid_grating_coupler_preliminary_design.lsf4.修改参数并运行脚本 对于给定的中心波长\\(\\lambda_{c}\\)和给定的刻蚀深度\\(e\\)，我们可以按照参考文献[1]，根据物理参数设计一个切趾光栅。在这里，我们进行简单地推导，更多关于变量的详细信息和精确定义，见参阅参考。 主要思想是使用切趾光栅的局部有效折射率。对于每一个单元，使用插值法，有效折射率可用下式近似计算： \\[ n_{eff}=F\\cdot{n_0}+(1-F)n_E \\] F是填充分数(占空比),\\(n_0\\)是未刻蚀区域的有效折射率率，\\(n_E\\)是部分刻蚀区域的有效折射率 为了确定这些有效指数，我们使用 MODE FDE 求解器。对220nm高度的硅波导进行仿真，使用折射率为3.476683.47668的硅，以及折射率为1.444011.44401的背景材料（SiO2）。 我们可以写出布拉格条件的公式，用于计算光栅周期 \\[ Λ=\\frac{λ_c}{n_{eff}-n_{bg}sin\\theta} \\] \\(\\theta\\)是入射光的入射角度,\\(\\lambda{c}\\)是中心波长,\\(n_{bg}\\)是背景折射率 对于一个线性切趾光栅，填充因子随着波导的位置而改变 \\[ F(x)=F_0-R \\cdot x \\] R是切趾系数，\\({F_0}\\)是初始的填充因子。在理想情况下，\\(F_0\\)应该是1,因为我们以一个无刻蚀的波导开始,但是我们设置\\(F_0=0.95\\),目的是为了避免一些很小的间隔(trenches)。 在插值有效指数中使用线性切趾(Using the linear apodization in the interpolated effective index:)： \\[ n_{eff}(x)=F(x)n_0+(1-F(x))n_E=n_E+F(x)\\Delta n \\] 我们就能得到随着空间变化的光栅周期的函数： \\[ Λ(x)=\\frac{λ_c}{(n_{E}-n_{bg}sin\\theta)+F(x)\\Delta n} \\] 为了找到良好的初始条件,我们对每个周期离散化处理，可以得到每个周期的填充因子\\(F_i\\)以及周期\\(Λ_i\\) 至今，我们还剩唯一一个不知道的参数--\\(R\\)。为了一个更加高效的优化，我们可以引入四个待优化的参数： \\[ p=[x_0,R,a,b] \\] 相关计算公式如下: \\[ F_i=F_0-R(x_{i-1}-x_0) \\] \\[ Λ_i=\\frac{\\lambda_c}{a+F_ib} \\] \\[ a=n_E-n_{bg}sin\\theta \\] \\[ b=\\Delta n \\] b是有效折射率的差值。b = neff_thick - neff_thin 光栅耦合器结构 右图的下方的结构是传统的线性变迹光栅，周期是固定的。 右图的上方的结构是周期不固定的线性变迹 注意\\(x_0\\)和R将单独定义。我们将\\(x_0\\)设置为\\(-2.5μm\\)，将\\(R\\)设置为\\(0.03μm^{-1}\\)(见参考[1])。如果你更改材料，几何形状，或者偏振（polarization），你应该进行这些参数的扫描，来找到一个合适的初始条件。 脚本pid_grating_coupler_preliminary_grating_design.lsf 将会计算这些初始参数，并将结果保存在pid_grating_coupler_initial_params.json文件中，以便下一步使用。 步骤二：使用2D FDYD优化切趾光栅 我们首先需要找到光纤的最佳位置。 用FDTD的编译器打开python脚本pid_grating_coupler_sweep_2D.py 如果需要的话，可以修改参数。 运行脚本 这个脚本会加载步骤一中的初始设计，并且运行光纤最佳位置的扫描，来找到最佳的位置。 image-20220712155120278 找到的最佳位置为\\(4.2μm\\)，超过百分之60的传输率 The optimum position is found at 4.2μm, with a transmission over 60%. 用FDTD脚本编辑器,打开python 脚本 pid_grating_coupler_2D_apodized.py 如果需要的话,更新参数,并且运行脚本 打开脚本pid_grating_coupler_2D_1etch.py 运行脚本 在这一步,我们会使用从1到3的获得的参数,然后提取每个每个壁的x坐标作为自由参数。更加具体地说，参数将会是光栅的起始位置，蚀刻的宽度，以及每个光栅的齿的宽度。 脚本pid_grating_coupler_2D_apodized.py将这些参数保存到pid_optim_1.json文件中，这些参数可以用作起点。 我们在这一步中使用使用最小特征尺寸约束，将min_feature_size=0.1，这将确保，两个光栅的间隔将会大于\\(100nm\\)。 resuls_with_min_features_new optimization 最终的传输率约为60%，现在的光栅耦合器易于制造。优化的光栅参数保存在pid_optim_final.json。 步骤三: 提取 3D 设计和 GDS 打开脚本pid_grating_coupler_3D.py 如果需要，请修改设置 运行脚本 该脚本将加载优化结果，设置相应的3D模拟，并从结构中提取GDS。 一些重要的模型设置 优化的主要参数在脚本的初始设置，并且保存在初始模拟文件pid_grating_coupler_2D_TE_base.fsp。 12345678910111213# Optimization global parameterslambda_c = 1.55e-6 bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401 偏振：所选的折射率值代表SOI芯片制造工艺。由于硅和氧化硅之间的折射率对比度很高，因此集成波导的两种基本模式（TE和TM）的有效折射率之间存在很大差异。因此，SOI光栅耦合器具有很强的偏振选择性。目前的设计主要是TE mode，因为这是最常见的选择，不过也可以针对TM模式设置优化。要将极化更改为 TM 或者higher order mode，需要更改 pid_grating_coupler_preliminary_design.lsf 和 pid_grating_coupler python 文件的 ModeMatch 类中的模式编号。此外，还应更改base fsp 文件中的偏振角。对于 TM 优化，在这个配置中，模式编号为 2，偏振角为 0 度。 倾斜角度 ：耦合效率很大程度上取决于光纤如何与顶部氧化硅包层相遇。在本例中，我们使用高斯光束作为光纤光束输出的近似值。假设光纤的末端以很小的角度抛光，以便光纤在安装在顶部包层上时倾斜。这种倾斜可防止光反射到光纤中。 蚀刻深度：耦合效率对光栅的周期、占空比和蚀刻深度高度敏感。为简单起见，这里采用固定的蚀刻深度，但是，如果可用的制造工艺提供了这种自由度，它也可以改变。 衬底：如果制造的器件中存在硅衬底，则应将其包含在模拟中。衬底将对光的耦合方式产生明显影响，不能像其他器件设计中经常做的那样省略。 品质因数（FOM）：该设计的目的是在所需波长下实现最佳耦合，选择优化品质因数作为通过1550nm处的光栅耦合器传输，优化算法将尝试最大化该值。Lumopt使用mode power coupling，当扫描光纤位置时，我们使用功率传输率。 可优化几何形状的定义：固定y坐标的多边形，并且可修改的壁的x坐标以获得最佳几何形状。 场监控器：场监控器DFT monitor (opt_field) 被用于光栅中的收集光场的数据，用来计算光场的梯度，梯度被用于优化算法中。因此，场监控器的位置特别重要，因此场监控器应该覆盖全部的优化区域。 品质因数场监控器：因为这个场监视器被用于计算优化所需的品质因数，（模式与输出波导的基本TE模式重叠），因此应该位于适当尺寸的光栅耦合器的输出博导中。 光栅的高度和深度：几何对象的高度（深度）是根据制造过程选择的。这对于确保正确集合设置的3D仿真尤为重要。这是通过调整脚本中的height和etch_depth来完成的。将结构导出到GDS文件的脚本中需要用到这些值。 参数边界和初始值：优化算法改变参数的范围以及这些参数的初始值由initial_params定义，在调用函数时将bounds arrays定义为函数 FunctionDefinedPolygonI 的输入参数。 光谱范围:优化的光谱范围可以指定为数组“波长”以及优化中考虑的频率点数。请注意，选择大量频率点将使优化速度慢得多，并且在FDTD和Python环境之间传输大量数据时可能会导致问题。建议将此数字保持在尽可能低的水平，特别是对于 3D 模拟。对于单频率优化，只需选择相同的开始和停止值，并将点数设置为 1。 最大迭代次数 ：虽然算法能够在品质因数的梯度低于某个阈值时停止优化，但用于定义优化算法的“max_iter”变量可用于限制算法能够执行的迭代次数。 目标 FOM ：在定义 FOM 时，可以使用“target_T_fwd”输入参数指定不同波长下 FOM 的目标值。这应该是一个与波长数据长度相同的数组，并包含每个波长的目标FOM值（正向传输），该值可以小于1。对于所有波长，默认值为 1。这使用户能够选择在设计光谱范围给出目标的Transmission。 使用自己的参数更新模型 几何： 如果您需要为光栅耦合器定义自己的几何图形，包括SOI厚度（光栅高度）和蚀刻深度，则应在基本仿真文件和优化设置Python脚本中进行相应的更改。这可能需要更改基本脚本中的对象范围和位置，即python脚本中多边形的“etch_depth”参数，其值也会传递到脚本的GDS导出部分。源、仿真区域、网格覆盖以及场梯度和 FOM 监视器的尺寸也应相应地进行调整，以确保它们正确覆盖整个结构。 在此示例中，我们使用函数 FunctionDefinedPolygon 将光栅耦合器几何图形设置为多边形。或者，我们可以改用函数ParametrizedGeometry，从而在几何形状的设置方式上提供更大的灵活性。可以通过注释/取消注释来完成FunctionDefinedPolygon到ParametrizedGeometry的转换。 123456789101112131415161718192021def runGratingOptimization(bandwidth_in_nm, etch_depth, n_grates, params, working_dir):bounds = [(-4,3), #&lt; Starting position (in um) (0,0.05), #&lt; Scaling parameter R (1.5,3), #&lt; Parameter a (0,2)] #&lt; Parameter b # geometry = ParameterizedGeometry(func = etched_grating, # initial_params = params, # bounds = bounds, # dx = 1e-5) geometry = FunctionDefinedPolygon(func = grating_params_pos, initial_params = params, bounds = bounds, z = 0.0, depth = 110e-9, eps_out = indexSiO2 ** 2, eps_in = indexSi ** 2, edge_precision = 5, dx = 1e-5) 材料 ：在定义几何体时，通过调用函数DefinedPolygon（此处它们表示为折射率的平方）），模拟文件中中包含的材料（使几何体的材料（core）和围绕其周围的材料（cladding））的介电常数应传递给优化器。波导的折射率（非介电常数）（与可优化的几何体相同）也应在base仿真脚本中定义。 光栅几何形状 ：我们使用圆形光栅进行3D模拟和GDS导出。可以使用更复杂的光栅形状，类似于聚焦光栅耦合器。 进一步推动模型 针对想要进一步自定义模型的用户的信息和提示 锥度优化 ：3-D耦合器模型使用线性锥度部分连接到光栅开始时的集成波导。通过优化锥度形状，还可以提高耦合效率（参见 SOI 锥度设计）。 高效光栅耦合器 ：使用更复杂的光栅和混合的2-D/3-D优化策略，使用FDTD设计了在大带宽上效率高于90%的耦合器（参见参考文献） 更多资源 Additional documentation, examples, and training material Related publications R. Marchetti, C. Lacava, A. Khokhar, X. Chen, I. Cristiani, D. J. Richardson, G. T. Reed, P. Petropoulos and P. Minzioni, “High-efficiency grating-couplers: demonstration of a new design strategy,” Scientific Reports 7, Article number: 16670, 2017. (https://www.nature.com/articles/s41598-017-16505-z); Neil V. Sapra et.al, “Inverse design and demonstration of broadband grating couplers” IEEE Journal of Selected Topics in Quantum Electronics ( Volume: 25, Issue: 3, May-June 2019 ) D. Taillaert, F. Van Laere, M. Ayre, W. Bogaerts, D. Van Thourhout, P. Bienstman and R. Baets, “Grating Couplers for Coupling between Optical Fibers and Nanophotonic Waveguides,” Japanese Journal of Applied Physics, vol. 45, no. 8a, pp. 6071-6077, 2006. T. Watanabe, M. Ayata, U. Koch, Y. Fedoryshyn and J. Leuthold, “Perpendicular Grating Coupler Based on a Blazed Antiback-Reflection Structure,” Journal of Lightwave Technology, vol. 35, no. 21, pp. 4663- 4669, 2017. https://support.lumerical.com/hc/en-us/articles/360036618513)","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"Grating Coupler","slug":"Grating-Coupler","permalink":"http://example.com/tags/Grating-Coupler/"}]},{"title":"期末复习","slug":"数字电路汇总/数电期末","date":"2022-06-13T08:45:55.278Z","updated":"2022-07-21T12:08:32.776Z","comments":true,"path":"2022/06/13/数字电路汇总/数电期末/","link":"","permalink":"http://example.com/2022/06/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E7%94%B5%E6%9C%9F%E6%9C%AB/","excerpt":"","text":"填空题 选择题 判断题 概念 设计题分析 给定功能 第一章 偶数个异或输出为0 数字量 信号量 采样定理 二进编码; 数的基; 数; 源码反码补码; 有符号数的补码; 给一个有符号数;正数的补码和负数的补码是什么; 整数和小数(小数的规则);0.5转换为小数(二进); 逻辑门的输入和输出代表的不是绝对值;cmos和ttl的区间;表达一个波形设计参数,有周期,非周期,振幅,占空比,上升时间(定义:百分之10到百分之90);下降时间(定义);两个中位点作为宽度 方波不意味着周期 占空比的定义 时钟同步的定义:其他信号以时钟信号为基准 表达逻辑关系: 波形图 逻辑函数(逻辑方程) 逻辑图 真值表 基本逻辑操作:与或非; 通用门(与非和或非); 异或同或(性质) 固定功能芯片: 加法器;编码器;译码器;数据选择器;数据分配器;生成校验码(奇偶校验码) 数据选择器和译码器(?)实现sop 奇偶校验的定义;里面用到的运算;原理;可能比较方便地实现一些功能; 11章 可编程逻辑:如何分类(复杂的简单的);结构;与或者非 ad变换需要什么 coms:2-2.3V, 0-0.8V正逻辑负逻辑 一般ttl和coms不混起来,有一个特殊的coms可以混起来 全加器半加器的概念 分配器是重用译码器(掌握) 移位寄存器,用途一,用途二 环形能配合译码器 计数器的模 计数器有三个异步同步 芯片至少有两个引脚接地和电源; SSI,MSI,VLSI,ULSI TTL,CMOS,BIMOS(TTL+CMOS) 数基 任何一个十进小数,能否表达为一个精确的二进制小数,不可能 BCD常用8421码 二进数转换十进数(防止出错) 格雷码二进码转换 德摩根律 COMS逻辑类型那个表","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"resource","slug":"程设/资源","date":"2022-06-10T11:26:45.673Z","updated":"2022-06-10T11:28:37.091Z","comments":true,"path":"2022/06/10/程设/资源/","link":"","permalink":"http://example.com/2022/06/10/%E7%A8%8B%E8%AE%BE/%E8%B5%84%E6%BA%90/","excerpt":"","text":"Description 注意：以下世界观内容仿制《辐射4》背景故事，纯属虚构，切勿当真！ After the nuclear firestorm in year 2077, human civilization is on the verge of destruction, but new civilizations still exist on the old and glorious wreckage. Survivors started building underground Safehouse to avoid ground fallout and explore new living place. A Safehouse can not only provide rooms for surviving, but also store many necessary types of living Resource. 在2077年的末世浩劫“核火风暴”之后，人类文明毁灭了，但没有完全毁灭，新的文明依然存在于旧日辉煌的残骸之上。幸存者为了躲避地面的辐射，找到新的生存空间，开始修建起地下避难所（Safehouse）。地下避难所不仅仅能提供人们居住的环境，而且还能存储各种各样的资源（Resource）。 Guiding Assume that any kinds of Resource has its name and count in management. 假设在资源管理的概念中，每一种资源（Resource）都有对应的名称（name） 和数量（count）。 1234567struct Resource &#123; string name; int count; Resource(): name(&quot;&quot;), count(0) &#123;&#125; Resource(const string&amp; str, const int&amp; c): name(str), count(c) &#123;&#125;&#125;; And a Safehouse can be regarded as a place for storing these kinds of Resource. 而一个避难所（Safehouse）可以被视为存储这些资源的地方。 12345678class Safehouse &#123;private: Resource* _owns; // A place for storing many types of resources. int _count_own_types; // How many types of resources has this Savehouse stored.public: // Some functions.&#125;; There are up to 16 kinds of Resource in the world, and a Safehouse may contain several kinds of them, each of which is of corresponding amount (or count). To manage the Resource in Safehouse, the regulator decided to use overloaded operator to express Resource changes, for instance, so here is the task for you: implement the operator overloading of class Safehouse, since you are the cleverest among all residents. 这个世界上最多一共有16种资源，每个避难所可能存储其中的几种，每一种资源都有其对应的数量。为了方便管理避难所的资源存储，避难所监管者决定采用重载的运算符（overloaded operator）形式来表示避难所的资源存储变化概况。现在请你——避难所里最聪明的居民，来帮助他实现避难所的资源数量运算。 Details The Implementation of Resource struct is not needed, because it has been placed together with the announcement of class Safehouse in file \"Safehouse.h\". All you need to do is to realize some operator overloading functions of class Safehouse. 你不需要实现用于表示资源的结构体，因为它的定义和避难所类的声明都放在\"Safehouse.h\"头文件中。你只需要为避难所类实现如下这些运算符重载即可。 123456789101112131415161718192021222324252627282930// &quot;Copy&quot; all Resource from another Safehouse to current Safehouse.Safehouse&amp; operator = (const Safehouse&amp; another);// Add a kind of Resource to target Safehouse.// If the Resource type ALREADY exists in target Safehouse, just add on its existing count.// If the Resource type NOT exists in target Safehouse, add the new type totarget Safehouse with corresponding count.Safehouse operator + (const Resource&amp; new_resource); // Add all Resource existing in another Safehouse to target Safehouse.// You can call the overloaded version of &#x27;+ Resource&#x27; above for convenience.Safehouse operator + (const Safehouse&amp; another);// Similar to the overloading of &#x27;+ Resource&#x27;.Safehouse&amp; operator += (const Resource&amp; new_resource);// Similar to the overloading of &#x27;+ Safehouse&#x27;.Safehouse&amp; operator += (const Safehouse&amp; another);// Get the Resource object at designated index. You can assume that all input indexs are VALID!const Resource&amp; operator [] (const int&amp; index) const;// Compare current Safehouse with another Safehouse.// &quot;Safehouse1 &gt;= Safehouse2&quot; is satisfied, if and only if each of all Resource types existing in Safehouse2 also exists in Safehouse1.// Besides, as for a type of Resource, the corresponding amount in Safehouse1 must be NOT LESS THAN the corresponding amount in Safehouse2.// Otherwise, &quot;Safehouse1 &gt;= Safehouse2&quot; is NOT satisfied.bool operator &gt;= (const Safehouse&amp; another);// Print all existing Resource in target Safehouse.// The form of output is shown in Sample Output.friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Safehouse&amp; house); Hint Some useful functions of class Safehouse have been implemented. You can use them for simplifying your own codes, or just ignore them. 在Safehouse类中实现了一些可以直接调用的函数。你可以调用它们以简化自己代码，也可以选择无视它们。 Sample Input 12345678910111213141516Oil 2Coal 4Gunpowder 3Leather 6Plastic 5Rubber 10Lewel 7Steel 14Iron 11Copper 22Zinc 13Wood 26Glass 17Fibre 34Grass 19Eletronic 38 Sample Output (Notice how to put a Safehouse object in ostream) 123456789101112131415161718192021222324252627282930After adding 2 Oil to house1 &gt;&gt;&gt;Oil: 2After adding 4 Coal to house1 &gt;&gt;&gt;Oil: 2Coal: 4After adding 3 Gunpowder to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3After adding 6 Leather to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3Leather: 6After adding 5 Plastic to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3Leather: 6Plastic: 5After adding 10 Rubber to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3Leather: 6 main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &quot;Safehouse.h&quot;/*Available resource types:- Oil- Coal- Gunpowder- Leather- Plastic- Rubber- Lewel- Steel- Iron- Copper- Zinc - Wood- Glass- Fibre- Grass- Electronic*/istream&amp; operator &gt;&gt; (istream&amp; is, Resource&amp; r) &#123; is &gt;&gt; r.name &gt;&gt; r.count; return is;&#125;int main() &#123; Safehouse house1; for(int i=0; i&lt;MAX_RESOURCE_TYPES; ++i) &#123; Resource new_resource; cin &gt;&gt; new_resource; house1 += new_resource; cout &lt;&lt; &quot;After adding &quot; &lt;&lt; new_resource.count &lt;&lt; &quot; &quot; &lt;&lt; new_resource.name &lt;&lt; &quot; to house1 &gt;&gt;&gt;&quot; &lt;&lt; endl; cout &lt;&lt; house1 &lt;&lt; endl; &#125; Safehouse house2; for(int i=0; i&lt;house1.GetCountOwnTypes()/2; ++i) &#123; house2 = house2 + house1[i*2]; cout &lt;&lt; &quot;After adding &quot; &lt;&lt; house1.GetOwnsCount(i*2) &lt;&lt; &quot; &quot; &lt;&lt; house1.GetOwnsName(i*2) &lt;&lt; &quot; to house2 &gt;&gt;&gt;&quot; &lt;&lt; endl; cout &lt;&lt; house2 &lt;&lt; endl; &#125; cout &lt;&lt; &quot;house2 &gt;= house1? : &quot; &lt;&lt; boolalpha &lt;&lt; (house2 &gt;= house1) &lt;&lt; endl; Safehouse house3; house3 = house1 + house3; house3 += house2; cout &lt;&lt; &quot;After adding house1 and house2 to house3 &gt;&gt;&gt;&quot; &lt;&lt; endl; cout &lt;&lt; house3 &lt;&lt; endl; cout &lt;&lt; &quot;house3 &gt;= house1? : &quot; &lt;&lt; boolalpha &lt;&lt; (house3 &gt;= house1) &lt;&lt; endl; Safehouse house4 = house3; house4 = house4; cout &lt;&lt; &quot;After initializing house4 with house3 &gt;&gt;&gt; &quot; &lt;&lt; endl; cout &lt;&lt; house4 &lt;&lt; endl; return 0;&#125; safehouse.h(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#ifndef __SAFEHOUSE__#define __SAFEHOUSE__#define MAX_RESOURCE_TYPES 16#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Resource &#123; string name; int count; Resource(): name(&quot;&quot;), count(0) &#123;&#125; Resource(const string&amp; str, const int&amp; c): name(str), count(c) &#123;&#125;&#125;;class Safehouse &#123; private: Resource* _owns; int _count_own_types; public: Safehouse(): _owns(new Resource[MAX_RESOURCE_TYPES]), _count_own_types(0) &#123;&#125; ~Safehouse() &#123;if(_owns) delete[] _owns;&#125; // Below are some supporting functions. // Copy constuctor for class Safehouse. Safehouse(const Safehouse&amp; another): _owns(new Resource[MAX_RESOURCE_TYPES]), _count_own_types(another._count_own_types) &#123; for(int i=0; i&lt;_count_own_types; ++i) &#123; _owns[i].name = another._owns[i].name; _owns[i].count = another._owns[i].count; &#125; &#125; // Return how many different types of Resource does this Safehouse contain. int GetCountOwnTypes() const &#123; return _count_own_types; &#125; // Get the Resource name on designated index. string GetOwnsName(const int&amp; index) const &#123; if(index &gt;= _count_own_types || index &lt; 0) &#123; return &quot;None&quot;; &#125; else &#123; return _owns[index].name; &#125; &#125; // Get the Resource count on designated index. int GetOwnsCount(const int&amp; index) const &#123; if(index &gt;= _count_own_types || index &lt; 0) &#123; return 0; &#125; else &#123; return _owns[index].count; &#125; &#125; // Find the first index of designated Resource type, return -1 if the designated Resource does not exist in Safehouse yet. int IndexOfResource(const string&amp; resource_name) const &#123; for(int i=0; i&lt;_count_own_types; ++i) &#123; if(_owns[i].name == resource_name) &#123; return i; &#125; &#125; return -1; &#125; // Find the count of designated Resource type, return 0 if the designated Resource does not exist in Safehouse yet. int CountOfResource(const string&amp; resource_name) const &#123; for(int i=0; i&lt;_count_own_types; ++i) &#123; if(_owns[i].name == resource_name) &#123; return _owns[i].count; &#125; &#125; return 0; &#125; // Your Implementation. Safehouse&amp; operator = (const Safehouse&amp; another); Safehouse operator + (const Resource&amp; new_resource); Safehouse operator + (const Safehouse&amp; another); Safehouse&amp; operator += (const Resource&amp; new_resource); Safehouse&amp; operator += (const Safehouse&amp; another); const Resource&amp; operator [] (const int&amp; index) const; bool operator &gt;= (const Safehouse&amp; target); friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Safehouse&amp; house); &#125;;#endif safehouse.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;Safehouse.h&gt;Safehouse&amp; Safehouse::operator = (const Safehouse&amp; another)&#123; if(&amp;another == this) return *this; _count_own_types=another._count_own_types; for(int i=0;i&lt;_count_own_types;i++)&#123; _owns[i]=another._owns[i]; &#125; return *this;&#125;// Add a kind of Resource to target Safehouse.// If the Resource type ALREADY exists in target Safehouse, just add on its existing count.// If the Resource type NOT exists in target Safehouse, add the new type totarget Safehouse with corresponding count.Safehouse Safehouse::operator + (const Resource&amp; n)&#123; Safehouse temp = (*this); if( temp.IndexOfResource(n.name) != -1)&#123; temp._owns[ IndexOfResource(n.name) ].count+=n.count; //数量问题 &#125;else&#123; if(_count_own_types==16) return temp; temp._owns[_count_own_types]=n; temp._count_own_types++; &#125; return temp;&#125;// Add all Resource existing in another Safehouse to target Safehouse.// You can call the overloaded version of &#x27;+ Resource&#x27; above for convenience.Safehouse Safehouse::operator + (const Safehouse&amp; a)&#123; Safehouse temp=(*this); for(int i=0; i&lt;a._count_own_types;i++)&#123; temp = temp + a._owns[i]; &#125; return temp;&#125;// Similar to the overloading of &#x27;+ Resource&#x27;.Safehouse&amp; Safehouse::operator += (const Resource&amp; n)&#123; if( IndexOfResource(n.name) != -1)&#123; _owns[ IndexOfResource(n.name) ].count+=n.count; //数量问题 &#125;else&#123; _owns[_count_own_types]=n; _count_own_types++; &#125; return *this;&#125;// Similar to the overloading of &#x27;+ Safehouse&#x27;.Safehouse&amp; Safehouse::operator += (const Safehouse&amp; a)&#123; (*this) = (*this) + a; return *this;&#125;// Get the Resource object at designated index. You can assume that all input indexs are VALID!const Resource&amp; Safehouse::operator [] (const int&amp; index) const&#123; return _owns[index];&#125;// Compare current Safehouse with another Safehouse.// &quot;Safehouse1 &gt;= Safehouse2&quot; is satisfied, if and only if each of all Resource types existing in Safehouse2 also exists in Safehouse1.// Besides, as for a type of Resource, the corresponding amount in Safehouse1 must be NOT LESS THAN the corresponding amount in Safehouse2.// Otherwise, &quot;Safehouse1 &gt;= Safehouse2&quot; is NOT satisfied.bool Safehouse::operator &gt;= (const Safehouse&amp; a)&#123; int i=0; for(;i&lt;a._count_own_types;i++)&#123; if( IndexOfResource( a._owns[i].name ) == -1 ) return false; if( CountOfResource( a._owns[i].name ) &lt; a.CountOfResource( a._owns[i].name ) ) return false; &#125; return true;&#125;// Print all existing Resource in target Safehouse.// The form of output is shown in Sample Output.ostream&amp; operator &lt;&lt; (ostream&amp; os, const Safehouse&amp; house)&#123; for(int i=0;i&lt;house._count_own_types;i++)&#123; os&lt;&lt;house._owns[i].name&lt;&lt;&quot;: &quot;&lt;&lt;house._owns[i].count&lt;&lt;endl; &#125; return os;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"数字电路-Shift Registers","slug":"数字电路汇总/数电第九章","date":"2022-05-31T13:56:12.239Z","updated":"2022-05-31T15:04:51.298Z","comments":true,"path":"2022/05/31/数字电路汇总/数电第九章/","link":"","permalink":"http://example.com/2022/05/31/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"basic function and operations Shift Register Generator(SRG) 串进串出(serial in serial out) 串进并出(serial in parallel out) 并进串出(parallel in parallel out) 并进并出(parallel in parallel out) 双向移位寄存器 移位寄存计数器(shift register counter) 纽环计数器(重点) 初始状态一定要为0000 环形计数器(重点) 10位环形计数器的电路逻辑图，模式=位数 •模数是相同位数的扭环计数器的一半 •如果\\(Q_0-Q_9\\)只有一个为1，其余为0，状态由1所在的位置 决定，无需译码 •初始状态可以根据要求来设置 移位寄存器应用 移位寄存器应用示例：延时电路 原理：脉冲输入寄存器，每拍移动一位，经过n拍后输出，n位 寄存器延迟n拍 延时电路示例：8位共延迟8拍，每拍1/500k=2us，延 时2*8=16us 移位寄存器应用示例：以74HC195构成环形计数器 方法：\\(Q_3\\)作为输入，\\(Q_0~Q_3\\)初始状态为：1000 移位寄存器应用示例：数据的串行-并行转换电路 数据的串行输入格式：0开始，8位数据，1结束 通用异步收发器（UART）：数据的串-并、并-串转换 逻辑符号 8位移位寄存器74HC164的关联标注逻辑符号 •共用控制块：上方带凹槽的方框 •独立元件：下方的8个方框 •限制符号：SRG 8，表达8位移位寄存器 •关联符号：C：控制，R：清零（Reset），箭号：移位 4位双向移位寄存器74HC194的关联标注逻辑符号 •共用控制块：上方带凹槽的方框 •独立元件：下方的4个方框 •限制符号：SRG 4，表达4位移位寄存器 •关联符号：C：控制，M：模式，R：清零（Reset），箭号：移位 需掌握的重点","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"选数(dfs)","slug":"程设/选数(dfs)","date":"2022-05-31T12:15:03.170Z","updated":"2022-05-31T12:16:59.372Z","comments":true,"path":"2022/05/31/程设/选数(dfs)/","link":"","permalink":"http://example.com/2022/05/31/%E7%A8%8B%E8%AE%BE/%E9%80%89%E6%95%B0(dfs)/","excerpt":"","text":"[NOIP2002 普及组] 选数 题目描述 已知 \\(n\\) 个整数 \\(x_1,x_2,\\cdots,x_n\\)，以及 \\(1\\) 个整数 \\(k\\)（\\(k&lt;n\\)）。从 \\(n\\) 个整数中任选 \\(k\\) 个整数相加，可分别得到一系列的和。例如当 \\(n=4\\)，\\(k=3\\)，\\(4\\) 个整数分别为 \\(3,7,12,19\\) 时，可得全部的组合与它们的和为： \\(3+7+12=22\\) \\(3+7+19=29\\) \\(7+12+19=38\\) \\(3+12+19=34\\) 现在，要求你计算出和为素数共有多少种。 例如上例，只有一种的和为素数：\\(3+7+19=29\\)。 输入格式 第一行两个空格隔开的整数 \\(n,k\\)（\\(1 \\le n \\le 20\\)，\\(k&lt;n\\)）。 第二行 \\(n\\) 个整数，分别为 \\(x_1,x_2,\\cdots,x_n\\)（\\(1 \\le x_i \\le 5\\times 10^6\\)）。 输出格式 输出一个整数，表示种类数。 样例 #1 样例输入 #1 124 33 7 12 19 样例输出 #1 11 提示 【题目来源】 NOIP 2002 普及组第二题 提交代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; int n, k, x[21]=&#123;0&#125;;int sum=0, ans=0;bool judge(int t)&#123; if(t==2) return true; for(int i=2;i&lt;t/2;i++)&#123; if(t%i==0) return false; &#125; return true; &#125; void dfs(int count, int pos)&#123; if(count &gt; k)&#123; if(judge(sum))&#123; ans++; &#125; return; &#125; else&#123; for(int i=pos+1;i&lt;=n;i++)&#123; sum += x[i]; dfs(count+1, i); sum -= x[i]; &#125; &#125; &#125; int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i=1;i&lt;=n;i++) cin &gt;&gt; x[i]; dfs(1,0); cout &lt;&lt; ans; return 0; &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"桶排序","slug":"程设/桶排序","date":"2022-05-31T11:56:00.612Z","updated":"2022-05-31T11:59:17.077Z","comments":true,"path":"2022/05/31/程设/桶排序/","link":"","permalink":"http://example.com/2022/05/31/%E7%A8%8B%E8%AE%BE/%E6%A1%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"【深基9.例1】选举学生会 题目描述 学校正在选举学生会成员，有 \\(n(n\\le 999)\\) 名候选人，每名候选人编号分别从 1 到 \\(n\\)，现在收集到了 \\(m(m&lt;=2000000)\\) 张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。 输入格式 输入 \\(n\\) 和 \\(m\\) 以及 \\(m\\) 个选票上的数字。 输出格式 求出排序后的选票编号。 样例 #1 样例输入 #1 125 102 5 2 2 5 2 2 2 1 2 样例输出 #1 11 2 2 2 2 2 2 2 5 5 函数映射关系 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int a,n,m,b[1000];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)cin&gt;&gt;a,++b[a]; //记录票出现的次数 for(int i=0;i&lt;1000;i++)while(b[i]--)cout&lt;&lt;i&lt;&lt;&quot; &quot;; //根据票出现的次数输出 return 0;&#125; 参考【算法】排序算法之桶排序 - 知乎 (zhihu.com) 假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序。然后把各个桶中的数据合并。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iterator&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int BUCKET_NUM = 10;struct ListNode&#123; explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125; ListNode* mNext; int mData;&#125;;ListNode* insert(ListNode* head,int val)&#123; ListNode dummyNode; ListNode *newNode = new ListNode(val); ListNode *pre,*curr; dummyNode.mNext = head; pre = &amp;dummyNode; curr = head; while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123; pre = curr; curr = curr-&gt;mNext; &#125; newNode-&gt;mNext = curr; pre-&gt;mNext = newNode; return dummyNode.mNext;&#125;ListNode* Merge(ListNode *head1,ListNode *head2)&#123; ListNode dummyNode; ListNode *dummy = &amp;dummyNode; while(NULL!=head1 &amp;&amp; NULL!=head2)&#123; if(head1-&gt;mData &lt;= head2-&gt;mData)&#123; dummy-&gt;mNext = head1; head1 = head1-&gt;mNext; &#125;else&#123; dummy-&gt;mNext = head2; head2 = head2-&gt;mNext; &#125; dummy = dummy-&gt;mNext; &#125; if(NULL!=head1) dummy-&gt;mNext = head1; if(NULL!=head2) dummy-&gt;mNext = head2; return dummyNode.mNext;&#125;void BucketSort(int n,int arr[])&#123; vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0)); for(int i=0;i&lt;n;++i)&#123; int index = arr[i]/BUCKET_NUM; ListNode *head = buckets.at(index); buckets.at(index) = insert(head,arr[i]); &#125; ListNode *head = buckets.at(0); for(int i=1;i&lt;BUCKET_NUM;++i)&#123; head = Merge(head,buckets.at(i)); &#125; for(int i=0;i&lt;n;++i)&#123; arr[i] = head-&gt;mData; head = head-&gt;mNext; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"dfs","slug":"程设/dfs","date":"2022-05-31T07:21:41.520Z","updated":"2022-05-31T07:22:30.257Z","comments":true,"path":"2022/05/31/程设/dfs/","link":"","permalink":"http://example.com/2022/05/31/%E7%A8%8B%E8%AE%BE/dfs/","excerpt":"","text":"[NOIP2002 普及组] 选数 题目描述 已知 \\(n\\) 个整数 \\(x_1,x_2,\\cdots,x_n\\)，以及 \\(1\\) 个整数 \\(k\\)（\\(k&lt;n\\)）。从 \\(n\\) 个整数中任选 \\(k\\) 个整数相加，可分别得到一系列的和。例如当 \\(n=4\\)，\\(k=3\\)，\\(4\\) 个整数分别为 \\(3,7,12,19\\) 时，可得全部的组合与它们的和为： \\(3+7+12=22\\) \\(3+7+19=29\\) \\(7+12+19=38\\) \\(3+12+19=34\\) 现在，要求你计算出和为素数共有多少种。 例如上例，只有一种的和为素数：\\(3+7+19=29\\)。 输入格式 第一行两个空格隔开的整数 \\(n,k\\)（\\(1 \\le n \\le 20\\)，\\(k&lt;n\\)）。 第二行 \\(n\\) 个整数，分别为 \\(x_1,x_2,\\cdots,x_n\\)（\\(1 \\le x_i \\le 5\\times 10^6\\)）。 输出格式 输出一个整数，表示种类数。 样例 #1 样例输入 #1 124 33 7 12 19 样例输出 #1 11 提示 【题目来源】 NOIP 2002 普及组第二题 1234567891011121314151617181920212223242526272829303132333435361 #include &lt;iostream&gt; 2 using namespace std; 3 4 int n, k, x[21]=&#123;0&#125;; 5 int sum=0, ans=0; 6 7 bool judge(int t)&#123; #判断是否是素数 8 if(t==2) return true; 9 for(int i=2;i&lt;t/2;i++)&#123;10 if(t%i==0) return false;11 &#125;12 return true;13 &#125;14 15 void dfs(int count, int pos)&#123; #count是当前有几个数被计算了，pos是他们的位置16 if(count &gt; k)&#123;17 if(judge(sum))&#123;18 ans++;19 &#125;20 return; #回溯21 &#125;22 else&#123;23 for(int i=pos+1;i&lt;=n;i++)&#123;24 sum += x[i];25 dfs(count+1, i);26 sum -= x[i];27 &#125;28 &#125;29 &#125;30 31 int main()&#123;32 cin &gt;&gt; n &gt;&gt; k;33 for(int i=1;i&lt;=n;i++) cin &gt;&gt; x[i];34 dfs(1,0);35 cout &lt;&lt; ans;36 return 0;37 &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"模拟","slug":"程设/火星人","date":"2022-05-29T13:28:42.432Z","updated":"2022-05-29T13:35:28.543Z","comments":true,"path":"2022/05/29/程设/火星人/","link":"","permalink":"http://example.com/2022/05/29/%E7%A8%8B%E8%AE%BE/%E7%81%AB%E6%98%9F%E4%BA%BA/","excerpt":"","text":"火星人 题目描述 人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。 火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 \\(1,2,3,\\cdots\\)。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。 一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 \\(1,2,3,4\\) 和 \\(5\\)，当它们按正常顺序排列时，形成了 \\(5\\) 位数 \\(12345\\)，当你交换无名指和小指的位置时，会形成 \\(5\\) 位数 \\(12354\\)，当你把五个手指的顺序完全颠倒时，会形成 \\(54321\\)，在所有能够形成的 \\(120\\) 个 \\(5\\) 位数中，\\(12345\\) 最小，它表示 \\(1\\)；\\(12354\\) 第二小，它表示 \\(2\\)；\\(54321\\) 最大，它表示 \\(120\\)。下表展示了只有 \\(3\\) 根手指时能够形成的 \\(6\\) 个 \\(3\\) 位数和它们代表的数字： 三进制数 代表的数字 \\(123\\) \\(1\\) \\(132\\) \\(2\\) \\(213\\) \\(3\\) \\(231\\) \\(4\\) \\(312\\) \\(5\\) \\(321\\) \\(6\\) 现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。 输入格式 共三行。 第一行一个正整数 \\(N\\)，表示火星人手指的数目（\\(1 \\le N \\le 10000\\)）。 第二行是一个正整数 \\(M\\)，表示要加上去的小整数（\\(1 \\le M \\le 100\\)）。 下一行是 \\(1\\) 到 \\(N\\) 这 \\(N\\) 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。 输出格式 \\(N\\) 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。 样例 #1 样例输入 #1 123531 2 3 4 5 样例输出 #1 11 2 4 5 3 提示 对于 \\(30\\%\\) 的数据，\\(N \\le 15\\)。 对于 \\(60\\%\\) 的数据，\\(N \\le 50\\)。 对于 \\(100\\%\\) 的数据，\\(N \\le 10000\\)。 题解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int b[10000+1]; int i,j,k,m,n,t;void init()&#123; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) cin&gt;&gt;b[i];&#125;void out()&#123; for(i=1;i&lt;=n-1;i++) cout&lt;&lt;b[i]&lt;&lt;&#x27; &#x27;; cout&lt;&lt;b[n]&lt;&lt;endl;&#125;void work()&#123; for(i=1;i&lt;=m;i++)//增1 共M次 &#123; for(j=n-1;j&gt;=1;j--)//找到最后可增加的位，即定位 if(b[j]&lt;b[j+1])//例如12354加1，则只有3可增加位数 break; for(k=n;k&gt;=1;k--)//找到最小可增加的数字 if(b[k]&gt;b[j])//例如12354加1，最小可增加的数字是4 break; t=b[j];//交换，把原排列增大 ， b[j]=b[k];//例如12354加1，即3和4交换，交换结果为12453 b[k]=t; //但12453并不是最终结果，而是12435即要排序 j=j+1;//向后移一位 k=n; while((j&lt;k))//把后面的逆序，相当于从小到大排序 &#123; t=b[j]; b[j]=b[k]; b[k]=t; j++; k--; &#125; &#125;&#125;int main()&#123; init(); work(); out(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template and stack","slug":"程设/template and stack","date":"2022-05-26T14:26:09.818Z","updated":"2022-06-01T07:15:30.791Z","comments":true,"path":"2022/05/26/程设/template and stack/","link":"","permalink":"http://example.com/2022/05/26/%E7%A8%8B%E8%AE%BE/template%20and%20stack/","excerpt":"","text":"队列模拟栈 Description In this assignment, you need to complete Class Stack's declaration and definition with templates. The different thing is that the Stack is implemented by two queues. Following is the example of Stack in integer: 1234567891011121314class Stack &#123; public: Stack(); // constructor. void push(const int&amp; data); // push operation. int pop(); // return the value in the top and pop it out of the stack. int top(); // return the value in top. int size() const; // return size of the stack. bool empty(); // check whether is empty. private: queue&lt;int&gt; q1; // two queues. queue&lt;int&gt; q2; int count; // the number of elements.&#125;; And you need to define a print function to print the content in the Stack from top to bottom. The format is: every element is followed by a blank space and an endl in the end. Hint You are not allowed to use any STL except queue. For more detail, see the codes in main.cpp. 出题人：黎洋 main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;Stack.h&quot;#include&lt;iostream&gt;#include&lt;exception&gt;using namespace std;class StackForbidden : public exception &#123; virtual const char *what() const throw() &#123; return &quot;Please do not use Stack in stl..&quot;; &#125;&#125;;void test1()&#123; Stack&lt;int&gt; stack; stack.push(88); stack.push(44); stack.push(99); cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack.size() &lt;&lt; endl; if (!stack.empty()) cout &lt;&lt; stack.top() &lt;&lt; endl; print(stack); stack.pop(); print(stack); stack.push(777); cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack.size() &lt;&lt; endl; if (!stack.empty()) cout &lt;&lt; stack.top() &lt;&lt; endl; print(stack); stack.pop(); stack.pop(); cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack.size() &lt;&lt; endl; print(stack); stack.pop(); if (!stack.empty()) cout &lt;&lt; stack.top() &lt;&lt; endl; else cout &lt;&lt; &quot;it is empty now.&quot; &lt;&lt; endl;&#125;void test2()&#123; Stack&lt;double&gt; stack1; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; stack1.push(i + 0.01); &#125; print(stack1); while (m--) &#123; stack1.pop(); &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack1.size() &lt;&lt; endl; if (!stack1.empty()) cout &lt;&lt; stack1.top() &lt;&lt; endl; print(stack1);&#125;int main() &#123; #if defined(_GLIBCXX_STACK) throw StackForbidden(); #endif test1(); test2();&#125; stack.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;class Stack &#123; public: Stack()&#123; count = 0; &#125; // constructor. void push(const T&amp; data)&#123; q1.push(data); ++count; &#125; // push operation. T pop()&#123; while(!q2.empty()) q2.pop(); if(count)&#123; --count; for(int i = 0; i &lt; count; ++i)&#123; q2.push(q1.front()); q1.pop(); &#125; swap(q1, q2); &#125; return q1.front(); &#125; // return the value in the top and pop it out of the stack. T top()&#123; return q1.back(); &#125; // return the value in top. int size() const&#123; return count; &#125; // return size of the stack. bool empty()&#123; return count == 0; &#125;// check whether is empty. //friend void print(Stack&lt;TT&gt;&amp; s); private: queue&lt;T&gt; q1; // two queues. queue&lt;T&gt; q2; int count; // the number of elements.&#125;;template&lt;class TT&gt;void print(Stack&lt;TT&gt; queue) &#123; while (!queue.empty()) &#123; cout &lt;&lt; queue.top() &lt;&lt; &quot; &quot;; queue.pop(); &#125; cout &lt;&lt; endl;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;template&lt;typename T&gt;class Stack &#123; public: Stack(); void push(const T&amp; data); T pop(); T top(); int size() const; bool empty(); private: queue&lt;T&gt; q1; queue&lt;T&gt; q2; int count;&#125;;template&lt;typename T&gt;Stack&lt;T&gt;::Stack() &#123; count = 0;&#125;template&lt;typename T&gt;int Stack&lt;T&gt;::size() const &#123; return count;&#125;template&lt;typename T&gt;bool Stack&lt;T&gt;::empty() &#123; return count == 0;&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::push(const T&amp; data) &#123; if (q1.empty() &amp;&amp; q2.empty()) &#123; q1.push(data); &#125; else &#123; if (!q1.empty()) q1.push(data); else q2.push(data); &#125; count++;&#125;template&lt;typename T&gt;T Stack&lt;T&gt;::top() &#123; if (!q1.empty()) return q1.back(); return q2.back();&#125;template&lt;typename T&gt;T Stack&lt;T&gt;::pop() &#123; T value; if (!empty()) &#123; if (q1.empty()) &#123; while (q2.size() &gt;= 2) &#123; q1.push(q2.front()); q2.pop(); &#125; value = q2.front(); q2.pop(); &#125; else &#123; while (q1.size() &gt;= 2) &#123; q2.push(q1.front()); q1.pop(); &#125; value = q1.front(); q1.pop(); &#125; count--; &#125; return value;&#125;template&lt;typename T&gt;void print(Stack&lt;T&gt; stack) &#123; while (!stack.empty()) &#123; cout &lt;&lt; stack.top() &lt;&lt; &quot; &quot;; stack.pop(); &#125; cout &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Stack &#123; public: Stack()&#123; count = 0; &#125; // constructor. void push(const T&amp; data)&#123; q2.push(data); while(!q1.empty())&#123; q2.push(q1.front()); q1.pop(); &#125; swap(q1,q2); &#125; // push operation. T pop()&#123; T r = q1.front(); q1.pop(); return r; &#125; // return the value in the top and pop it out of the stack. T top()&#123; return q1.front(); &#125; // return the value in top. int size() const&#123; return count; &#125; // return size of the stack. bool empty()&#123; return q1.empty(); &#125; // check whether is empty. private: queue&lt;T&gt; q1; // two queues. queue&lt;T&gt; q2; int count; // the number of elements.&#125;;template &lt;typename T&gt;void print(Stack &lt;T&gt; stack)&#123; while (!stack.empty()) &#123; cout &lt;&lt; stack.top() &lt;&lt; &quot; &quot;; stack.pop(); &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template(queue)","slug":"程设/queue with template","date":"2022-05-24T03:03:28.851Z","updated":"2022-05-24T06:20:41.314Z","comments":true,"path":"2022/05/24/程设/queue with template/","link":"","permalink":"http://example.com/2022/05/24/%E7%A8%8B%E8%AE%BE/queue%20with%20template/","excerpt":"","text":"Description Please modify class Queue's declaration and definition so as to finish the test from main.cpp. Attention: please use template you have learned in the class to finish this assignment and DO NOT add or modify any memeber functions or member variables. Warning: DO NOT USE queue in STL. The Queue's declaration with element type int is below: 123456789101112131415161718192021222324252627class Queue &#123; public: Queue(); Queue(const Queue &amp; another); ~Queue(); bool empty(); int size(); int front() const; int back() const; void push(int element); void pop(); void swap(Queue &amp; queue); private: struct Node &#123; int element; Node* next; Node(int ele, Node* n = NULL) &#123; element = ele; next = n; &#125; &#125;; Node* front_node; Node* back_node; int node_num;&#125;; Hint 如果你对类中的成员函数有疑问，函数的具体作用，请参见：www.cplusplus.com里的queue内容 Author: 黎洋 main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &quot;Queue.h&quot;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;class Job &#123; public: explicit Job(int pri = 0) &#123; id = number++; priority = pri; &#125; string toString() &#123; stringstream ss; ss &lt;&lt; &quot;[&quot; &lt;&lt; id &lt;&lt; &quot;:&quot; &lt;&lt; priority &lt;&lt; &quot;]&quot;; return ss.str(); &#125; private: static int number; int id; int priority;&#125;;int Job::number = 0;template&lt;class T&gt;void print(Queue&lt;T&gt; queue) &#123; while (!queue.empty()) &#123; cout &lt;&lt; queue.front() &lt;&lt; &quot; &quot;; queue.pop(); &#125; cout &lt;&lt; endl;&#125;int main() &#123; // test case 1: integer.. Queue&lt;int&gt; que; int m, n; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) que.push(i + 0.01); for (int i = 0; i &lt; n; i++) que.pop(); if (!que.empty()) &#123; cout &lt;&lt; que.front() &lt;&lt; endl; cout &lt;&lt; que.back() &lt;&lt; endl; &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; que.size() &lt;&lt; endl; if (que.empty()) cout &lt;&lt; &quot;The queue is empty!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;The queue is NOT empty!&quot; &lt;&lt; endl; // test case 2: double.. Queue&lt;double&gt; que1; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) que1.push(i + 0.01); for (int i = 0; i &lt; n; i++) que1.pop(); if (!que1.empty()) &#123; cout &lt;&lt; que1.front() &lt;&lt; endl; cout &lt;&lt; que1.back() &lt;&lt; endl; &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; que1.size() &lt;&lt; endl; if (que1.empty()) cout &lt;&lt; &quot;The queue is empty!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;The queue is NOT empty!&quot; &lt;&lt; endl; // test case 3: user defined class.. Queue&lt;Job&gt; que2; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) que2.push(Job(i)); for (int i = 0; i &lt; n; i++) que2.pop(); if (!que2.empty()) &#123; cout &lt;&lt; que2.front().toString() &lt;&lt; endl; cout &lt;&lt; que2.back().toString() &lt;&lt; endl; &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; que2.size() &lt;&lt; endl; if (que2.empty()) cout &lt;&lt; &quot;The queue is empty!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;The queue is NOT empty!&quot; &lt;&lt; endl; // test case 4: swap function.. Queue&lt;int&gt; que3, que4; for (int i = 0; i &lt; m; i++) que3.push(i); for (int i = 0; i &lt; n; i++) que4.push(m - i); cout &lt;&lt; &quot;Before Swap....&quot; &lt;&lt; endl; print(que3); print(que4); que3.swap(que4); cout &lt;&lt; &quot;After Swap....&quot; &lt;&lt; endl; cout &lt;&lt; endl; print(que3); print(que4);&#125; Queue.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt;class Queue&#123; public: Queue()&#123; front_node = NULL; back_node = NULL; node_num = 0; &#125; Queue(const Queue &amp; another):node_num(0)&#123; for(Node* i = another.front_node; i != another.back_node; i = i-&gt;next)&#123; push(i-&gt;element); &#125; push(another.back_node-&gt;element); &#125; ~Queue()&#123; while(front_node)&#123; Node* temp = front_node; front_node = front_node-&gt;next; delete temp; &#125; &#125; bool empty()&#123; return node_num == 0; &#125; int size()&#123; return node_num; &#125; T front() const&#123; return front_node-&gt;element; &#125; T back() const&#123; return back_node-&gt;element; &#125; void push(T element)&#123; if(empty())&#123; Node* temp = new Node(element); back_node = temp; front_node = temp; node_num = 1; &#125; else&#123; Node* temp = new Node(element); back_node-&gt;next = temp; back_node = temp; ++node_num; &#125; &#125; void pop()&#123; if(!empty())&#123; --node_num; Node* temp = front_node; front_node = front_node-&gt;next; delete temp; &#125; &#125; void swap(Queue &amp; queue)&#123; Node* temp = front_node; front_node = queue.front_node; queue.front_node = temp; temp = back_node; back_node = queue.back_node; queue.back_node = temp; int temp1 = node_num; node_num = queue.node_num; queue.node_num = temp1; &#125; private: struct Node &#123; T element; Node* next; Node(T ele, Node* n = NULL) &#123; element = ele; next = n; &#125; &#125;; Node* front_node; Node* back_node; int node_num;&#125;; Queue.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;using namespace std; template &lt;typename ElementType&gt;class Queue &#123; public: Queue(); Queue(const Queue&lt;ElementType&gt;&amp; another); ~Queue(); bool empty(); int size(); ElementType front() const; ElementType back() const; void push(ElementType element); void pop(); void swap(Queue&lt;ElementType&gt;&amp; queue); private: struct Node &#123; ElementType element; Node* next; Node(ElementType ele, Node* n = NULL) &#123; element = ele; next = n; &#125; &#125;; Node* front_node; Node* back_node; int node_num;&#125;; template &lt;typename ElementType&gt;Queue&lt;ElementType&gt;::Queue(const Queue&lt;ElementType&gt;&amp; another) &#123; if (this == &amp;another) return; front_node = back_node = NULL; node_num = 0; Node* temp = another.front_node; while (temp != NULL) &#123; push(temp-&gt;element); temp = temp-&gt;next; &#125;&#125; template &lt;typename ElementType&gt;Queue&lt;ElementType&gt;::Queue() &#123; front_node = back_node = NULL; node_num = 0;&#125; template &lt;typename ElementType&gt;Queue&lt;ElementType&gt;::~Queue() &#123; while (!empty()) &#123; pop(); &#125;&#125; template &lt;typename ElementType&gt;bool Queue&lt;ElementType&gt;::empty() &#123; return node_num == 0;&#125; template &lt;typename ElementType&gt;int Queue&lt;ElementType&gt;::size() &#123; return node_num;&#125; template &lt;typename ElementType&gt;ElementType Queue&lt;ElementType&gt;::front() const &#123; return front_node-&gt;element;&#125; template &lt;typename ElementType&gt;ElementType Queue&lt;ElementType&gt;::back() const &#123; return back_node-&gt;element;&#125; template &lt;typename ElementType&gt;void Queue&lt;ElementType&gt;::push(ElementType element) &#123; if (front_node == NULL) &#123; front_node = back_node = new Node(element); &#125; else &#123; back_node-&gt;next = new Node(element); back_node = back_node-&gt;next; &#125; node_num++;&#125; template &lt;typename ElementType&gt;void Queue&lt;ElementType&gt;::pop() &#123; if (empty()) return; if (size() == 1) &#123; delete front_node; front_node = back_node = NULL; &#125; else &#123; Node* temp = front_node; front_node = front_node-&gt;next; delete temp; &#125; node_num--;&#125; template &lt;typename ElementType&gt;void Queue&lt;ElementType&gt;::swap(Queue&lt;ElementType&gt;&amp; queue) &#123; int old_size = size(); while (!empty()) &#123; queue.push(front()); pop(); &#125; while (queue.size() &gt; old_size) &#123; push(queue.front()); queue.pop(); &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"stack(指针gou'jian)","slug":"程设/stack","date":"2022-05-23T13:46:36.689Z","updated":"2022-05-24T02:10:58.428Z","comments":true,"path":"2022/05/23/程设/stack/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/stack/","excerpt":"","text":"Description 构建使用指针构建动态堆栈。 已知每一个数据节点的结构体： 12345typedef int ELEMENT; // 为堆栈元素类型起一个别名struct NODE &#123; ELEMENT element; // 存放堆栈的元素 NODE* link; // 指向下一个结点的链接&#125;; 类声明： 1234567891011121314class STACK &#123;public: STACK(); // 构造函数，设置栈顶为空指针 ~STACK(); // 析构函数，释放堆栈结点占用的存储空间 void push(ELEMENT obj); // 将元素obj压入栈顶 void pop(); // 将当前栈顶的元素弹出栈中。要求：栈不为空。 ELEMENT get_top() const; // 返回当前栈顶的元素值。要求：栈不为空。 bool is_empty() const; // 判断当前堆栈是否为空，空则返回true，非空则返回false void display() const; // 自顶向下显示堆栈中的元素private: NODE* top; // 堆栈的栈顶&#125;; Sample Output 12345678910111213141516171819202120 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 1 202 193 184 175 166 157 148 139 1210 1111 1012 913 814 715 616 517 418 319 220 1 STACK.H(lock) 1234567891011121314151617181920212223#ifndef STACK_H#define STACK_Htypedef int ELEMENT; // 为堆栈元素类型起一个别名struct NODE &#123; ELEMENT element; // 存放堆栈的元素 NODE* link; // 指向下一个结点的链接&#125;;class STACK &#123;public: STACK(); // 构造函数，设置栈顶为空指针 ~STACK(); // 析构函数，释放堆栈结点占用的存储空间 void push(ELEMENT obj); // 将元素obj压入栈顶 void pop(); // 将当前栈顶的元素弹出栈中。要求：栈不为空。 ELEMENT get_top() const; // 返回当前栈顶的元素值。要求：栈不为空。 bool is_empty() const; // 判断当前堆栈是否为空，空则返回true，非空则返回false void display() const; // 自顶向下显示堆栈中的元素private: NODE* top; // 堆栈的栈顶&#125;;#endif main.cpp(lock) 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &quot;STACK.h&quot;using namespace std;int main()&#123; STACK turner; // 声明一个元素为整数类型的堆栈 ELEMENT user_input; // 用户输入的元素（即整数类型） int loop; // 循环变量 int max_input = 20; for (loop = 1; loop &lt;= max_input; loop++) // 由用户输入若干个元素 &#123; turner.push(loop); // 将用户输入的元素压入栈中 &#125; turner.display(); // 测试堆栈中的内容 for (loop = 1; loop &lt;= max_input; loop++) &#123; if (!turner.is_empty()) // 仅当堆栈不为空时才处理 &#123; user_input = turner.get_top(); // 取出栈顶元素的值 turner.pop(); // 将栈顶元素弹出 cout &lt;&lt;loop&lt;&lt;&quot; &quot;&lt;&lt; user_input &lt;&lt; endl; &#125; &#125; return 0;&#125; STACK.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;STACK.h&quot;#include &lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;STACK::STACK()&#123; top = NULL; // 将栈顶置为空&#125;STACK::~STACK()&#123; NODE* ptr; // 指向堆栈结点的临时指针 while (top != NULL) // 从上到下释放堆栈的结点，注意循环体中语句的次序 &#123; ptr = top; // 先记住将被摘下来的栈顶结点 top = top-&gt;link; // 摘下栈顶结点 delete ptr; // 释放刚才被摘下来的结点 &#125;&#125;void STACK::push(ELEMENT obj) // 将obj压入堆栈的栈顶&#123; NODE* temp; temp = new NODE; // 创建一个新结点 if (temp != NULL) // 内存分配成功时 &#123; temp-&gt;link = top; temp-&gt;element = obj; top = temp; &#125; else // 内存分配失败时作异常处理 &#123; cout &lt;&lt; &quot;Error: No enough memory.&quot;&lt;&lt; endl; exit(1); // 终止程序 &#125;&#125;void STACK::pop() // 将堆栈当前的栈顶元素弹出&#123; NODE* temp; if (top != NULL) // 堆栈不为空时才处理 &#123; temp = top; // 将栈顶元素弹出堆栈 top = top-&gt;link; delete temp; // 释放被弹出结点占用的存储空间 &#125; else // 空栈时作异常处理 &#123; cout &lt;&lt; &quot;Error: Pop from empty stack.\\n&quot;; exit(1); // 终止程序 &#125;&#125;ELEMENT STACK::get_top() const // 返回当前栈顶的元素值&#123; if (top == NULL) // 空栈时作异常处理 &#123; cout &lt;&lt; &quot;Error: Get top from empty stack.\\n&quot;; exit(1); // 终止程序 &#125; return top-&gt;element; // 返回栈顶的当前值&#125;bool STACK::is_empty() const // 判断当前堆栈是否为空，空则返回trur，非空则返回false&#123; return (top == NULL);&#125;void STACK::display() const // 自顶向下显示堆栈中的元素&#123; NODE* loop; loop = top; while (loop != NULL) // 以空指针作为链的结束标记 &#123; cout &lt;&lt; loop-&gt;element &lt;&lt; &quot; &quot;; // 将当前结点的元素输出 loop = loop-&gt;link; // 指向下一个结点 &#125; cout&lt;&lt;endl;&#125; stack.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;NODE* top; // 堆栈的栈顶STACK:: STACK()&#123; top = NULL;&#125; // 构造函数，设置栈顶为空指针STACK:: ~STACK()&#123; while(top != NULL)&#123; NODE* temp = top; top = top -&gt; link; delete top; &#125;&#125; // 析构函数，释放堆栈结点占用的存储空间 void STACK:: push(ELEMENT obj)&#123; NODE* temp = new NODE; temp -&gt; element = obj; temp -&gt; link = top; top = temp;&#125; // 将元素obj压入栈顶void STACK:: pop()&#123; if(!is_empty())&#123; NODE* temp = top; top = top -&gt; link; delete temp; &#125;&#125; // 将当前栈顶的元素弹出栈中。要求：栈不为空。ELEMENT STACK:: get_top() const&#123; if(!is_empty())&#123; return top -&gt; element; &#125;else&#123; return 0; &#125;&#125; // 返回当前栈顶的元素值。要求：栈不为空。bool STACK:: is_empty() const&#123; if(!top) return true; else return false;&#125; // 判断当前堆栈是否为空，空则返回true，非空则返回falsevoid STACK:: display() const&#123; NODE* temp = top; while(temp != NULL)&#123; cout &lt;&lt; temp -&gt; element &lt;&lt; &quot; &quot;; temp = temp -&gt; link; if(temp) cout &lt;&lt; &#x27; &#x27;; else cout &lt;&lt; endl; &#125;&#125; // 自顶向下显示堆栈中的元素","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template(func)","slug":"程设/template(func)","date":"2022-05-23T13:33:37.854Z","updated":"2022-05-23T13:34:54.344Z","comments":true,"path":"2022/05/23/程设/template(func)/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/template(func)/","excerpt":"","text":"Description Implement the 3 functions: 12345template &lt;typename T&gt;void demoFunc(const T v1, const T v2)template &lt;typename T&gt;void demoFunc(const T v)void demoFunc(const int v1, const int v2) Sample Output 12345678the first generic version of demoFunc()the arguments: 2.8 8.5the second generic version of demoFunc()the argument: 3the ordinary version of demoFunc()the arguments: 3 5the ordinary version of demoFunc()the arguments: 65 5 main.cpp(lock) 1234567891011121314151617181920212223#include &quot;demo.hpp&quot;int main()&#123; char ch1 = &#x27;A&#x27;, ch2 = &#x27;B&#x27;; int iv1 = 3, iv2 = 5; double dv1 = 2.8, dv2 = 8.5; // 调用第一个函数模板的实例 demoFunc(dv1, dv2); // 调用第二个函数模板的实例 demoFunc(iv1); // 调用非模板函数demoFunc(int, int) demoFunc(iv1, iv2); // 调用非模板函数demoFunc(int, int)（进行隐式类型转换） demoFunc(ch1, iv2); return 0;&#125; demo.h 123456789101112131415#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;void demoFunc(const T v1, const T v2)&#123; cout &lt;&lt; &quot;the first generic version of demoFunc()&quot; &lt;&lt; endl &lt;&lt; &quot;the arguments: &quot; &lt;&lt; v1 &lt;&lt; &#x27; &#x27; &lt;&lt; v2 &lt;&lt; endl; &#125;template &lt;typename T&gt;void demoFunc(const T v)&#123; cout &lt;&lt; &quot;the second generic version of demoFunc()&quot; &lt;&lt; endl &lt;&lt; &quot;the argument: &quot; &lt;&lt; v &lt;&lt; endl; &#125;void demoFunc(const int v1, const int v2)&#123; cout &lt;&lt; &quot;the ordinary version of demoFunc()&quot; &lt;&lt; endl &lt;&lt; &quot;the arguments: &quot; &lt;&lt; v1 &lt;&lt; &#x27; &#x27; &lt;&lt; v2 &lt;&lt; endl; &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template(class)","slug":"程设/template(class)","date":"2022-05-23T13:08:00.826Z","updated":"2022-05-23T13:29:15.244Z","comments":true,"path":"2022/05/23/程设/template(class)/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/template(class)/","excerpt":"","text":"Description Implement the following template: 1234567891011121314template &lt;typename ElementType, std::size_t N&gt;class Stack&#123;public: Stack(); void push(ElementType obj); void pop(); ElementType getTop() const; bool isEmpty() const;private: ElementType elements[N]; // 堆栈中存放的元素 std::size_t count; // 堆栈中现有元素的数目&#125;; Output 12343201 Hint Note: size_t is in header . main.cpp(lock) 1234567891011121314151617181920#include &quot;array_basedGStack.hpp&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; Stack&lt;int, 10&gt; stack; // 声明一个保存10个int型元素的堆栈 stack.push(1); stack.push(2); stack.push(3); cout &lt;&lt; stack.getTop() &lt;&lt; endl; stack.pop(); cout &lt;&lt; stack.getTop() &lt;&lt; endl; stack.pop(); cout &lt;&lt; stack.isEmpty() &lt;&lt; endl; stack.pop(); cout &lt;&lt; stack.isEmpty() &lt;&lt; endl; return 0;&#125; array_basedGStack.hpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstddef&gt;#include &lt;stdexcept&gt;template &lt;typename ElementType, std::size_t N&gt;class Stack&#123;public: Stack(); void push(ElementType obj); void pop(); ElementType getTop() const; bool isEmpty() const;private: ElementType elements[N]; // 堆栈中存放的元素 std::size_t count; // 堆栈中现有元素的数目&#125;;// #include &quot;array_basedGStack.cpp&quot; // 包含源文件template &lt;typename ElementType, std::size_t N&gt;Stack&lt;ElementType, N&gt;::Stack() // 将堆栈初始化为空栈&#123; count = 0; // 将元素数目置为0&#125;template &lt;typename ElementType, std::size_t N&gt;void Stack&lt;ElementType, N&gt;::push(ElementType obj)// 将元素obj压入堆栈&#123; if (count &lt; N) &#123; // 堆栈未满 elements[count] = obj; count++; &#125; else &#123; // 堆栈已满 throw std::logic_error(&quot;push onto full stack&quot;); &#125;&#125;template &lt;typename ElementType, std::size_t N&gt;void Stack&lt;ElementType, N&gt;::pop()&#123; if (!isEmpty()) count--;&#125;template &lt;typename ElementType, std::size_t N&gt;bool Stack&lt;ElementType, N&gt;::isEmpty() const&#123; if (count == 0) return true; return false;&#125;template &lt;typename ElementType, std::size_t N&gt;ElementType Stack&lt;ElementType, N&gt;::getTop() const&#123; return elements[count - 1];&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template","slug":"程设/template","date":"2022-05-23T13:02:50.690Z","updated":"2022-05-23T13:04:06.951Z","comments":true,"path":"2022/05/23/程设/template/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/template/","excerpt":"","text":"Description Implement the following function template: 12template &lt;typename T, std::size_t N&gt;void printValues(T (&amp;arr)[N]) In this function, you need print the values in the input array. Sample Output 123456789101234561.22.33.44.5 main.cpp(lock) 123456789101112#include &quot;printArray.h&quot;int main()&#123; int intArr[6] = &#123;1, 2, 3, 4, 5, 6&#125;; double dblArr[4] = &#123;1.2, 2.3, 3.4, 4.5&#125;; printValues(intArr); // 生成函数实例printValues(int (&amp;) [6]) printValues(dblArr); // 生成函数实例printValues(double (&amp;) [4]) return 0;&#125; printarrlist.hpp 1234567891011121314#include&lt;iostream&gt;using namespace std;template &lt;typename T, size_t N&gt;void printValues(T (&amp;arr)[N])&#123; size_t i = 0; while(i &lt; N)&#123; cout &lt;&lt; arr[i] &lt;&lt; endl; ++i; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"玩具谜题","slug":"程设/玩具谜题","date":"2022-05-22T12:18:39.499Z","updated":"2022-05-22T12:44:52.194Z","comments":true,"path":"2022/05/22/程设/玩具谜题/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E7%8E%A9%E5%85%B7%E8%B0%9C%E9%A2%98/","excerpt":"","text":"玩具谜题 题目背景 NOIP2016 提高组 D1T1 题目描述 小南有一套可爱的玩具小人, 它们各有不同的职业。 有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图: 这时\\(singer\\)告诉小南一个谜題: “眼镜藏在我左数第3个玩具小人的右数第\\(1\\)个玩具小人的左数第\\(2\\)个玩具小人那里。 ” 小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。 小南一边艰难地辨认着玩具小人, 一边数着: \\(singer\\)朝内, 左数第\\(3\\)个是\\(archer\\)。 \\(archer\\)朝外,右数第\\(1\\)个是\\(thinker\\)。 \\(thinker\\)朝外, 左数第\\(2\\)个是\\(write\\)r。 所以眼镜藏在\\(writer\\)这里! 虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜題的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜題。 这样的谜題具体可以描述为: 有 \\(n\\)个玩具小人围成一圈, 已知它们的职业和朝向。现在第\\(1\\)个玩具小人告诉小南一个包含\\(m\\)条指令的谜題, 其中第 \\(z\\)条指令形如“左数/右数第$ s$,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。 输入格式 输入的第一行包含两个正整数 \\(n,m\\)，表示玩具小人的个数和指令的条数。 接下来 \\(n\\) 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 \\(0\\) 表示朝向圈内，\\(1\\) 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 \\(10\\) 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。 接下来 \\(m\\) 行，其中第 \\(i\\) 行包含两个整数 \\(a_i,s_i\\)，表示第 \\(i\\) 条指令。若 \\(a_i=0\\)，表示向左数 \\(s_i\\) 个人；若 \\(a_i=1\\)，表示向右数 \\(s_i\\) 个人。 保证 \\(a_i\\) 不会出现其他的数，\\(1 \\le s_i &lt; n\\)。 输出格式 输出一个字符串，表示从第一个读入的小人开始，依次数完 \\(m\\) 条指令后到达的小人的职业。 样例 #1 样例输入 #1 12345678910117 30 singer0 reader0 mengbier 1 thinker1 archer0 writer1 mogician 0 31 10 2 样例输出 #1 1writer 样例 #2 样例输入 #2 12345678910111213141516171819202110 101 C0 r0 P1 d1 e1 m1 t1 y1 u0 V1 71 11 40 50 30 11 61 20 80 4 样例输出 #2 1y 提示 【样例1说明】 这组数据就是【题目描述】 中提到的例子。 【子任务】 子任务会给出部分测试数据的特点。 如果你在解决题目中遇到了困难, 可以尝试只解决一部分测试数据。 每个测试点的数据规模及特点如下表: 其中一些简写的列意义如下: • 全朝内: 若为“√”, 表示该测试点保证所有的玩具小人都朝向圈内; 全左数:若为“√”,表示该测试点保证所有的指令都向左数,即对任意的 \\(1≤z≤m, a_i=0\\); \\(s= 1\\):若为“√”,表示该测试点保证所有的指令都只数1个,即对任意的 \\(1≤z≤m,s_i=1\\); 职业长度为\\(1\\) :若为“√”,表示该测试点保证所有玩具小人的职业一定是一个 长度为\\(1\\)的字符串。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int main()&#123; co int n,m; cin&gt;&gt;n&gt;&gt;m; int people[n]; string people1 [n]; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;people[i]; cin&gt;&gt;people1 [i]; &#125; int operator[m][2]; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;operator[i][0]&gt;&gt;operator[i][1]; &#125; int ans = 0 ; for(int i=0;i&lt;m;i++)&#123; if( operator [i][0] == 0 &amp;&amp; people[ans] == 0 )&#123; ans += operator[i][1]; ans%=n; &#125; if( operator [i][0] == 0 &amp;&amp; people[ans] == 1 )&#123; ans -= operator[i][1]; if(ans&lt;0) ans+=n; &#125; if( operator [i][0] == 1 &amp;&amp; people[ans] == 0 )&#123; ans -= operator[i][1]; if(ans&lt;0) ans+=n; &#125; if( operator [i][0] == 1 &amp;&amp; people[ans] == 1 )&#123; ans += operator[i][1]; ans %=n; &#125; &#125; cout &lt;&lt; people1[ans]; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"说假话","slug":"程设/说假话","date":"2022-05-22T12:13:35.787Z","updated":"2022-05-22T12:14:24.156Z","comments":true,"path":"2022/05/22/程设/说假话/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E8%AF%B4%E5%81%87%E8%AF%9D/","excerpt":"","text":"在《三体》中的三体文明接触了人类文明以后逐渐开始学会了说假话，于是三体社会中流行起了聚在一起评论别人说的话是真是假的活动。有一天，N个人（编号范围[0,N−1]）聚在一起，每个人都说了一句：\"*a**i*说的是真/假话\"。现在，围观的你想知道他们每个人说的是真还是假？ 输入格式 第一行一个整数N，表示有N个人 后面接着N行，其中第i行表示编号为i的人说的话，每行有两个整数ai和bi，表示编号为i的人说编号为ai的人说的是真话(bi=1)或假话(*b**i*=0) 数据范围1&lt;=N&lt;=15,0&lt;=ai&lt;N,bi∈{0,1} 输出格式 N个整数，第i个整数为1表示编号为 i 的人实际在说真话，为0表示编号为 i 的人实际在说假话。 若有多种情况，则输出字典序最小的一个。 样例输入1 12321 00 0 样例输出1 10 1 样例输入2 123431 10 10 0 样例输出2 10 0 1 Hint 样例输入1 0号和1号互相说对方说谎，那么有4种情况 1.若0,1实际都在说谎：0说谎所以他说的是假的，从而1说的是真的，这就与1实际在说谎矛盾 2.实际0在说谎，1在说真话：0说谎所以他说的是假的，从而1说的是真的，不矛盾；1在说真话所以0在说谎，不矛盾 3.实际1在说谎，0在说真话：1说谎所以他说的是假的，从而0说的是真的，不矛盾；0在说真话所以1在说谎，不矛盾 4.若0，1实际都在说真话：0说真话所以1在说谎，这就与1实际在说真话矛盾 故只有2，3两种情况是逻辑自治的，其中情况2为“0 1”而情况3为“1 0”，所以输出小的那一个“0 1” 样例输入2 只有两种情况是逻辑自治的： 1.0号1号都在说谎，2号在说真话 2.0号1号都在说真话，2号在说谎 情况1为“0 0 1”，情况2为“1 1 0”，所以输出小的那个“0 0 1” main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdlib&gt; using namespace std;int test [15] = &#123;0&#125;;int ans [15][2] = &#123;0,0&#125;;void dfs(int now,int n)&#123; if( now == n )&#123; int flag=0; for(int i=0 ; i&lt;n ;i++)&#123; if( ans[i][1] == 0 &amp;&amp; test [ ans[i][0] ] == 1 &amp;&amp; test[i] == 1) flag=1; if( ans[i][1] == 1 &amp;&amp; test [ ans[i][0] ] == 0 &amp;&amp; test[i] == 1) flag=1; if( ans[i][1] == 1 &amp;&amp; test [ ans[i][0] ] == 1 &amp;&amp; test[i] == 0) flag=1; if( ans[i][1] == 0 &amp;&amp; test [ ans[i][0] ] == 0 &amp;&amp; test[i] == 0) flag=1; &#125; if(flag == 0)&#123; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; test [i]&lt;&lt;&quot; &quot;; &#125; exit(0); &#125; return; &#125; test[ now ] = 0 ; dfs( now + 1 , n ); test[ now ] = 1; dfs( now + 1, n);&#125;int main()&#123; int n; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; ans[i][0]; cin &gt;&gt; ans[i][1]; &#125; dfs(0,n); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"神经网络类","slug":"程设/神经网络类","date":"2022-05-22T12:10:53.956Z","updated":"2022-06-08T10:07:11.631Z","comments":true,"path":"2022/05/22/程设/神经网络类/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%B1%BB/","excerpt":"","text":"题目描述 深度神经网络由若干不同类型的层组成。每一层可以视为一个函数，方便起见，在本题中我们设定所有层的输入和输出都是长度为 n 的一维向量，即 x∈Rn。为了方便地搭建深度神经网络，你需要先在 layer.hpp 中设计一个表示层的抽象基类Layer，所有具体的层类型都继承自该基类，并且所有具体的层类型都要有一个 forward 方法，用以计算前向结果。在 linear.hpp 中已经实现了一个 Linear 层，你可以参考该层的实现来设计 Layer。Linear 层的数学定义如下： Linear(x)=Wx+b 其中 W∈Rn×n,b∈Rn 为参数，应当在构造 Linear 层时输入。 然后，你需要再在 conv.hpp 中实现一个 Conv 层，该层的数学定义如下： \\[Conv_i(x)=\\sum_{j=0}^{2m}k_jX_{i−m+j}\\] 其中 \\[k∈R^{2m+1}\\] 为参数，应当在构造 Conv 层时输入。 例如，当m=1时，output的其中一个维度，如output[2]=k[0]∗x[1]+k[1]∗x[2]+k[2]∗x[3]。 注意若有超出范围的部分则不需要计算，例如*outpu**t[0]=k[1]∗x[0]+k[2]∗x[1]，这里不存在x*[−1]就不用算它。 conv.hpp 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;class Conv: public Layer&#123;private: double * K; int n; int m;public: Conv(int a, int b,double * k):n(a),m(b)&#123; K = new double [2*m+1]; memcpy( K , k , (2*m+1) * sizeof(double) ); &#125; void forward(double *input,double *output)const&#123; for(int i=0; i &lt; n ;i++)&#123; double sum = 0; for(int j=0; j&lt;2*m +1; j++)&#123; if(i-m+j &lt; 0 ) continue; if(i-m+j &gt;= n ) continue; sum += K[j] * input [ i- m +j ]; &#125; output[i] = sum; sum = 0; &#125; &#125; ~Conv()&#123; delete [] K; &#125;&#125;; layer.hpp 12345678910111213141516171819202122#ifndef LAYER_H_#define LAYER_H_ #include &lt;iostream&gt;#include &lt;iomanip&gt;class Layer&#123;public: virtual void forward(double * const input, double * output)const = 0; virtual ~Layer()&#123;&#125;;&#125;;#endif linear.h(lock) 123456789101112131415161718192021222324252627#pragma once#include &quot;layer.hpp&quot;#include &quot;new_tensor.hpp&quot;class Linear: public Layer &#123;private: double const * const * const _W; double const * const _b; const int _n;public: Linear(int n, double * const * const W, double * const b): _W(new_tensor_2d(n, W)), _b(new_tensor_1d(n, b)), _n(n) &#123;&#125; void forward(double * const input, double * output) const &#123; for (int i = 0; i &lt; _n; ++i) &#123; output[i] = _b[i]; for (int j = 0; j &lt; _n; ++j) output[i] += _W[i][j] * input[j]; &#125; &#125; ~Linear() &#123; delete[] _b; for (int i = 0; i &lt; _n; ++i) delete[] _W[i]; delete[] _W; &#125;&#125;; main.cpp(lock) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &quot;layer.hpp&quot;#include &quot;linear.hpp&quot;#include &quot;conv.hpp&quot;int main() &#123; int d, n, m, type_mark; double **W, *b, *k; std::cin &gt;&gt; d &gt;&gt; n; Layer ** layers = new Layer * [d]; W = new double * [n]; b = new double [n]; k = new double [n]; for (int i = 0; i &lt; n; ++i) W[i] = new double [n]; for (int i = 0; i &lt; d; ++i) &#123; std::cin &gt;&gt; type_mark; if (type_mark == 0) &#123; // Linear for (int x = 0; x &lt; n; ++x) for (int y = 0; y &lt; n; ++y) std::cin &gt;&gt; W[x][y]; for (int x = 0; x &lt; n; ++x) std::cin &gt;&gt; b[x]; layers[i] = new Linear(n, W, b); &#125; else &#123; // Conv std::cin &gt;&gt; m; for (int x = 0; x &lt; 2*m+1; ++x) std::cin &gt;&gt; k[x]; layers[i] = new Conv(n, m, k); &#125; &#125; double * x = new double [n]; double ** y = new double * [d]; for (int i = 0; i &lt; d; ++i) y[i] = new double [n]; int T; std::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(2); for (std::cin &gt;&gt; T; T &gt; 0; --T) &#123; for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; x[i]; layers[0]-&gt;forward(x, y[0]); for (int i = 1; i &lt; d; ++i) layers[i]-&gt;forward(y[i-1], y[i]); for (int i = 0; i &lt; n-1; ++i) std::cout &lt;&lt; y[d-1][i] &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; y[d-1][n-1] &lt;&lt; std::endl; &#125; for (int i = 0; i &lt; d; ++i) &#123; delete layers[i]; delete [] y[i]; &#125; delete [] layers; delete [] y; for (int i = 0; i &lt; n; ++i) delete [] W[i]; delete [] W; delete [] b; delete [] k; delete [] x; return 0;&#125; new_tensor.hpp(lock) 1234567891011121314151617#pragma once#include &lt;cstring&gt;double * new_tensor_1d(int n, double * const source) &#123; double * target = new double[n]; memcpy(target, source, n * sizeof(double)); return target;&#125;double * const * new_tensor_2d(int n, double * const * const source) &#123; double * * target = new double * [n]; for (int i = 0; i &lt; n; ++i) &#123; target[i] = new_tensor_1d(n, source[i]); &#125; return target;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"链表","slug":"程设/链表","date":"2022-05-22T12:09:33.144Z","updated":"2022-05-22T12:10:41.542Z","comments":true,"path":"2022/05/22/程设/链表/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目描述 请在 orderedList.hpp 中定义以下三个类： 抽象 基类 1OrderedList ，表示一个整数链表，有以下方法： 构造函数：无参数，创建一个空的链表； void insert(int val) 向链表中插入一个元素，在 OrderedList 中该方法应当为纯虚函数； void printList() const 依次在屏幕上输出链表中的元素，元素之间用空格分隔，输出完整个链表后换行； 析构函数：释放链表所占用的空间。 具体类 AscendOrderedList，表示一个升序的链表，继承自 OrderedList，需要重载 void insert(int val) 函数来实现升序。 具体类 DescendOrderedList，表示一个降序的链表，继承自 OrderedList，需要重载 void insert(int val) 函数来实现降序。 main.cpp(lock) 12345678910111213141516171819#include &lt;iostream&gt;#include &quot;orderedList.hpp&quot;int main() &#123; int n, x; OrderedList * a = new AscendOrderedList, * d = new DescendOrderedList; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; x; a-&gt;insert(x); d-&gt;insert(x); &#125; a-&gt;printList(); d-&gt;printList(); delete a; delete d; return 0;&#125; orderlist.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;using namespace std;class node&#123;public: int data; node * Node; node()&#123; Node = NULL; &#125; node(int a)&#123; data = a; Node = NULL; &#125; // node(int a, node * b): data(a)&#123; // node* temp = b; // while(temp-&gt;Node != NULL)&#123; // temp = temp -&gt; Node; // &#125; // &#125;&#125;;class OrderedList&#123;public: node* head; OrderedList()&#123; head = new node (); &#125; virtual void insert(int val) = 0; void printList()const&#123; node* temp = head; if(temp -&gt; Node == NULL) return; else &#123; temp = temp -&gt; Node; &#125; while(temp != NULL)&#123; cout&lt;&lt;temp -&gt; data &lt;&lt; &quot; &quot;; temp = temp -&gt; Node; &#125; cout&lt;&lt;endl; &#125; virtual ~OrderedList()&#123; node * temp = head; while(temp -&gt; Node != NULL)&#123; node* a = temp; temp = temp -&gt; Node; delete a; &#125; delete temp; &#125;&#125;;class AscendOrderedList : public OrderedList&#123; public: void insert(int val)&#123; node* temp = head; if(temp -&gt; Node == NULL)&#123; temp -&gt; Node = new node (val); return ; &#125; temp = temp -&gt; Node; while(temp -&gt;data &lt;= val &amp;&amp; temp -&gt; Node != NULL )&#123; temp = temp -&gt; Node; &#125; if( temp -&gt; data &gt; val )&#123; node* a = head; while(a-&gt;Node != temp)&#123; a = a -&gt;Node; &#125; a-&gt;Node = new node (val); a-&gt;Node-&gt;Node = temp; return ; &#125; if( temp -&gt; Node == NULL )&#123; temp -&gt; Node = new node (val); return ; &#125; &#125;&#125;;class DescendOrderedList : public OrderedList&#123;public: void insert(int val)&#123; node* temp = head; if(temp -&gt; Node == NULL)&#123; temp -&gt; Node = new node (val); return ; &#125; temp = temp -&gt; Node; while(temp -&gt;data &gt;= val &amp;&amp; temp -&gt; Node != NULL )&#123; temp = temp -&gt; Node; &#125; if( temp -&gt; data &lt; val )&#123; node* a = head; while(a-&gt;Node != temp)&#123; a = a -&gt;Node; &#125; a-&gt;Node = new node (val); a-&gt;Node-&gt;Node = temp; return ; &#125; if( temp -&gt; Node == NULL )&#123; temp -&gt; Node = new node (val); return ; &#125; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"多态","slug":"程设/多态","date":"2022-05-22T12:07:59.961Z","updated":"2022-05-22T12:08:51.376Z","comments":true,"path":"2022/05/22/程设/多态/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E5%A4%9A%E6%80%81/","excerpt":"","text":"Description Design a class named Person and its two derived classes namedStudent and Employee. Make Faculty and Staff derived classes of Employee. Person class has the following members: 1234string name;string address;string phoneNumber;string email; Student class has the following members: 12enum class_status&#123;frssman,sophomore,junior,senior&#125;; class_status status; Employee class has the following members: 123string office;int salary;MyDate dateHired; Faculty class has the following members: 12string officeHours;int rank; Staff class has the following members: 1string title; MyDate class contains the following members: 123int year;int month;int day; Override the toString function in each class to display the class name. For example, in Employee class: 1234string toString() const&#123; return &quot;Employee&quot;;&#125; Make sure that the following code: 123456789101112131415void f(const Person &amp;p)&#123; cout &lt;&lt; p.toString() &lt;&lt; endl;&#125;Person person;Student student;Employee employee;Faculty faculty;Staff staff;f(person);f(student);f(employee);f(faculty);f(staff); outputs: 12345PersonStudentEmployeeFacultyStaff source.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person&#123;public: string name; string address; string phoneNumber; string email; virtual string toString() const &#123; return &quot;Person&quot;; &#125;&#125;;class Student: public Person&#123;public: enum class_status&#123;frssman,sophomore,junior,senior&#125;; class_status status; virtual string toString() const &#123; return &quot;Student&quot;; &#125;&#125;;class MyDate&#123;public: int year; int month; int day;&#125;;class Employee: public Person&#123;public: string office; int salary; MyDate dateHired; virtual string toString() const &#123; return &quot;Employee&quot;; &#125;&#125;;class Faculty: public Employee&#123;public: string officeHours; int rank; virtual string toString() const &#123; return &quot;Faculty&quot;; &#125;&#125;;class Staff : public Employee&#123;public: string title; virtual string toString() const &#123; return &quot;Staff&quot;; &#125;&#125;; framework.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;source.h&quot;using namespace std;void f1(Person p)&#123; cout &lt;&lt; p.toString() &lt;&lt; endl;&#125;void f2(Employee e)&#123; cout &lt;&lt; e.toString() &lt;&lt; endl;&#125;void f(const Person &amp;p)&#123; cout &lt;&lt; p.toString() &lt;&lt; endl;&#125;int main()&#123; Person person; Student student; Employee employee; Faculty faculty; Staff staff; f1(person); f1(student); f1(employee); f1(faculty); f1(staff); f2(employee); f2(faculty); f2(staff); f(person); f(student); f(employee); f(faculty); f(staff); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"虚函数","slug":"程设/虚函数","date":"2022-05-22T12:06:35.792Z","updated":"2022-05-31T12:16:12.818Z","comments":true,"path":"2022/05/22/程设/虚函数/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E8%99%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++:Instance of Description 在Java语言里边，所有的对象都会继承Object类，但C++却是没有的 例如以下的一些类： class Object; class Animal:public Object; class Dog:public Animal; class Cat:public Animal; class Vehicle:public Object; class Bus:public Vehicle; class Car:public Vehicle; class Person:public Object; class Student:public Person; class Teacher:public Person; 我们知道对象是可以向上向下转型的，就例如 Animal* animal = new Dog(); 因为继承本身就是一种is-a的关系，狗就是动物，因此这样赋值是没问题的。 但是问题来了。倘若别人传递上述代码的animal对象给你，你这个时候却不知道它原本是Dog这个类的（在Java里边是有instance of 可以判断的），于是现在你的任务来了。 请完成以下函数以及类，使得满足instanceof函数可以返回该对象的类型名字。（注意这里的类全部都还没定义，你可以根据自己的思路去完成定义，完成的方法不限，能AC即可） 123456789101112131415161718192021222324252627282930class Object;class Animal:public Object;class Dog:public Animal;class Cat:public Animal;class Vehicle:public Object;class Bus:public Vehicle;class Car:public Vehicle;class Person:public Object;class Student:public Animal;class Teacher:public Animal;/** 一个Object对象* 返回这个对象实例实际的类型名* 例如： Object *obj = new Bus();* 则instanceof(*obj) == &quot;Bus&quot;*/string instanceof(Object obj); Input N/A Output N/A Sample_Input 123456样例测试: Object *obj = new Dog(); cout &lt;&lt; instanceof(*obj) &lt;&lt; endl; Object *obj = new Car(); cout &lt;&lt; instanceof(*obj) &lt;&lt; endl; Sample_Ouput 12DogCar Hint 无需提交主函数！ framework.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;source.h&quot;using namespace std;int main()&#123; Object *obj = new Dog(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Animal(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Car(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Bus(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Cat(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Vehicle(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Teacher(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Person(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Student(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Object(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; return 0;&#125; source.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Object&#123;public: string a; Object():a(&quot;Object&quot;)&#123;&#125; Object(string b):a(b)&#123;&#125; virtual ~Object()&#123;&#125;&#125;;class Animal:public Object&#123;public: Animal():Object(&quot;Animal&quot;)&#123;&#125; Animal(string a):Object(a)&#123; &#125;&#125;;class Dog:public Animal&#123;public: Dog():Animal(&quot;Dog&quot;)&#123;&#125;&#125;;class Cat:public Animal&#123;public: Cat():Animal(&quot;Cat&quot;)&#123;&#125;&#125;;class Vehicle:public Object&#123;public: Vehicle():Object(&quot;Vehicle&quot;)&#123;&#125; Vehicle(string a):Object(a)&#123;&#125;&#125;;class Bus:public Vehicle&#123;public: Bus():Vehicle(&quot;Bus&quot;)&#123;&#125;&#125;;class Car:public Vehicle&#123;public: Car():Vehicle(&quot;Car&quot;)&#123;&#125;&#125;;class Person:public Object&#123;public: Person():Object(&quot;Person&quot;)&#123;&#125; Person(string a):Object(a)&#123;&#125;&#125;;class Student:public Person&#123;public: Student():Person(&quot;Student&quot;)&#123;&#125;&#125;;class Teacher:public Person&#123;public: Teacher():Person(&quot;Teacher&quot;)&#123;&#125;&#125;;/** 一个Object对象* 返回这个对象实例实际的类型名* 例如： Object *obj = new Bus();* 则instanceof(*obj) == &quot;Bus&quot;*/string instanceof(Object&amp; obj)&#123; return obj.a;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"抽象类","slug":"程设/抽象类","date":"2022-05-22T12:04:52.255Z","updated":"2022-05-22T12:06:00.492Z","comments":true,"path":"2022/05/22/程设/抽象类/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"Description 声明一个Shape抽象类，在此基础上派生出Rectangle类和Circle类，两者都有GetArea（）和GetPerim（）函数，用来计算面积和周长，麻烦封装以上各类，编写程序。需要提交类shape、Rectangle、Cricle类 Input 第一行输入n，表示n个测试例子；接下来有n行，每一行输入数，a、b、c，表示矩形的宽、长，以及圆形的半径 Output 对应每一行输入： 第一行输出矩形的面积、周长 第二行输出圆形的面积、周长 Sample_Input 1212 2 3 Sample_Ouput 124 828.26 18.84 Hint const double PI = 3.14； (Already defined) framework.cpp 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const double PI = 3.14;#include &quot;source.h&quot;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); double n,a,b,c; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; Shape *s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; s = new Rectangle(a,b); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; s = new Circle(c); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; &#125; return 0;&#125; source.h 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Shape&#123;public: virtual double GetArea() = 0; virtual double GetPerim() = 0;&#125;;class Rectangle :public Shape&#123;public: double wid; double leng; Rectangle(double a,double b):wid(a),leng(b)&#123;&#125; double GetArea()&#123; return wid*leng; &#125; double GetPerim()&#123; return 2*(wid+leng); &#125; &#125;;class Circle :public Shape&#123;public: double rad; Circle(double a):rad(a)&#123;&#125; double GetArea()&#123; return rad*rad*PI; &#125; double GetPerim()&#123; return 2*PI*rad; &#125; &#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"传参","slug":"程设/访问控制","date":"2022-05-22T12:00:26.283Z","updated":"2022-05-22T12:04:37.497Z","comments":true,"path":"2022/05/22/程设/访问控制/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","excerpt":"","text":"Description 写出3组Plus函数的声明与实现，类型分别为int，double，string。 主函数如下，注意只需要实现Plus函数和包含相关的头文件。 1234567891011121314151617int main() &#123; int n; int a,b; double c,d; std::string str1,str2; std::cin&gt;&gt;n; while(n--) &#123; std::cin &gt;&gt; a &gt;&gt; b ; std::cin &gt;&gt; c &gt;&gt; d; std::cin &gt;&gt; str1 &gt;&gt; str2; std::cout &lt;&lt; myplus(a, b) &lt;&lt; endl; std::cout &lt;&lt; myplus(d, c) &lt;&lt; endl; std::cout &lt;&lt; myplus(str1, str2) &lt;&lt; endl; &#125; return 0;&#125; Sample Input 123412 32.5 3.5women day Sample Output 12356womenday Hint PS：Please add std:: before using the string type. framework.cpp(lock) 1234567891011121314#include&lt;iostream&gt;using namespace std;int myplus(int a, int b)&#123; return a+b;&#125;double myplus(double a, double b)&#123; return a+b;&#125;std::string myplus(const std::string&amp; a, const std::string&amp; b)&#123; return a+b;&#125; source.h 1234567891011121314#include&lt;iostream&gt;using namespace std;int myplus(int a, int b)&#123; return a+b;&#125;double myplus(double a, double b)&#123; return a+b;&#125;std::string myplus(const std::string&amp; a, const std::string&amp; b)&#123; return a+b;&#125; Description As shown in the following code segment, op is an object of class Number. Please implement Number in which you should: write the member functions of add and sub with one int parameter respectively. write a constructor with one int parameter. write a print function to print the result. Number op(1); op.add(2).sub(3).add(4) op.print(); // output：4 Input Output Sample_Input 1234Sample Test Number n(1); n.add(2).sub(3).add(4); n.print(); Sample_Ouput 14 Hint framework.cpp 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &quot;source.h&quot;using namespace std;int main()&#123; Number n(1); n.add(2).sub(3).add(4); n.print(); Number n1(-1); n1.sub(12).sub(3).sub(4); n1.print(); Number n2(0); n2.add(-13).add(0).add(0); n2.add(13); n2.print(); return 0;&#125; source.h 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Number&#123;private: int n;public: Number(int a)&#123; n=a; &#125; Number&amp; add(int a)&#123; n+=a; return *this; &#125; Number&amp; sub(int a)&#123; n-=a; return *this; &#125; void print()&#123; cout&lt;&lt;n&lt;&lt;endl; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Tiger and cat","slug":"程设/Tiger and cat","date":"2022-05-22T11:59:00.673Z","updated":"2022-05-22T12:00:21.299Z","comments":true,"path":"2022/05/22/程设/Tiger and cat/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/Tiger%20and%20cat/","excerpt":"","text":"猫科动物和老虎 Description 下面是不完整的继承类定义， 12345678910111213class Cat&#123; int data;public: Cat();&#125;;class Tiger : public Cat&#123; int data;public: Tiger(int);&#125;; 试完成其定义(你可以根据需要增加必要的构造函数和析构函数)，使得主函数main运行后能得到其后结果： 12345678int main()&#123; Cat bc; Tiger dc(6); Tiger dc1(18); return 0;&#125; 运行结果： Default Constructor of Cat is Running Constructor of Cat is Running 6 Constructor of Tiger is Running 6 Constructor of Cat is Running 18 Constructor of Tiger is Running 18 Destructor of Tiger is Running 18 Destructor of Cat is Running 18 Destructor of Tiger is Running 6 Destructor of Cat is Running 6 Destructor of Cat is Running 0 framework.cpp 1234567891011121314#include &lt;iostream&gt;using namespace std;#include &quot;source.h&quot;int main()&#123; Tiger t1(9); Cat c1; Tiger t2(25); return 0;&#125; source.h 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class Cat&#123; int data;public: Cat():data(0)&#123; cout&lt;&lt;&quot;Default Constructor of Cat is Running&quot;&lt;&lt;endl; &#125; Cat(int a):data(a)&#123; cout&lt;&lt;&quot;Constructor of Cat is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125; ~Cat()&#123; cout&lt;&lt;&quot;Destructor of Cat is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125;&#125;;class Tiger : public Cat&#123; int data;public: Tiger(int a):Cat(a),data(a)&#123; cout&lt;&lt;&quot;Constructor of Tiger is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125; ~Tiger()&#123; cout&lt;&lt;&quot;Destructor of Tiger is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"time(继承)","slug":"程设/time","date":"2022-05-14T09:26:42.205Z","updated":"2022-05-14T10:45:11.513Z","comments":true,"path":"2022/05/14/程设/time/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/time/","excerpt":"","text":"Description 需要实现的是一下两个类，time作为父类，ExtTime作为子类，以下是两个类的声明，你需要做的是，实现这两个类。 123456789101112131415161718192021222324252627class Time&#123; public : void Set ( int hours , int minutes , int seconds ) ; void Increment ( ) ; void Write ( ) const ; Time ( int initHrs, int initMins, int initSecs ) ; // constructor Time ( ) ; // default constructorprivate : int hrs ; int mins ; int secs ;&#125; class ExtTime : public Time // Time is the base class&#123;public : ExtTime ( int initHrs , int initMins , int initSecs , ZoneType initZone ) ; // constructor ExtTime ( ) ; // default constructor void Set ( int hours, int minutes, int seconds , ZoneType timeZone ) ; void Write ( ) const ; private : ZoneType zone ; // added data member&#125; ; Sample Output 1234567891011121314151617time1: 05:30:00 CDTtime2: 00:00:00 ESTNew time2: 23:59:55 PSTIncrementing time2:23:59:55 PST23:59:56 PST23:59:57 PST23:59:58 PST23:59:59 PST00:00:00 PST00:00:01 PST00:00:02 PST00:00:03 PST00:00:04 PSTtime3: 01:02:0303:04:05 main.cpp(lock) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &quot;ExtTime.h&quot; //程序4_4#include &quot;Time.h&quot;using namespace std;int main()&#123; ExtTime time1(5, 30, 0, CDT); ExtTime time2; int count; cout &lt;&lt; &quot;time1: &quot;; time1.Write(); cout &lt;&lt; endl; cout &lt;&lt; &quot;time2: &quot;; time2.Write(); cout &lt;&lt; endl; time2.Set(23, 59, 55, PST); cout &lt;&lt; &quot;New time2: &quot;; time2.Write(); cout &lt;&lt; endl; cout &lt;&lt; &quot;Incrementing time2:&quot; &lt;&lt; endl; for (count = 1; count &lt;= 10; count++) &#123; time2.Write(); cout &lt;&lt; endl; time2.Increment(); &#125; Time time3(1,2,3); cout &lt;&lt; &quot;time3: &quot;; time3.Write(); cout &lt;&lt; endl &lt;&lt; endl; time1.Time::Set(3,4,5); time1.Time::Write(); cout &lt;&lt; endl; return 0;&#125; ExtTime.h(lock) 12345678910111213141516171819202122#ifndef ExtTime_H#define ExtTime_H#include &quot;Time.h&quot;enum ZoneType &#123;EST, CST, MST, PST, EDT, CDT, MDT, PDT &#125; ;class ExtTime : public Time // Time is the base class&#123;public : ExtTime ( int initHrs , int initMins , int initSecs , ZoneType initZone ) ; // constructor ExtTime ( ) ; // default constructor void Set ( int hours, int minutes, int seconds , ZoneType timeZone ) ; void Write ( ) const ; private : ZoneType zone ; // added data member&#125; ;#endif Time.h 12345678910111213141516171819202122#ifndef Time_H#define Time_H#include &lt;iostream&gt;using namespace std;class Time&#123;public: void Set(int hours, int minutes, int seconds); void Increment(); void Write() const; Time(int initHrs, int initMins, int initSecs); // constructor Time(); // default constructorprivate: int hrs; int mins; int secs;&#125;;#endif Time.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;Time.h&quot;#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;Time::Time( int initHrs, int initMins, int initSecs )&#123; hrs = initHrs; mins = initMins; secs = initSecs;&#125;Time::Time()&#123; hrs = 0; mins = 0; secs = 0;&#125;void Time::Set( int hours, int minutes, int seconds )&#123; hrs = hours; mins = minutes; secs = seconds;&#125;void Time::Increment() // IMPLEMENTATION FILE ( time.cpp )&#123; secs++; if (secs &gt; 59) &#123; secs = 0; mins++; if (mins &gt; 59) &#123; mins = 0; hrs++; if (hrs &gt; 23) hrs = 0; &#125; &#125;&#125;void Time::Write() const&#123; if (hrs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; hrs &lt;&lt; &quot;:&quot;; if (mins &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; mins &lt;&lt; &quot;:&quot;; if (secs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; secs;&#125; ExtTime.cpp 1234567891011121314151617181920212223242526#include&quot;Time.h&quot;#include&lt;iomanip&gt;void Time::Set(int hours, int minutes, int seconds)&#123; hrs = hours; mins = minutes; secs = seconds;&#125;void Time::Increment()&#123; secs++; if(secs == 60)&#123; secs = 0; mins++; if(mins == 60)&#123; mins = 0; hrs++; if(hrs == 24)&#123; hrs = 0; &#125; &#125; &#125;&#125;void Time::Write() const&#123; cout &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;)&lt;&lt; hrs &lt;&lt; &#x27;:&#x27; &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;)&lt;&lt; mins &lt;&lt; &#x27;:&#x27; &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;)&lt;&lt; secs;&#125;Time::Time(int initHrs, int initMins, int initSecs):hrs(initHrs), mins(initMins), secs(initSecs)&#123;&#125;Time::Time():hrs(0), mins(0), secs(0)&#123;&#125; 参考答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;Time.h&quot;#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;Time::Time( int initHrs, int initMins, int initSecs )&#123; hrs = initHrs; mins = initMins; secs = initSecs;&#125;Time::Time()&#123; hrs = 0; mins = 0; secs = 0;&#125;void Time::Set( int hours, int minutes, int seconds )&#123; hrs = hours; mins = minutes; secs = seconds;&#125;void Time::Increment() // IMPLEMENTATION FILE ( time.cpp )&#123; secs++; if (secs &gt; 59) &#123; secs = 0; mins++; if (mins &gt; 59) &#123; mins = 0; hrs++; if (hrs &gt; 23) hrs = 0; &#125; &#125;&#125;void Time::Write() const&#123; if (hrs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; hrs &lt;&lt; &quot;:&quot;; if (mins &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; mins &lt;&lt; &quot;:&quot;; if (secs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; secs;&#125; 123456789101112131415161718192021222324252627282930313233343536#include &quot;ExtTime.h&quot;#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;ExtTime::ExtTime( int initHrs, int initMins, int initSecs, ZoneType initZone ) : Time(initHrs, initMins, initSecs)&#123; zone = initZone;&#125;ExtTime::ExtTime()&#123; zone = EST;&#125;void ExtTime::Set( int hours, int minutes, int seconds, ZoneType timeZone )&#123; Time::Set(hours, minutes, seconds); //调用基类函数。Why? zone = timeZone;&#125;void ExtTime::Write() const&#123; static string zoneString[8] = &#123; &quot;EST&quot;, &quot;CST&quot;, &quot;MST&quot;, &quot;PST&quot;, &quot;EDT&quot;, &quot;CDT&quot;, &quot;MDT&quot;, &quot;PDT&quot; &#125;; Time::Write(); cout &lt;&lt; &quot; &quot; &lt;&lt; zoneString[zone];&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"shape(多态)","slug":"程设/shape(多态)","date":"2022-05-14T09:17:11.258Z","updated":"2022-05-14T09:25:52.529Z","comments":true,"path":"2022/05/14/程设/shape(多态)/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/shape(%E5%A4%9A%E6%80%81)/","excerpt":"","text":"Description 声明一个Shape抽象类，在此基础上派生出Rectangle类和Circle类，两者都有GetArea()和GetPerim()函数，用来计算面积和周长，麻烦封装以上各类，编写程序。需要提交类Shape、Rectangle、Cricle。 以下是主函数： 1234567891011121314151617int main ()&#123; double n,a,b,c; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; Shape *s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; s = new Rectangle(a,b); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; s = new Circle(c); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; &#125; return 0;&#125; Input 第一行输入n，表示n个测试例子；接下来有n行，每一行输入数a、b、c，表示矩形的宽、长，以及圆形的半径。 输入处理已经由框架代码处理，你无需另外处理。 Output 对应每一行输入： 第一行输出矩形的面积、周长； 第二行输出圆形的面积、周长。 输出处理已经由框架代码处理，你无需另外处理。 Sample Input 1212 2 3 Sample Output 124 828.26 18.84 Hint 我们已经为你定义了圆周率PI，请勿使用其他数值。 1const double PI = 3.14; framework.cpp(lock) 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const double PI = 3.14;#include &quot;source.h&quot;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); double n,a,b,c; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; Shape *s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; s = new Rectangle(a,b); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; s = new Circle(c); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; &#125; return 0;&#125; source.h 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class Shape &#123; public: virtual double GetArea() &#123;&#125;; virtual double GetPerim() &#123;&#125;;&#125;;class Rectangle: public Shape &#123; private: double length; double height; public: Rectangle(double l, double h) &#123; length = l; height = h; &#125; virtual double GetArea() &#123; return length * height; &#125; virtual double GetPerim() &#123; return 2*(length + height); &#125;&#125;;class Circle: public Shape &#123; private: double radius; public: Circle(double r) &#123; radius = r; &#125; virtual double GetArea() &#123; return 3.14 * radius * radius; &#125; virtual double GetPerim() &#123; return 6.28 * radius; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"多态","slug":"程设/多态(淘宝排序)","date":"2022-05-14T08:56:26.672Z","updated":"2022-05-14T08:58:27.293Z","comments":true,"path":"2022/05/14/程设/多态(淘宝排序)/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/%E5%A4%9A%E6%80%81(%E6%B7%98%E5%AE%9D%E6%8E%92%E5%BA%8F)/","excerpt":"","text":"Description Feng Gor除了是个房地产商外，像大多数女生一样，她也是喜欢逛淘宝的。我们都知道，在淘宝上有很多很多的商品。当然，Feng Gor挑的一般都是最贵的，但是偶尔也是要看看销量参考一下的啊。因此，她希望淘宝能够按照她想要的方式来排序：当她想要按价格排序，商品就按价格排序；当她想要按销量排序，商品就按销量排序（都是按照从大到小排序）。淘宝这种大公司肯定已经提供这个功能的啊。不过，作为一个程序猿，她希望大家也来用C++模拟实现一下。 代表商品的结构体如下： 1234struct TaoBaoItem &#123; int price; int volume_of_sales;&#125;; 为了能实现不同的排序方式，她特意抽象出了一个接口出来： 123456class SortInterface &#123; public: virtual ~SortInterface() &#123;&#125;; virtual void DoSort(TaoBaoItem item[], int size) = 0;&#125;; 接下来，她要你们实现的类如下： 12345678910111213141516171819202122class SortByPrice : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size);&#125;; class SortBySales : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size);&#125;;class TaoBao &#123; public: TaoBao(SortInterface* strategy); void SetSortStrategy(SortInterface* strategy); // Use current strategy_ to do the sort. void sort(TaoBaoItem item[], int size); private: SortInterface *strategy_;&#125;; 你提交的实现可能会被测试框架用如下的方式进行调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct TaoBaoItem &#123; int price; int volume_of_sales;&#125;;class SortInterface &#123; public: virtual ~SortInterface() &#123;&#125;; virtual void DoSort(TaoBaoItem item[], int size) = 0;&#125;;#include &quot;source.cpp&quot;void printItem(TaoBaoItem arr[], int size) &#123; for (int i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; arr[i].price &lt;&lt; &quot; &quot; &lt;&lt; arr[i].volume_of_sales &lt;&lt; endl; &#125;&#125;int main(int argc, char *argv[]) &#123; TaoBaoItem item[4] = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;, &#123;5, 1&#125;, &#123;3, 10&#125; &#125;; SortByPrice price; SortBySales sales; TaoBao taobao(&amp;price); taobao.sort(item, 4); printItem(item, 4); taobao.SetSortStrategy(&amp;sales); taobao.sort(item, 4); printItem(item, 4); return 0;&#125; Sample Output 123456785 13 102 31 23 102 31 25 1 Hint 这其实是一种叫做“策略模式”的设计模式，有兴趣的同学查阅该条目的维基百科页面（中文，英文）。不过，这个题目最主要的目的是想让大家体验一下多态带来的好处。 关于排序的实现，大家可以尝试使用std::sort函数，使用方法请自行查找。 framework.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct TaoBaoItem &#123; int price; int volume_of_sales;&#125;;class SortInterface &#123; public: virtual ~SortInterface() &#123;&#125;; virtual void DoSort(TaoBaoItem item[], int size) = 0;&#125;;#include &quot;source.h&quot;void printItem(TaoBaoItem arr[], int size) &#123; for (int i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; arr[i].price &lt;&lt; &quot; &quot; &lt;&lt; arr[i].volume_of_sales &lt;&lt; endl; &#125;&#125;int main(int argc, char *argv[]) &#123; TaoBaoItem item[4] = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;, &#123;5, 1&#125;, &#123;3, 10&#125; &#125;; SortByPrice price; SortBySales sales; TaoBao taobao(&amp;price); taobao.sort(item, 4); printItem(item, 4); taobao.SetSortStrategy(&amp;sales); taobao.sort(item, 4); printItem(item, 4); return 0;&#125; source.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#ifndef SOURCE_H#define SOURCE_Hclass SortByPrice : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size) &#123; TaoBaoItem temp; for(int i = 0; i &lt; size; i++) &#123; for(int j = 0; j &lt; size - i - 1; j++) &#123; if(item[j].price &lt; item[j + 1].price) &#123; temp = item[j]; item[j] = item[j + 1]; item[j + 1] = temp; &#125; &#125; &#125; &#125;&#125;;class SortBySales : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size) &#123; TaoBaoItem temp; for(int i = 0; i &lt; size; i++) &#123; for(int j = 0; j &lt; size - i - 1; j++) &#123; if(item[j].volume_of_sales &lt; item[j + 1].volume_of_sales) &#123; temp = item[j]; item[j] = item[j + 1]; item[j + 1] = temp; &#125; &#125; &#125; &#125;&#125;;class TaoBao &#123; public: TaoBao(SortInterface* strategy) &#123; this-&gt;strategy_ = strategy; &#125; void SetSortStrategy(SortInterface* strategy) &#123; this-&gt;strategy_ = strategy; &#125; // Use current strategy_ to do the sort. void sort(TaoBaoItem item[], int size) &#123; this-&gt;strategy_-&gt;DoSort(item, size); &#125; private: SortInterface *strategy_;&#125;;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;numeric&gt;using namespace std;bool cmp1(TaoBaoItem&amp; a, TaoBaoItem&amp; b)&#123; return a.price &gt; b.price;&#125;bool cmp2(TaoBaoItem&amp; a, TaoBaoItem&amp; b)&#123; return a.volume_of_sales &gt; b.volume_of_sales;&#125;class SortByPrice : public SortInterface &#123;public: virtual void DoSort(TaoBaoItem item[], int size)&#123; sort(item, item + size, cmp1); &#125;&#125;; class SortBySales : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size)&#123; sort(item, item + size, cmp2); &#125;&#125;;class TaoBao &#123; public: TaoBao(SortInterface* strategy)&#123; strategy_ = strategy; &#125; void SetSortStrategy(SortInterface* strategy)&#123; strategy_ = strategy; &#125; // Use current strategy_ to do the sort. void sort(TaoBaoItem item[], int size)&#123; strategy_-&gt;DoSort(item, size); &#125; private: SortInterface *strategy_;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Product and Factory","slug":"程设/Product and Factory","date":"2022-05-14T08:06:34.096Z","updated":"2022-05-14T08:52:58.883Z","comments":true,"path":"2022/05/14/程设/Product and Factory/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/Product%20and%20Factory/","excerpt":"","text":"Description 在软件设计中，一个对象的创建可能没有它看上去那么容易。比如课程管理系统中，一个课程的创建依赖于许多业务逻辑。 某些情况下，将对象的创建和使用分离开来，是一个不错的选择，这让我们可以更优雅地组织代码，降低各模块的耦合性。 我们将使用 Product 和 Factory 的概念： 当客户端需要某个 Product 时，并不直接拿到它，而是通过一个 Factory 拿到 只有 Factory 关心如何创建这个 Product，而客户端无需关心 客户端拿到 Product，即可使用它支持的各种方法 依次阅读 Hint 中给出的三个链接，理解这三种模式和它们之间的关系，理解“产品等级结构”、“产品族”。 根据给出的信息，应用“抽象工厂模式”，完成该程序。 Sample Input 1 10 Sample Output 1 12Apple Laptop compiles a cpp program.Apple MobilePhone sends a short message. Sample Input 2 11 Sample Output 2 12Xiaomi Laptop compiles a cpp program.Xiaomi MobilePhone sends a short message. Hint 关键知识点：抽象类（接口继承）、多态 Laptop 可以 compileCppProgram，MobilePhone 可以 sendShortMessage 想要 AppleLaptop 或 AppleMobilePhone，去找 AppleFactory 想要 XiaomiLaptop 或 XiaomiMobilePhone，去找 XiaomiFactory 简单工厂模式 工厂方法模式 抽象工厂模式 Client.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &quot;Product.hpp&quot;#include &quot;Factory.hpp&quot;using std::cin;void test() &#123; Factory* factory = NULL; int choose; cin &gt;&gt; choose; switch (choose) &#123; case 0: factory = new AppleFactory(); break; case 1: default: factory = new XiaomiFactory(); break; &#125; Laptop* laptop = factory-&gt;produceLaptop(); MobilePhone* phone = factory-&gt;produceMobilePhone(); laptop-&gt;compileCppProgram(); phone-&gt;sendShortMessage(); delete laptop; delete phone; delete factory;&#125;int main() &#123; test(); return 0;&#125; Factory.hpp 12345678910111213141516171819202122232425#ifndef FACTORY_HPP_#define FACTORY_HPP_#include &quot;Product.hpp&quot;class Factory &#123;public: virtual Laptop* produceLaptop() = 0; virtual MobilePhone* produceMobilePhone() = 0; virtual ~Factory() &#123;&#125;&#125;;class AppleFactory : public Factory &#123;public: Laptop* produceLaptop() &#123; return new AppleLaptop(); &#125; MobilePhone* produceMobilePhone() &#123; return new AppleMobilePhone(); &#125;&#125;;class XiaomiFactory : public Factory &#123;public: Laptop* produceLaptop() &#123; return new XiaomiLaptop(); &#125; MobilePhone* produceMobilePhone() &#123; return new XiaomiMobilePhone(); &#125;&#125;;#endif Product.hpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef PRODUCT_HPP_#define PRODUCT_HPP_#include &lt;iostream&gt;using std::cout;using std::endl;class Laptop &#123;public: virtual void compileCppProgram() = 0; virtual ~Laptop() &#123;&#125;&#125;;class AppleLaptop : public Laptop &#123;public: void compileCppProgram() &#123; cout &lt;&lt; &quot;Apple Laptop compiles a cpp program.&quot; &lt;&lt; endl; &#125;&#125;;class XiaomiLaptop : public Laptop &#123;public: void compileCppProgram() &#123; cout &lt;&lt; &quot;Xiaomi Laptop compiles a cpp program.&quot; &lt;&lt; endl; &#125;&#125;;class MobilePhone &#123;public: virtual void sendShortMessage() = 0; virtual ~MobilePhone() &#123;&#125;&#125;;class AppleMobilePhone : public MobilePhone &#123;public: void sendShortMessage() &#123; cout &lt;&lt; &quot;Apple MobilePhone sends a short message.&quot; &lt;&lt; endl; &#125;&#125;;class XiaomiMobilePhone : public MobilePhone &#123;public: void sendShortMessage() &#123; cout &lt;&lt; &quot;Xiaomi MobilePhone sends a short message.&quot; &lt;&lt; endl; &#125;&#125;;#endif","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"虚函数(virtual destructor)","slug":"程设/destructor","date":"2022-05-14T07:53:33.813Z","updated":"2022-05-14T08:02:02.350Z","comments":true,"path":"2022/05/14/程设/destructor/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/destructor/","excerpt":"","text":"Description 下面是不完整的继承类定义： 1234567891011121314class A &#123;public: virtual void Prin() &#123; cout&lt;&lt;&quot;Prin come form class A&quot;&lt;&lt;endl; &#125;&#125;;class B &#123; char *buf;public: void Prin() &#123; cout&lt;&lt;&quot;Prin come from class B&quot;&lt;&lt;endl; &#125;&#125;; 试完成其定义（你可以根据需要增加必要的构造函数、析构函数），使得主函数main运行后能得到预期结果。 123456789101112void fun(A *a) &#123; delete a;&#125;int main() &#123; A *a = new B(10); a-&gt;Prin(); fun(a); B *b = new B(20); fun(b); return 0;&#125; Sample Output 12345Prin come from class BB::~B()calledA::~A()calledB::~B()calledA::~A()called Hint Virtual destructor! Only need to submit class A and B. Please check your spelling carefully. source.cpp 123456789101112131415161718192021222324#include &lt;iostream&gt;class A &#123;public: virtual void Prin() &#123; std::cout &lt;&lt; &quot;Prin come form class A&quot; &lt;&lt; std::endl; &#125; virtual ~A() &#123; std::cout &lt;&lt; &quot;A::~A()called&quot; &lt;&lt; std::endl; &#125;&#125;;class B: public A &#123;private: char *buf;public: B(int)&#123;&#125; void Prin() &#123; std::cout &lt;&lt; &quot;Prin come from class B&quot; &lt;&lt; std::endl; &#125; virtual ~B() &#123; std::cout &lt;&lt; &quot;B::~B()called&quot; &lt;&lt; std::endl; &#125;&#125;; framework.cpp(lock) 1234567891011121314151617#include &lt;iostream&gt;using namespace std;#include &quot;source.cpp&quot;void fun(A *a) &#123; delete a;&#125;int main() &#123; A *a = new B(10); a-&gt;Prin(); fun(a); B *b = new B(20); fun(b); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"polymorphism多态(一个接口，多种方法)","slug":"程设/vitual class(多态)","date":"2022-05-08T08:30:04.373Z","updated":"2022-05-08T08:39:39.587Z","comments":true,"path":"2022/05/08/程设/vitual class(多态)/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/vitual%20class(%E5%A4%9A%E6%80%81)/","excerpt":"","text":"Description There are 4 classes, Figure is the base class, both Triangle, Rectangle and Circle are all inherited from it. Figure class is like following: 1234567class FIGURE &#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()被声明为纯虚函数protected: double x_size, y_size;&#125;; You should implement Figure, Triangle, Rectange, Circle class. Sample Output 123Area of triangle is 60Area of rectangle is 120Area of circle is 706.858 Figure.h(lock) 123456789101112131415#ifndef FIGURE_H#define FIGURE_Hconst double PI = 3.14159; // 圆周率常量class FIGURE&#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()被声明为纯虚函数protected: double x_size, y_size;&#125;;#endif main.cpp(lock) 123456789101112131415161718192021222324252627#include &quot;Figure.h&quot;#include &quot;Triangle.h&quot;#include &quot;Rectangel.h&quot;#include &quot;Circle.h&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; TRIANGLE triangle; RECTANGLE rectangle; CIRCLE circle; // 处理三角形 triangle.set_size(15, 8); // 设置三角形的底和高 cout &lt;&lt; &quot;Area of triangle is &quot; &lt;&lt; triangle.get_area() &lt;&lt; &quot;\\n&quot;; // 处理矩形 rectangle.set_size(15, 8); // 设置矩形的长和宽 cout &lt;&lt; &quot;Area of rectangle is &quot; &lt;&lt; rectangle.get_area() &lt;&lt; &quot;\\n&quot;; // 处理圆 circle.set_size(15); // 设置圆的半径 cout &lt;&lt; &quot;Area of circle is &quot; &lt;&lt; circle.get_area() &lt;&lt; &quot;\\n&quot;; return 0;&#125; Figure.cpp 12345678910111213#include&quot;Figure.h&quot;using namespace std; double FIGURE::get_area()&#123;&#125;void FIGURE::set_size(double x, double y)&#123; x_size = x; y_size = y;&#125; Triangle.h 123456789101112#include&quot;Figure.h&quot;class TRIANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size / 2; &#125;&#125;; Rectangle.h 123456789101112#include&quot;Figure.h&quot;class RECTANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size ; &#125;&#125;; Circle.h 123456789101112#include&quot;Figure.h&quot;class CIRCLE:public FIGURE&#123;public:void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * x_size * PI; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Complex class(重载、格式控制)","slug":"程设/simple complex class","date":"2022-05-08T08:07:51.421Z","updated":"2022-05-08T08:07:51.421Z","comments":true,"path":"2022/05/08/程设/simple complex class/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/simple%20complex%20class/","excerpt":"","text":"Description You need to define a class named complex which has private two members, one is real which represents the real part of the complex, and another is imag which represents the imaginary part of the complex, both of them are integer; The class has some member functions: 1234void display() const;//print the complex with this form like 3 + 4i, if the real part and the imaginary part both are 0, you need to print 0;double getModuli() const;//like the function&#x27;s name, you need to return the moduli of the complex; What's more, you need to finish two friend function, overload \"+\" and \"-\", the rule follow the rules of the complex. Sample Input 120 -35 2 Sample Output 12345-3i5+2i5.09902 7.071075-1i-5-5i complex.hpp(lock) 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;class complex&#123; public: complex(int a, int b); complex operator=(complex&amp; other); complex operator+(complex&amp; other); complex operator-(complex&amp; other); void display() const; double getModuli() const; private: int real; int imag;&#125;; main.cpp(lock) 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;complex.hpp&quot;using namespace std;int main() &#123; int real, imag; cin &gt;&gt; real &gt;&gt; imag; complex a(real, imag); a.display(); cout &lt;&lt; endl; cin &gt;&gt; real &gt;&gt; imag; complex b(real, imag); b.display(); cout &lt;&lt; endl; complex c = a + b; complex d = a - b; cout &lt;&lt; c.getModuli() &lt;&lt; &quot; &quot; &lt;&lt; d.getModuli() &lt;&lt; endl; c.display(); cout &lt;&lt; endl; d.display();&#125; complex.cpp 1234567891011121314151617181920212223242526272829303132#include&quot;complex.hpp&quot;complex::complex(int a, int b)&#123; real = a; imag = b;&#125;complex complex::operator=(complex&amp; other)&#123; this-&gt;real = other.real; this-&gt;imag = other.imag; return *this;&#125;complex complex::operator+(complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real + other.real; temp.imag = this-&gt;imag + other.imag; return temp;&#125;complex complex::operator - (complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real - other.real; temp.imag = this-&gt;imag - other.imag; return temp;&#125;void complex::display() const&#123; if(!real &amp;&amp; !imag ) cout &lt;&lt; 0 &lt;&lt; endl; else if(!real) cout &lt;&lt; noshowpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; else if( !imag) cout&lt;&lt; noshowpos&lt;&lt; real; else cout &lt;&lt; noshowpos&lt;&lt; real &lt;&lt;showpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; cout &lt;&lt; noshowpos;&#125;double complex::getModuli() const&#123; return sqrt(real * real + imag * imag);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"point class 3（继承）","slug":"程设/point class3(继承)","date":"2022-05-08T08:07:01.347Z","updated":"2022-05-08T08:09:36.905Z","comments":true,"path":"2022/05/08/程设/point class3(继承)/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/point%20class3(%E7%BB%A7%E6%89%BF)/","excerpt":"","text":"题目描述 在先前Point Class 2的题目中，使用的方法是用三维的ThreeDPoint继承二维的TwoDPoint，我们可以发现，将二维点作为基类其实是不具有继承意义的。 为了实现一个具有真实继承意义的Point基类，我们在基类Point中让点的维度作为一个变量存在，这样多维度的点我们只需要继承基类就可以得到了，同时避免了Distance方法的重写。 请在 derivedPoint.h、derivedPoint.cpp、point.cpp中分别完成类的声明和定义。 Hint 请根据main.cpp和point.h的内容完成代码编写 在getDistance方法中，如果两个点维度不同，那么返回-1 出现额外方法： getAbsSlope为获取斜率的绝对值，如果斜率无穷则返回-1 isOnAxis为判断点是否在坐标轴上，是返回true，否则返回false point.h 123456789101112131415161718192021#ifndef POINT_H#define POINT_H#include &lt;iostream&gt;using namespace std;class Point&#123; private: int *coordinate; // 记录坐标的数组 int dim; // 维度 public: Point(int dim); // 初始化为原点坐标 Point(int dim, int *coordinate); int getDimension(); int getByIndex(int); double getDistance(Point&amp; another); virtual ~Point();&#125;;#endif main.cpp(lock) 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &quot;point.h&quot;#include &quot;derivedPoint.h&quot;int main() &#123; int point1[2], point2[2]; int point[3]; cin &gt;&gt; point1[0] &gt;&gt; point1[1]; cin &gt;&gt; point2[0] &gt;&gt; point2[1]; cin &gt;&gt; point[0] &gt;&gt; point[1] &gt;&gt; point[2]; TwoDPoint p1(point1), p2(point2); cout &lt;&lt; &quot;Distance between p1 and p2 is &quot; &lt;&lt; p1.getDistance(p2) &lt;&lt; endl; cout &lt;&lt; &quot;The absolute slope of the line through p1 and p2 is &quot; &lt;&lt; p1.getAbsSlope(p2) &lt;&lt; endl; cout &lt;&lt; &quot;X = &quot; &lt;&lt; p2.getX() &lt;&lt; endl; cout &lt;&lt; &quot;Y = &quot; &lt;&lt; p2.getY() &lt;&lt; endl; ThreeDPoint p(point); cout &lt;&lt; &quot;Distance between p1 and p is &quot; &lt;&lt; p1.getDistance(p) &lt;&lt; endl; if(p.isOnAxis()) cout &lt;&lt; &quot;ThreeDPoint is on the axis.\\n&quot;; else cout &lt;&lt; &quot;ThreeDPoint is not on the axis.\\n&quot;; return 0;&#125; derived point.cpp 123456789101112131415161718192021222324#include&quot;point.h&quot;#include&lt;cmath&gt;class TwoDPoint:public Point&#123;public: TwoDPoint(int* p):Point(2, p)&#123;&#125; double getAbsSlope(TwoDPoint&amp; another)&#123; if(abs(this-&gt;getByIndex(0) - another.getByIndex(0) == 0) )return -1; return 1.0 * abs(this-&gt;getByIndex(1) - another.getByIndex(1)) / abs(this-&gt;getByIndex(0) - another.getByIndex(0)); &#125; int getX()&#123; return this-&gt;getByIndex(0); &#125; int getY()&#123; return this-&gt;getByIndex(1); &#125;&#125;;class ThreeDPoint:public Point&#123;public: ThreeDPoint(int* p):Point(3, p)&#123;&#125; bool isOnAxis()&#123; return !this-&gt;getByIndex(0) || !this-&gt;getByIndex(1) || !this-&gt;getByIndex(2); &#125;&#125;; point.cpp 123456789101112131415161718192021222324252627282930313233#include&quot;point.h&quot;#include&lt;math.h&gt;Point::Point(int newdim)&#123; dim = newdim; coordinate = new int[dim]; for(int i = 0; i &lt; dim; i++)&#123; coordinate[i] = 0; &#125;&#125;Point::Point(int newdim, int *newcoordinate)&#123; dim = newdim; coordinate = newcoordinate;&#125;int Point::getDimension()&#123; return dim;&#125;int Point::getByIndex(int ind)&#123; return coordinate[ind];&#125;double Point::getDistance(Point&amp; another)&#123; if(dim != another.dim) return -1; double s = 0.0; int dim1 = dim; while(dim1 &gt; 0)&#123; --dim1; s += (this-&gt;coordinate[dim1] - another.coordinate[dim1])*(this-&gt;coordinate[dim1] - another.coordinate[dim1]); &#125; //cout &lt;&lt; sqrt(s) &lt;&lt; endl; return sqrt(s);&#125;Point::~Point()&#123; //delete []coordinate;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"point class 2（继承）","slug":"程设/point class2(继承)","date":"2022-05-08T08:00:11.103Z","updated":"2022-05-08T08:04:05.431Z","comments":true,"path":"2022/05/08/程设/point class2(继承)/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/point%20class2(%E7%BB%A7%E6%89%BF)/","excerpt":"","text":"Description Recall the \"Point\" class before, we want to create TwoDPoint class to model a point in a two-dimensional space.(Default value (0,0), int). It has functions to get its coordinates getX(), getY() and a member function to calculate the distance between it and another TwoDPoint distance(return type double). Based on TwoDPoint, create a class named ThreeDPoint to model a point in a three-dimensional space.x, y, z represent x-, y- and z-coordinates(Default value (0,0,0), int).Let ThreeDPoint be derived from TwoDPoint, adding function getZ() and overload the member functiondistance. Hint Get to know details in framework.cpp and try to separate declaration and definition in Points.h and Points.cpp . framwork.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;Points.h&quot;using namespace std;ostream&amp; operator&lt;&lt;(ostream&amp; out, const TwoDPoint&amp; point)&#123; out &lt;&lt; &#x27;(&#x27; &lt;&lt; point.getX() &lt;&lt; &#x27;,&#x27; &lt;&lt; point.getY() &lt;&lt; &#x27;)&#x27;; return out;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, const ThreeDPoint&amp; point)&#123; out &lt;&lt; &#x27;(&#x27; &lt;&lt; point.getX() &lt;&lt; &#x27;,&#x27; &lt;&lt; point.getY() &lt;&lt; &#x27;,&#x27; &lt;&lt; point.getZ() &lt;&lt; &#x27;)&#x27;; return out;&#125;int main()&#123; //2-D Point TwoDPoint pa1, pa; int pa2_x, pa2_y; cin &gt;&gt; pa2_x &gt;&gt; pa2_y; TwoDPoint pa2(pa2_x,pa2_y); cout &lt;&lt; &quot;Distance between &quot; &lt;&lt; pa1 &lt;&lt; &quot; and &quot; &lt;&lt; pa2 &lt;&lt;&quot; is &quot;&lt;&lt;pa1.distance(pa2) &lt;&lt; endl; //3-D Point ThreeDPoint pb1; int pb2_x, pb2_y, pb2_z, pb3_x, pb3_y, pb3_z; cin &gt;&gt; pb2_x &gt;&gt; pb2_y &gt;&gt; pb2_z; cin &gt;&gt; pb3_x &gt;&gt; pb3_y &gt;&gt; pb3_z; ThreeDPoint pb2(pb2_x, pb2_y, pb2_z), pb3(pb3_x, pb3_y, pb3_z); cout &lt;&lt; &quot;Distance between &quot; &lt;&lt; pb1 &lt;&lt; &quot; and &quot; &lt;&lt; pb2 &lt;&lt;&quot; is &quot;&lt;&lt;pb1.distance(pb2) &lt;&lt; endl; cout &lt;&lt; &quot;Distance between &quot; &lt;&lt; pb1 &lt;&lt; &quot; and &quot; &lt;&lt; pb3 &lt;&lt;&quot; is &quot;&lt;&lt;pb1.distance(pb3) &lt;&lt; endl; return 0;&#125; points.hpp 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;cmath&gt;using namespace std;class TwoDPoint&#123;protected: int x, y;public: TwoDPoint(int xx = 0, int yy = 0):x(xx), y(yy)&#123;&#125; int getX() const&#123;return x;&#125; int getY() const&#123;return y;&#125; double distance(const TwoDPoint&amp; other)&#123; return sqrt( 1.0 * (x + other.getX()) * (x + other.getX()) + 1.0 * (y + other.getY()) * (y + other.getY())); &#125;&#125;;class ThreeDPoint:public TwoDPoint&#123; int z;public: ThreeDPoint(int xx = 0, int yy = 0, int zz = 0):TwoDPoint(xx, yy), z(zz)&#123;&#125; int getZ() const&#123; return z; &#125; double distance(const ThreeDPoint&amp; other)&#123; return sqrt( 1.0 * (x + other.getX()) * (x + other.getX()) + 1.0 * (y + other.getY()) * (y + other.getY()) + 1.0 * (z + other.getZ()) * (z + other.getZ())); &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Complex class(重载、格式控制)","slug":"程设/simple complex class(复习)","date":"2022-05-08T07:44:24.227Z","updated":"2022-05-08T07:48:48.925Z","comments":true,"path":"2022/05/08/程设/simple complex class(复习)/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/simple%20complex%20class(%E5%A4%8D%E4%B9%A0)/","excerpt":"","text":"Description You need to define a class named complex which has private two members, one is real which represents the real part of the complex, and another is imag which represents the imaginary part of the complex, both of them are integer; The class has some member functions: 1234void display() const;//print the complex with this form like 3 + 4i, if the real part and the imaginary part both are 0, you need to print 0;double getModuli() const;//like the function&#x27;s name, you need to return the moduli of the complex; What's more, you need to finish two friend function, overload \"+\" and \"-\", the rule follow the rules of the complex. Sample Input 120 -35 2 Sample Output 12345-3i5+2i5.09902 7.071075-1i-5-5i complex.hpp(lock) 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;class complex&#123; public: complex(int a, int b); complex operator=(complex&amp; other); complex operator+(complex&amp; other); complex operator-(complex&amp; other); void display() const; double getModuli() const; private: int real; int imag;&#125;; main.cpp(lock) 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;complex.hpp&quot;using namespace std;int main() &#123; int real, imag; cin &gt;&gt; real &gt;&gt; imag; complex a(real, imag); a.display(); cout &lt;&lt; endl; cin &gt;&gt; real &gt;&gt; imag; complex b(real, imag); b.display(); cout &lt;&lt; endl; complex c = a + b; complex d = a - b; cout &lt;&lt; c.getModuli() &lt;&lt; &quot; &quot; &lt;&lt; d.getModuli() &lt;&lt; endl; c.display(); cout &lt;&lt; endl; d.display();&#125; complex.cpp 1234567891011121314151617181920212223242526272829303132#include&quot;complex.hpp&quot;complex::complex(int a, int b)&#123; real = a; imag = b;&#125;complex complex::operator=(complex&amp; other)&#123; this-&gt;real = other.real; this-&gt;imag = other.imag; return *this;&#125;complex complex::operator+(complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real + other.real; temp.imag = this-&gt;imag + other.imag; return temp;&#125;complex complex::operator - (complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real - other.real; temp.imag = this-&gt;imag - other.imag; return temp;&#125;void complex::display() const&#123; if(!real &amp;&amp; !imag ) cout &lt;&lt; 0 &lt;&lt; endl; else if(!real) cout &lt;&lt; noshowpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; else if( !imag) cout&lt;&lt; noshowpos&lt;&lt; real; else cout &lt;&lt; noshowpos&lt;&lt; real &lt;&lt;showpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; cout &lt;&lt; noshowpos;&#125;double complex::getModuli() const&#123; return sqrt(real * real + imag * imag);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(二十五)--static function","slug":"程设/static member","date":"2022-05-08T07:13:58.769Z","updated":"2022-05-08T07:27:12.881Z","comments":true,"path":"2022/05/08/程设/static member/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/static%20member/","excerpt":"","text":"Description 完成类Int，可以加入你觉得需要的member value or function. 123456class Int&#123; int data;public: Int(int n); //将n的值赋给data&#125;; 使得函数f()输出为 12345678910111213141516num 1 is odd? 1num 2 is odd? 01 objects of Int has been constructed.2 objects of Int has been constructed.3 objects of Int has been constructed.2 objects of Int has been constructed.void f()&#123; int i1=1, i2=2; cout &lt;&lt; &quot;num &quot; &lt;&lt; i1 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(1) &lt;&lt; endl; cout &lt;&lt; &quot;num &quot; &lt;&lt; i2 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(2) &lt;&lt; endl; Int ii1; &#123; Int ii1(i1); &#125; Int ii2(i2);&#125; framework.cpp 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;#include&quot;1001.cpp&quot;int Int::num=0;void f()&#123; int i1=1, i2=2; cout &lt;&lt; &quot;num &quot; &lt;&lt; i1 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(1) &lt;&lt; endl; cout &lt;&lt; &quot;num &quot; &lt;&lt; i2 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(2) &lt;&lt; endl; Int ii1; &#123; Int ii1(i1); Int ii2; &#125; Int ii2(i2);&#125;int main()&#123; f(); return 0;&#125; answer.cpp 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class Int&#123; int data; static int num;public: Int(int n):data(n)&#123; num++; cout &lt;&lt; num &lt;&lt; &quot; objects of Int has been constructed.&quot; &lt;&lt; endl; &#125; Int()&#123; num++; cout &lt;&lt; num &lt;&lt; &quot; objects of Int has been constructed.&quot; &lt;&lt; endl; &#125;; ~Int()&#123; num--; &#125; static int isodd(int n)&#123; return n % 2; &#125;&#125;; 几个点 12cout &lt;&lt; &quot;num &quot; &lt;&lt; i1 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(1) &lt;&lt; endl;cout &lt;&lt; &quot;num &quot; &lt;&lt; i2 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(2) &lt;&lt; endl; 123static int isodd(int n)&#123; return n % 2;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"期中考卷分析","slug":"数字电路汇总/期中考卷总结","date":"2022-04-25T08:34:12.724Z","updated":"2022-04-25T11:52:10.470Z","comments":true,"path":"2022/04/25/数字电路汇总/期中考卷总结/","link":"","permalink":"http://example.com/2022/04/25/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%9C%9F%E4%B8%AD%E8%80%83%E5%8D%B7%E6%80%BB%E7%BB%93/","excerpt":"","text":"填空题 实现逻辑门电路的两种主要半导体技术: TTL和COMS IC包括固定功能和可编程两大类,后者按结构和复杂度可细分为两大类:(PLD)和(FPGA) 8位有符号数,-85的反码和补码 74HC00字段含义,HC和00的含义 与非运算表示\\(AB+CD\\),或非运算表示\\((A+B)(C+D)\\) 芯片功能定义,数据选择器,编码器 常用D触发器和JK触发器的触发方式有两种,电平触发,边沿触发 生成单个或周期脉冲的电路分别为,单稳态触发器,多谐振荡器 根据图,看计数序列的模,和计数方式(或方向) 看图,集成电路的两种封装方式,DIP,小什么的封装 选择题 二进制表示53个数需要多少位,至少需要6位 或运算,可以通过两个或非门或三个与非门 -36的补码表示形式 数据选择器,三个地址数据输入端,最多有几个数据信号输入,8个 组合逻辑电路产生竞争冒险,是由于信号的延迟 异或门当作反相器时,输入端A和B引脚的接法是,A或B中有一个要接1 在不影响逻辑功能的情况下,COMS与非门的多余输入端可以接高电平 输出位低电平有效的16选1译码器,13对应的引脚出现一个低电平,求译码器输入是什么,1101 16进制-二进制优先编码器 一位全加器有什么特性,三个输入两个输出 判断题 脉冲可能考宽度,下降时间,占空比 补码表示形式的取值范围 所有数字电路可以用与或非逻辑电路出现 脉冲上升时间的定义 二进制减法可以取补码做加法进行 无效码可以在卡诺图作为无关项出现 逻辑与和布尔乘法等价 模二加法时,1+1=1 半加器包括两个输入位和一个进位输入位,产生一个和的输出位和一个进位输出位 6和3都是有效输出,高电平有效BCD编码器会输出0110 奇偶校验器级联,可将上一位的偶数输出位接下一位的任意输入位(错误) 逻辑函数化简题 卡诺图化简为sop表达式 \\[ A\\bar{B}CD+\\bar{B}\\bar{C}D+(A+C)B\\bar{D} \\] 组合逻辑电路分析 考了全加器的内部结构,最后要说明电路的逻辑功能 设计半加半减器 74HC151三输入(选择),8个数据输入,一个输出,实现四输入的逻辑表达式 实现多数表决电路","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"程设记录--matrix(运算练习)","slug":"程设/matrix练习","date":"2022-04-19T16:20:08.292Z","updated":"2022-04-19T16:21:47.250Z","comments":true,"path":"2022/04/20/程设/matrix练习/","link":"","permalink":"http://example.com/2022/04/20/%E7%A8%8B%E8%AE%BE/matrix%E7%BB%83%E4%B9%A0/","excerpt":"","text":"Description Task 完善 Matrix 类的定义，实现简单的Matrix运算，类的定义，main函数已给出，你需要编写Matrix.cpp文件实现具体函数，记得包含类的定义。 Input m n represent the row and col of matrix a and b(They have the same shape) For next m rows, input the elements in matrix a For next m+1~2m rows, input the elements in matrix b Output Print Matrix a, b Print Matrix a+b Print Matrix d(The transpose of a) Sample Input 1 123452 31 2 31 2 31 2 31 2 3 Sample Output 1 12345678910111213141516Matrix a:1 2 31 2 3Matrix b:1 2 31 2 3Matrix c = Matrix a + Matrix b :2 4 62 4 6Matrix a transpose to Matrix d:1 12 23 3 Sample Input 2 123452 21 23 44 32 1 Sample Ouput 2 123456789101112131415Matrix a:1 23 4Matrix b:4 32 1Matrix c = Matrix a + Matrix b :5 55 5Matrix a transpose to Matrix d:1 32 4 Hint 类的构造函数与析构函数，运算符重载，new与delete main.cpp(lock) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&quot;Matrix.h&quot;using namespace std;int main()&#123; int row, col; cout &lt;&lt; &quot;input the row and the col for Matrix a, b&quot; &lt;&lt; endl; cin &gt;&gt; row &gt;&gt; col; int **mat_a_arr = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; mat_a_arr[i] = new int[col]; for (int j = 0; j &lt; col; j++) &#123; cin &gt;&gt; mat_a_arr[i][j]; &#125; &#125; int **mat_b_arr = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; mat_b_arr[i] = new int[col]; for (int j = 0; j &lt; col; j++) &#123; cin &gt;&gt; mat_b_arr[i][j]; &#125; &#125; Matrix a(row, col, mat_a_arr), b(row, col, mat_b_arr), c(a), d; cout &lt;&lt; endl &lt;&lt; &quot;Matrix a:&quot; &lt;&lt; endl; a.display(); cout &lt;&lt; endl &lt;&lt; &quot;Matrix b:&quot; &lt;&lt; endl; b.display(); c = a + b;//用重载运算符“+”实现两个矩阵相加 cout &lt;&lt; endl &lt;&lt; &quot;Matrix c = Matrix a + Matrix b :&quot; &lt;&lt; endl; c.display(); cout &lt;&lt; endl &lt;&lt; &quot;Matrix a transpose to Matrix d:&quot; &lt;&lt; endl; d = a.transpose(); d.display(); for (int i = 0; i &lt; row; i++) &#123; delete[]mat_a_arr[i]; &#125; delete[]mat_a_arr; for (int i = 0; i &lt; row; i++) &#123; delete[]mat_b_arr[i]; &#125; delete[]mat_b_arr; return 0;&#125; matrix.h 123456789101112131415161718192021#ifndef MATRIX_H#define MATRIX_Hclass Matrix&#123;public: Matrix(); //默认构造函数 ~Matrix(); //析构函数 Matrix(const Matrix &amp;); //拷贝构造函数 Matrix(int row, int col, int** elements); //普通构造函数 Matrix operator+(const Matrix &amp;)const; //重载运算符“+” Matrix operator=(const Matrix &amp;); //重载运算符“=” Matrix transpose()const; //矩阵的转置 void display()const; //输出数据函数 private: int row; //矩阵的行 int col; //矩阵的列 int** mat; //用于储存矩阵&#125;;#endif matrix.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstring&gt;#include&lt;iostream&gt;#include&quot;Matrix.h&quot;using namespace std;Matrix::Matrix()&#123; mat = NULL;&#125; //构造函数Matrix::~Matrix()&#123; int i; for(i = 0; i &lt; row; i++)&#123; delete[] mat[i]; &#125; delete [] mat;&#125; //析构函数Matrix::Matrix(const Matrix &amp; other)&#123; row = other.row; col = other.col; mat = new int*[row]; int i; for(i = 0; i &lt; row; i++)&#123; mat[i] = new int[col + 1]; memcpy(mat[i], other.mat[i], col); &#125;&#125; //拷贝构造函数Matrix::Matrix(int row, int col, int** elements)&#123; this-&gt;row = row; this-&gt;col = col; mat = new int*[row]; int j, i; for(i = 0; i &lt; row; i++)&#123; mat[i] = new int[col]; for(j = 0; j &lt; col; j++)&#123; mat[i][j] = elements[i][j]; &#125; &#125;&#125; //默认构造函数 Matrix Matrix::operator+(const Matrix &amp; other)const&#123; Matrix temp; temp.row = this-&gt;row; temp.col = this-&gt;col; temp.mat = new int*[row]; int i, j; for(i = 0; i &lt; row; i++)&#123; temp.mat[i] = new int[col]; for(j = 0; j &lt; col; j++)&#123; temp.mat[i][j] = this-&gt;mat[i][j] + other.mat[i][j]; &#125; &#125; return temp;&#125; //重载运算符“+”Matrix Matrix::operator=(const Matrix &amp; other)&#123; if(this-&gt; mat != NULL)&#123; int i; for(i = 0; i &lt; row; i++)&#123; delete[] mat[i]; &#125; delete [] mat; &#125; this-&gt; row = other.row; this-&gt; col = other.col; this-&gt; mat = new int*[row]; int i, j; for(i = 0; i &lt; row; i++)&#123; this-&gt;mat[i] = new int[col]; for(j = 0; j &lt; col; j++)&#123; this-&gt;mat[i][j] = other.mat[i][j]; //cout &lt;&lt; other.mat[i][j] &lt;&lt; &#x27; &#x27;; &#125; &#125; return *this;&#125; //重载运算符“=”Matrix Matrix::transpose()const&#123; Matrix temp; temp.row = this-&gt;col; temp.col = this-&gt;row; temp.mat = new int*[col]; int i, j; for(i = 0; i &lt; temp.row; i++)&#123; temp.mat[i] = new int[row]; for(j = 0; j &lt; temp.col; j++)&#123; temp.mat[i][j] = this-&gt;mat[j][i]; &#125; &#125; return temp;&#125; //矩阵的转置void Matrix::display()const&#123; int i, j; for(i = 0; i &lt; row; i++)&#123; for(j = 0; j &lt; col - 1; j++)&#123; cout &lt;&lt; this-&gt;mat[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; this-&gt;mat[i][j] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录--[Static Member] Seminar Logger2","slug":"程设/static member2","date":"2022-04-19T11:36:03.752Z","updated":"2022-04-19T12:04:10.967Z","comments":true,"path":"2022/04/19/程设/static member2/","link":"","permalink":"http://example.com/2022/04/19/%E7%A8%8B%E8%AE%BE/static%20member2/","excerpt":"","text":"Description SDCS will organize students to participate in the seminar。curr_ people off campus mysterious guests and organizers have confirmed their participation. Meanwhile, they have been waiting in the venue. There are student_ num students participated, and each student has to introduce himself. At the end of the event, the students will leave in the order of admission, and the guests and the organizer will leave after the final discussion. Use the Student class to record the students. Please complete the Student.cpp so as to make the program achieve the corresponding record results. SDCS将组织学生参加讨论会，已经有curr_people个校外神秘嘉宾以及举办方确定参与，同时他们已经在会场中等待。共有student_num个学生参加，每一个学生到场后都要进行一次自我介绍。活动结束后，学生按照入场的顺序依次退场，嘉宾以及举办方在最终商讨后最后离场。 用Student类来记录参加的学生，请完成Student.cpp文件的编写，使得程序能够达成对应的记录结果。 Sample Input In the first line, there are two numeric inputs, which are the number of organizers and guests (curr_ people), and the number of students in SDCS(student_ num). In next student_num lines, each line has two inputs. The first input is indicate the gender of the student: if the student is a boy, it will be 1, otherwise, it's 0. The second input is a string, which indicates the name of the student 第一行有两个数字输入，分别为举办方与嘉宾的数目curr_people，以及SDCS中学生的数量student_num。 此后的person_num行中，每行都有2个输入，第一个int输入表示参与者的性别，如果是男生则为1，否则为0；第二个string输入表示参与者的姓名。 123456787 71 Jack0 Lisa1 Jackson0 Rose0 Jisoo1 Jack0 Jennie Sample Output 12345678910111213Hi! My name is Jack. I have no classmates here.Hi! My name is Lisa. I have only 1 classmate here.Hi! My name is Jackson. I have 2 classmates here.Hi! My name is Rose. I have 3 classmates here.Hi! My name is Jisoo. I have 4 classmates here.Hi! My name is Jack. I have 5 classmates here.Hi! My name is Jennie. I have 6 classmates here.The number of people is 14. The number of students is 7. The number of girls is 4. The number of boys is 3.The number of people is 13. The number of students is 6. The number of girls is 4. The number of boys is 2.The number of people is 12. The number of students is 5. The number of girls is 3. The number of boys is 2.The number of people is 11. The number of students is 4. The number of girls is 3. The number of boys is 1.The number of people is 10. The number of students is 3. The number of girls is 2. main.cpp(lock) 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &quot;Student.h&quot;using namespace std;void clear()&#123; Student::person_num = 0; total();&#125;int main()&#123; int curr_people = 0, student_num = 0; cin &gt;&gt; curr_people &gt;&gt; student_num; Student* student_list[student_num]; Student::person_num += curr_people; for(int i = 0; i &lt; student_num; ++i)&#123; string name = &quot;&quot;; int isBoy = 0; cin &gt;&gt; isBoy &gt;&gt; name; student_list[i] = new Student(isBoy, name); student_list[i]-&gt;sayHi(); &#125; total(); // 学生退场 cout &lt;&lt; endl; for(int i = 0; i &lt; student_num; ++i)&#123; delete student_list[i]; total(); &#125; clear(); // 嘉宾以及举办方离场 return 0;&#125; student.h(lock) 12345678910111213141516171819202122#ifndef STUDENT_H#define STUDENT_H#include &lt;iostream&gt;using namespace std;class Student&#123; public: static int girl_num; static int boy_num; static int person_num; Student(int gender, string name); ~Student(); void sayHi(); private: string name; int gender;&#125;;void total();#endif student.cpp 12345678910111213141516171819202122232425262728293031323334int Student:: girl_num=0;int Student:: boy_num=0;int Student:: person_num=0;Student::Student(int g,string n):gender(g),name(n)&#123; if(g ==1)&#123; boy_num++; &#125;else&#123; girl_num++; &#125; person_num++;&#125;Student::~Student()&#123; if(gender ==1)&#123; boy_num--; &#125;else&#123; girl_num--; &#125; person_num--;&#125;void Student:: sayHi()&#123; cout&lt;&lt;&quot;Hi! My name is &quot;&lt;&lt;name&lt;&lt;&quot;. I have &quot;; if(boy_num+girl_num==2) cout&lt;&lt;&quot;only 1 classmate here.&quot;&lt;&lt;endl; if(boy_num+girl_num==1) cout&lt;&lt;&quot;no classmates here.&quot;&lt;&lt;endl; if(boy_num+girl_num&gt;2) cout&lt;&lt;boy_num+girl_num-1&lt;&lt;&quot; classmates here.&quot;&lt;&lt;endl;&#125;void total()&#123; if(Student::person_num==0) cout&lt;&lt;&quot;There is nobody here.&quot;&lt;&lt;endl; cout&lt;&lt;&quot;The number of people is &quot;&lt;&lt;Student::person_num&lt;&lt;&quot;. The number of students is &quot;&lt;&lt;Student::boy_num+Student::girl_num&lt;&lt;&quot;. The number of girls is &quot;&lt;&lt;Student::girl_num&lt;&lt;&quot;. The number of boys is &quot;&lt;&lt;Student::boy_num&lt;&lt;&quot;.&quot;&lt;&lt;endl;&#125; 注意 全局函数在使用静态变量时,需要在前面加一个Student:: 如何初始化静态变量 int student:: girl_num=0;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录--inservice(虚继承)","slug":"程设/inservice","date":"2022-04-16T10:53:12.353Z","updated":"2022-05-09T14:50:58.092Z","comments":true,"path":"2022/04/16/程设/inservice/","link":"","permalink":"http://example.com/2022/04/16/%E7%A8%8B%E8%AE%BE/inservice/","excerpt":"","text":"Description Please complete the following 4 classes: Person, Student, Worker, Inservice. Note: Person owns data member name and sex, the output format is (For more detail, see the sample output): 1234// you should add this ouput statement in the constructorcout &lt;&lt; &quot;Construct Person&quot; &lt;&lt; endl;// you should add this ouput statement in the destructorcout &lt;&lt; &quot;Destruct Person&quot; &lt;&lt; endl; Student is a derived class of Person, its data member is a string sno (学号), its constructor has to print Construct Student and its destructor has to print Destruct Student. Worker is a derived class of Person, its data member is a string wno (职员号), its constructor has to print Construct Worker and its destructor has to print Destruct Worker. Please think the relationship between InService and Student/Worker, and implement InService class by yourself. with its constructor prints Construct InService and its destructor prints Destruct InService. Sample Input 1234amblpo11315467110814061 Sample Output 12345678910111213141516Construct PersonConstruct StudentConstruct WorkerConstruct InServiceamblpo1amblpo113154671amblpo110814061Destruct InServiceDestruct WorkerDestruct StudentDestruct Person Hints 虚继承 main.cpp(lock) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &quot;inservice.h&quot;using namespace std; int main() &#123; string name, sno, wno; int sex; cin &gt;&gt; name; cin &gt;&gt; sex; cin &gt;&gt; sno; cin &gt;&gt; wno; InService is(name, sex, sno, wno); Person* p = &amp;is; Student* s = &amp;is; Worker* w = &amp;is; cout &lt;&lt; p-&gt;getName() &lt;&lt; endl; cout &lt;&lt; p-&gt;getSex() &lt;&lt; endl; cout &lt;&lt; s-&gt;getName() &lt;&lt; endl; cout &lt;&lt; s-&gt;getSex() &lt;&lt; endl; cout &lt;&lt; s-&gt;getSno() &lt;&lt; endl; cout &lt;&lt; w-&gt;getName() &lt;&lt; endl; cout &lt;&lt; w-&gt;getSex() &lt;&lt; endl; cout &lt;&lt; w-&gt;getWno() &lt;&lt; endl; return 0;&#125; inservice.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Person&#123; string name; int sex;public:Person(string n,int s):name(n),sex(s)&#123; cout &lt;&lt; &quot;Construct Person&quot; &lt;&lt; endl;&#125;string getName() &#123; return name;&#125;~Person()&#123; cout&lt;&lt; &quot;Destruct Person&quot; &lt;&lt;endl;&#125;int getSex() &#123; return sex;&#125;&#125;;class Student: virtual public Person&#123; string sno;public:Student(string n,int s,string o): Person(n,s),sno(o)&#123; cout &lt;&lt; &quot;Construct Student&quot; &lt;&lt; endl;&#125;string getSno() &#123; return sno;&#125;~Student()&#123; cout&lt;&lt; &quot;Destruct Student&quot; &lt;&lt; endl;&#125;&#125;;class Worker: virtual public Person&#123; string wno;public: Worker(string n,int s,string o):Person(n,s),wno(o)&#123; cout&lt;&lt; &quot;Construct Worker&quot; &lt;&lt;endl; &#125; string getWno() &#123; return wno; &#125; ~Worker()&#123; cout&lt;&lt; &quot;Destruct Worker&quot; &lt;&lt;endl; &#125;&#125;;class InService: public Student, public Worker&#123;public: InService(string n, int se, string sn, string wn):Person(n, se), Student(n, se, sn), Worker(n, se, wn)&#123; cout &lt;&lt; &quot;Construct InService&quot; &lt;&lt; endl; &#125; ~InService()&#123; cout&lt;&lt; &quot;Destruct InService&quot; &lt;&lt;endl; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录--matrix and vector","slug":"程设/matrix and vector","date":"2022-04-16T09:17:05.200Z","updated":"2022-04-19T11:37:13.800Z","comments":true,"path":"2022/04/16/程设/matrix and vector/","link":"","permalink":"http://example.com/2022/04/16/%E7%A8%8B%E8%AE%BE/matrix%20and%20vector/","excerpt":"","text":"Problem Description Matrix can be stored in a one-dimensional vector in a row-first way, inheriting from the Vector class. According to Vector.h and Matrix.h, complete the implementation of Vector class and Matrix class. Function description: Vector::getModule() gets the modulus length of the vector, Matrix::Symmetric() judges whether the matrix is a symmetric matrix. 矩阵可以以行优先的方式存储在一维向量中, 继承于Vector类。根据Vector.h和Matrix.h完成Vector类和Matrix类的实现。 函数说明：Vector::getModule()求得向量的模长， Matrix::Symmetric()判断矩阵是不是对称矩阵。 HINT 向量的模长就是向量的长度（或称模）。 输入 向量长度n 向量n个元素的值 矩阵行row 矩阵列col 矩阵元素 输出 向量模长 矩阵元素个数 矩阵是否为对称矩阵 [Sample Input1] 3 0 0 0 3 3 1 0 0 0 1 0 0 0 1 [Sample Output1] Vector Module: 0 Total Elements in Matrix: 9 Symmetric matrix: 1 [Sample Input2] 3 3 4 0 3 3 3 0 1 0 4 0 1 0 5 [Sample Output2] Vector Module: 5 Total Elements in Matrix: 9 Symmetric matrix: 1 framwork.cpp(lock) 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&quot;vector_matrix.h&quot;using namespace std;int main()&#123; int vector_dimension; cin &gt;&gt; vector_dimension; int* vector_elements = new int[vector_dimension]; for(int i=0;i&lt;vector_dimension;i++) cin &gt;&gt; vector_elements[i]; int row, col; cin &gt;&gt; row &gt;&gt; col; int* matrix_elements = new int[row*col]; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) cin &gt;&gt; matrix_elements[i*row+j]; &#125; Vector v(row,vector_elements); cout&lt;&lt;&quot;Vector Module: &quot;&lt;&lt;v.getModule()&lt;&lt;endl; Matrix m(row,col,matrix_elements); cout&lt;&lt; &quot;Total Elements in Matrix: &quot; &lt;&lt; m.getDimension()&lt;&lt;endl; cout&lt;&lt; &quot;Symmetric matrix: &quot;&lt;&lt;m.Symmetric()&lt;&lt;endl; return 0;&#125; vector_matrix.h(lock) 123456789101112131415161718192021222324252627#ifndef VECTOR_MATRIX_H#define VECTOR_MATRIX_H#include&lt;iostream&gt;using namespace std;class Vector&#123;public: Vector(); Vector(int dim, const int* elements_); ~Vector(); int getDimension() const; int *getElements() const; double getModule() const; //求向量的模长 private: int dimension; //向量的维度 int *elements; //存储向量元素的数组&#125;;class Matrix: public Vector&#123;public: Matrix(); Matrix(int row, int col, const int* elements_); //矩阵的行列以及矩阵元素（行优先方式存储在一维数组中） bool Symmetric() const; //判断是否为对称矩阵private: int row; //矩阵的行&#125;;#endif vector_matrix.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Vector:: Vector()&#123; dimension=0; elements=NULL;&#125;Vector:: Vector(int dim, const int* elements_)&#123; dimension=dim; elements=new int [dim]; for(int i=0;i&lt;dim;i++)&#123; elements[i]=elements_[i]; &#125;&#125;Vector:: ~Vector()&#123; if(elements!=NULL)&#123; delete [] elements; &#125;&#125; int Vector:: getDimension() const&#123; return dimension;&#125;int* Vector:: getElements() const&#123; return elements;&#125;double Vector:: getModule() const&#123; double sum=0; for(int i=0;i&lt;dimension;i++)&#123; sum+=elements[i]*elements[i]; &#125; sum= sqrt(sum); return sum;&#125;Matrix:: Matrix()&#123; row=0;&#125;Matrix:: Matrix(int row, int col, const int* elements_):Vector(row*col,elements_)&#123; this-&gt;row=row;&#125; //矩阵的行列以及矩阵元素（行优先方式存储在一维数组中）bool Matrix:: Symmetric() const&#123; int col=getDimension()/row; if(col!=row) return false; //int temp [row][col]; int **temp=new int* [row]; for(int i=0;i&lt;row;i++)&#123; temp[i]=new int [col]; &#125; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; temp[i][j]=getElements()[col*i+j]; &#125; &#125; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(temp[i][j]!=temp[j][i]) return false; &#125; &#125; for(int i=0;i&lt;row;i++)&#123; delete [] temp[i]; &#125; delete [] temp; return true;&#125; //判断是否为对称矩阵","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"set的使用","slug":"程设/set 的使用","date":"2022-04-12T07:29:07.770Z","updated":"2022-04-13T07:38:48.067Z","comments":true,"path":"2022/04/12/程设/set 的使用/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/set%20%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"C++ STL set容器完全攻略（超级详细） (biancheng.net) 1234567891011121314//头文件#include&lt;set&gt;using namespace std;//template &lt; class T, // 键 key 和值 value 的类型 class Compare = less&lt;T&gt;, // 指定 set 容器内部的排序规则 class Alloc = allocator&lt;T&gt; // 指定分配器对象的类型 &gt; class set;set&lt;int&gt; myset; 相关函数 1234567891011121314151617set&lt;int&gt; a;//向set中插入元素a.insert(1);a.insert(2);a.insert(2);//set中元素的个数a.size();//返回set容器的第一个元素的地址a.begin();//返回set容器的最后一个元素的地址a.end();//删除set容器中的所有元素a.clear();//判断set容器是否为空a.empty();//返回set容器中可能包含的元素的最大个数a.max_size(); 如何修改set里面的默认排序顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;/*set与list容器排序区别：list容器的排序是一个自带的sort成员函数，需要在sort中传一个函数名来指定排序规则；set是默认插入数据就自动排序的，所以需要在插数据之前用仿函数指定排序规则*//*************************************set容器内置数据类型排序***************************/void printfIntSet(set&lt;int&gt;&amp; s)//打印内置数据类型int数组的函数&#123; for (set&lt;int&gt;::iterator it = s.begin();it != s.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;/*仿函数*/class myCompare//int数组比较大小的类，也可称为数据类型&#123;public: bool operator()(int v1, int v2)//仿函数的返回值是bool类型，重载了() 运算符 &#123; return v1 &gt; v2; &#125;&#125;;void test01()//set容器内置数据类型排序&#123; set&lt;int&gt; s; s.insert(10); s.insert(100); s.insert(1); s.insert(5); s.insert(80); printfIntSet(s);//默认是从小到大 set&lt;int, myCompare&gt; s1;//在定义数组的时候指定排序规则 s1.insert(10); s1.insert(100); s1.insert(1); s1.insert(5); s1.insert(80); for (set&lt;int,myCompare&gt;::iterator it = s1.begin();it != s1.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;;//数据输出变成降序了 &#125;&#125;/*************************************set容器自定义数据类型排序***************************///自定义的数据类型插入set容器如果不指定排序规则，编译器不知道该怎么排序，所以必须指定排序规则class Person//自定义数据类型&#123;public: Person(string name, int age) &#123; this-&gt;m_name = name; this-&gt;m_age = age; &#125; string m_name; int m_age;&#125;;class Compare//指定排序规则的仿函数&#123;public: bool operator()(const Person &amp;p1, Person &amp;p2)//加const限定不能修改传入的数据 &#123; return p1.m_age &gt; p2.m_age;//降序 &#125;&#125;;void test02()//set容器自定义数据排序&#123; set&lt;Person,Compare&gt; s; Person p1(&quot;张三&quot;, 18); Person p2(&quot;李四&quot;, 20); Person p3(&quot;王五&quot;, 19); Person p4(&quot;赵六&quot;, 27); Person p5(&quot;王八&quot;, 15); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); s.insert(p5); for (set&lt;Person, Compare&gt;::iterator it = s.begin();it != s.end();it++) &#123; cout &lt;&lt; it-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125;&#125;int main()&#123; //test01();//内置数据类型排序 test02();//自定义数据类型排序 return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录--unique friend(map)","slug":"程设/unique friend","date":"2022-04-12T06:47:54.011Z","updated":"2022-04-19T11:36:58.230Z","comments":true,"path":"2022/04/12/程设/unique friend/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/unique%20friend/","excerpt":"","text":"Unique friend Given information about the friend of each person. Print friends that are unique to exactly one person ordered by their name. In the given friend list, each line starts with a person name, followed by the names of the friends of the person. There are 10 persons, and each person has 10 friends. In this problem, you need to write a class FriendsFinder3. Exmaple input Collins Smith Perez Allen Brown Carter Jackson Rodriguez Young Evans Lopez Wilson Martin Williams Hall Lee Thompson Baker Campbell Evans Brown King Jones Jackson Lee Martinez Williams Thomas Moore Carter Thompson Hernandez Lopez Turner Roberts Miller Robinson Taylor Anderson Rodriguez Hernandez Wright Adams Phillips Lewis Hall Young Garcia Jackson Lopez Williams Miller Taylor White Johnson Evans Allen Miller White Smith Parker Phillips Brown Carter Collins Mitchell Adams King Smith Davis Gonzalez Clark Miller Martin Jones Martinez Walker Scott Nelson Garcia Collins Anderson Hall Adams Walker Hill Allen Moore Baker Harris Collins Miller Mitchell Hill Lee Rodriguez Nelson Lewis Wilson Miller Anderson Hall Clark Evans Wright Young Lee Walker Allen Johnson Exmaple output Baker Campbell Davis Gonzalez Harris Jones Lewis Parker Perez Roberts Robinson Thomas Wilson Hint 输出仅为某一个人的朋友的人的名字，注意名字按字典序输出。 main.cpp(lock) 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;#include &quot;head.h&quot;int main() &#123; string persons[10]; // persons string friends[10][10]; // friends per person string name; // input persons and friends for (int i = 0; i &lt; 10; ++ i) &#123; // for each of the 10 person cin &gt;&gt; name; persons[i] = name; // input 10 friends per person for (int j = 0; j &lt; 10; ++ j) &#123; cin &gt;&gt; name; friends[i][j] = name; &#125; &#125; FriendsFinder3 ff(persons, friends); ff(); return 0;&#125; head.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;class FriendsFinder3&#123;private: string per[10]; string fri[10][10];public: FriendsFinder3(); FriendsFinder3( string a[10],string b[10][10])&#123; for(int i=0;i&lt;10;i++)&#123; per[i]=a[i]; &#125; for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++)&#123; fri[i][j]=b[i][j]; &#125; &#125; &#125; void operator()()&#123; map&lt; string, int &gt; p; for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++)&#123; p[ fri[i][j] ] +=1; &#125; &#125; map&lt;string,int&gt;::iterator it; for(it=p.begin();it!=p.end();it++)&#123; if(it-&gt;second==1) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;; &#125; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录--[Set & Map] Conference Room Manager","slug":"程设/[Set & Map] Conference Room Manager","date":"2022-04-12T06:30:26.161Z","updated":"2022-04-19T11:37:04.668Z","comments":true,"path":"2022/04/12/程设/[Set & Map] Conference Room Manager/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/[Set%20&%20Map]%20Conference%20Room%20Manager/","excerpt":"","text":"Description 学校里有2个会议室，1个小会议室和1个大会议室。按照规定，小会议室和大会议室每天各自只有1个租借名额。如果要租借小会议室，只需要提供租借的日期信息（int类型）即可；如果要租借大会议室，那么不仅要提供租借的日期信息（int类型），而且还要同时提供租借该会议室的缘由（string类型）。 会议室的租借过程是无监督的和先到先得的。“无监督” 意味着只要某天某个会议室还没有人租借，那么任何人都可以申请此会议室该日期的使用权；“先到先得” 意味着如果会议室某天的使用权已经被其它人租借了，那么后续对于同一天同一个会议室的租借申请都会失败，除非原来的拥有者主动取消了这一次租借。 请根据提示完成RoomManager类，实现该学校里1大1小2个会议室的租借管理。其中，RoomManager类应该包括如下的功能： set _room1：用于存储所有小会议室租借的【日期】信息。 map&lt;int, string&gt; _room2：用于存储所有大会议室租借的【日期，缘由】信息。 bool InsertAppointment(const int&amp; date)：尝试租借小会议室，如果租借成功返回true，否则返回false。 bool InsertAppointment(const int&amp; date, const string&amp; event)：尝试租借大会议室，如果租借成功返回true，否则返回false。 bool CancelAppointment(const int&amp; room_id, const int&amp; date)：取消会议室的某次租借。如果该会议室对应的日期确实已经有租借记录，则将其删除并返回true，否则返回false。 void PrintAppointments(const int&amp; room_id)：按照日期的升序打印某个会议室目前已有的所有租借记录。 Guiding RoomManager类的声明如下代码段所示。 12345678910111213141516171819202122232425262728293031class RoomManager &#123; private: // Conference Room 1, the smaller one. // Only require the date information for appointment. set&lt;int&gt; _room1; // Conference Room 2, the bigger one. // Require both date and event information for appointment. map&lt;int, string&gt; _room2; public: // Insert an appointment to the smaller Conference Room (1). bool InsertAppointment(const int&amp; date); // Insert an appointment to the bigger Conference Room (2). bool InsertAppointment(const int&amp; date, const string&amp; event); // Cancel an appointment on designated date. // If room_id == 1, cancel the corresponding appointment of _room1. // If room_id == 2, cancel the corresponding appointment of _room2. bool CancelAppointment(const int&amp; room_id, const int&amp; date); // Print all existing appointments in chronological order. // If room_id == 1, just print the date information. Each piece of information is separated by &#x27; &#x27;. // If room_id == 2, print the information in form of &quot;date(event)&quot;. Each piece of information is separated by &#x27; &#x27;. // If there is no even one existing appointment yet, print &quot;No Appointment&quot;. void PrintAppointments(const int&amp; room_id) const;&#125;; 请根据提示手动实现RoomManager类里声明的4个方法。 Sample Input 1 123456789101110InsertRoom1 20220601InsertRoom2 20220601 MeetingInsertRoom1 20220602InsertRoom2 20220602 Play LOLInsertRoom1 20220601InsertRoom2 20220601 Keep fit with exerciseCancelRoom2 20220602CancelRoom2 20220603PrintRoom1PrintRoom2 Sample Output 1 12345678910Succeed?: trueSucceed?: trueSucceed?: trueSucceed?: trueSucceed?: falseSucceed?: falseSucceed?: trueSucceed?: false20220601 2022060220220601(Meeting) Sample Input 2 1234567891011121314151615InsertRoom1 20220610CancelRoom2 20220610InsertRoom2 20220611 Academic researchCancelRoom1 20220611InsertRoom1 20220611InsertRoom2 20220610 Quantum reaction experimentPrintRoom1PrintRoom2InsertRoom2 20220611 Satellite launch testCancelRoom2 20220611InsertRoom2 20220611 Satellite launch testInsertRoom2 20220611 Geological surveyInsertRoom2 20220612 Geological surveyInsertRoom2 20220609 Czar nuclear power testPrintRoom2 Sample Output 2 123456789101112131415Succeed?: trueSucceed?: falseSucceed?: trueSucceed?: falseSucceed?: trueSucceed?: true20220610 2022061120220610(Quantum reaction experiment) 20220611(Academic research)Succeed?: falseSucceed?: trueSucceed?: trueSucceed?: falseSucceed?: trueSucceed?: true20220609(Czar nuclear power test) 20220610(Quantum reaction experiment) 20220611(Satellite launch test) 20220612(Geological survey) main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;manager.h&quot;int main() &#123; RoomManager manager; int num_operations; string operation; cin &gt;&gt; num_operations; // How many operations in total. cout &lt;&lt; endl; for(int i=1; i&lt;=num_operations; ++i) &#123; cin &gt;&gt; operation; if(operation == &quot;InsertRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date) &lt;&lt; endl; &#125; else if(operation == &quot;InsertRoom2&quot;) &#123; int date; string event; cin &gt;&gt; date; getline(cin, event); event.erase(0, 1); cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date, event) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(1, date) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom2&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(2, date) &lt;&lt; endl; &#125; else if(operation == &quot;PrintRoom1&quot;) &#123; manager.PrintAppointments(1); cout &lt;&lt; endl; &#125; else &#123; manager.PrintAppointments(2); cout &lt;&lt; endl; &#125; &#125; return 0;&#125; manager.h(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;manager.h&quot;int main() &#123; RoomManager manager; int num_operations; string operation; cin &gt;&gt; num_operations; // How many operations in total. cout &lt;&lt; endl; for(int i=1; i&lt;=num_operations; ++i) &#123; cin &gt;&gt; operation; if(operation == &quot;InsertRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date) &lt;&lt; endl; &#125; else if(operation == &quot;InsertRoom2&quot;) &#123; int date; string event; cin &gt;&gt; date; getline(cin, event); event.erase(0, 1); cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date, event) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(1, date) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom2&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(2, date) &lt;&lt; endl; &#125; else if(operation == &quot;PrintRoom1&quot;) &#123; manager.PrintAppointments(1); cout &lt;&lt; endl; &#125; else &#123; manager.PrintAppointments(2); cout &lt;&lt; endl; &#125; &#125; return 0;&#125; manager.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&quot;manager.h&quot;bool RoomManager::InsertAppointment(const int&amp; date)&#123; if(_room1.find(date) != _room1.end())&#123; return false; &#125; else&#123; _room1.insert(date); return true; &#125;&#125;// Insert an appointment to the bigger Conference Room (2).bool RoomManager::InsertAppointment(const int&amp; date, const string&amp; event)&#123; if(_room2.find(date) != _room2.end())&#123; return false; &#125; else&#123; _room2.insert(pair&lt;int,string&gt;(date, event)); return true; &#125;&#125;// Cancel an appointment on designated date.// If room_id == 1, cancel the corresponding appointment of _room1.// If room_id == 2, cancel the corresponding appointment of _room2.bool RoomManager::CancelAppointment(const int&amp; room_id, const int&amp; date)&#123; if(room_id == 1)&#123; set&lt;int&gt;::iterator it; it = _room1.find(date); if(it == _room1.end())&#123; return false; &#125; else&#123; _room1.erase(it); return true; &#125; &#125; else&#123; map&lt;int, string&gt;::iterator it; it = _room2.find(date); if(it == _room2.end())&#123; return false; &#125; else&#123; _room2.erase(it); return true; &#125; &#125;&#125;// Print all existing appointments in chronological order.// If room_id == 1, just print the date information. Each piece of information is separated by &#x27; &#x27;.// If room_id == 2, print the information in form of &quot;date(event)&quot;. Each piece of information is separated by &#x27; &#x27;.// If there is no even one existing appointment yet, print &quot;No Appointment&quot;.void RoomManager::PrintAppointments(const int&amp; room_id) const&#123; if(room_id == 1)&#123; set&lt;int&gt;::iterator it = _room1.begin(); while(it != _room1.end())&#123; cout &lt;&lt;*it&lt;&lt; &#x27; &#x27;; it++; &#125; cout &lt;&lt; endl; &#125; else&#123; map&lt;int, string&gt;::const_iterator it; it = _room2.begin(); while(it != _room2.end())&#123; cout &lt;&lt; it-&gt;first &lt;&lt; &#x27;(&#x27; &lt;&lt;it-&gt;second&lt;&lt; &#x27;)&#x27; &lt;&lt;&#x27; &#x27;; it++; &#125; cout &lt;&lt; endl; &#125;&#125; 参考答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &quot;manager.h&quot;// Implements.bool RoomManager::InsertAppointment(const int&amp; date) &#123; if(_room1.find(date) != _room1.end()) &#123; return false; &#125; else &#123; _room1.insert(date); return true; &#125;&#125;bool RoomManager::InsertAppointment(const int&amp; date, const string&amp; event) &#123; if(_room2.find(date) != _room2.end()) &#123; return false; &#125; else &#123; _room2[date] = event; return true; &#125;&#125;bool RoomManager::CancelAppointment(const int&amp; room_id, const int&amp; date) &#123; if(room_id == 1) &#123; set&lt;int&gt;::iterator sit = _room1.find(date); if(sit == _room1.end()) &#123; return false; &#125; else &#123; _room1.erase(sit); return true; &#125; &#125; else &#123; map&lt;int, string&gt;::iterator mit = _room2.find(date); if(mit == _room2.end()) &#123; return false; &#125; else &#123; _room2.erase(mit); return true; &#125; &#125;&#125;void RoomManager::PrintAppointments(const int&amp; room_id) const &#123; if(room_id == 1) &#123; if(_room1.empty()) &#123; cout &lt;&lt; &quot;No Appointment&quot;; &#125; else &#123; for(auto sit=_room1.begin(); sit!=_room1.end(); ++sit) &#123; cout &lt;&lt; *sit &lt;&lt; &#x27; &#x27;; &#125; &#125; &#125; else &#123; if(_room2.empty()) &#123; cout &lt;&lt; &quot;No Appointment&quot;; &#125; else &#123; for(auto mit=_room2.begin(); mit!=_room2.end(); ++mit) &#123; cout &lt;&lt; mit-&gt;first &lt;&lt; &#x27;(&#x27; &lt;&lt; mit-&gt;second &lt;&lt; &#x27;)&#x27; &lt;&lt; &#x27; &#x27;; &#125; &#125; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(二十一)--account and vip","slug":"程设/account","date":"2022-04-12T06:24:09.492Z","updated":"2022-04-12T06:27:47.082Z","comments":true,"path":"2022/04/12/程设/account/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/account/","excerpt":"","text":"Description Account 是一个银行账户的实体模型，它有一个属性 balance 表示当前的存款余额，有一个属性 name 表示账户名（不同的账户 name 是不同的），另有两个行为分别表示查询余额 getBalance 和查询用户名 getName 操作。 由于程序不仅需要管理某一位顾客的账户，而且还可能涉及大量的银行账户需要处理，所以还应建立一个名为“账户管理员”的实体模型，它负责执行每一账户的开设、撤销和访问等操作。每个账户管理员管理若干个账户，账户可能由多个账户管理员同时管理。 账户管理员 AccountManager 有一属性 accountlist 记录当前已开设的所有账户，accountNumber 为指针，其指向的值记录当前已开设的账户个数，SuperVipAccount 为对象指针，其指向的值为超级 Vip 账户，当管理员管理的账户里没有开设超级 Vip 账户时，指针指向 NULL。账户可以在不同银行开设，所以需要拷贝构造函数 AccountManager(const AccountManager&amp;)，将所有信息移植给另外的管理员，注意深复制与浅复制的问题。管理员还有开设账户 open、开设超级 Vip 账户 openSuperVipAccount、关闭超级 Vip 账户closeSuperVipAccount、获取超级 Vip 账户余额 getBalanceOfSuperVip、获取账户总数 getAccountNumber、获取管理员总数 getManagerNumber 这些行为。 特别的，getBalanceOfSuperVip 有个 double 类型的引用参数，如果已经开设超级 Vip 则将其余额赋值给此参数，并且函数返回 true；否则参数的值不改变，函数返回 false。 超级 Vip 是独立存在的，开设和关闭超级 Vip 的时候不需要改变 Manager 里的 accountlist 和 accountNumber。 请实现如下 Account 和 AccountManager 类的定义，以完成该账户管理程序: 123456789101112131415161718192021222324252627282930class Account&#123; private: string name; double balance; public: Account(); Account(string,double); void deposit(double); //存款 bool withdraw(double); //取款 string getName() const; //const成员函数，获取账户名 double getBalance() const; //const成员函数，获取账户余额 &#125;;class AccountManager&#123; private: Account accountlist[100]; int *accountNumber; //记录当前开设的账户总数 Account* SuperVipAccount; //记录超级Vip账户 static int ManagerNumber; //static成员，记录所有管理员总数 public: AccountManager(); AccountManager(const AccountManager&amp;); //拷贝构造函数 void open(string); void close(string); void depositByName(string,double); bool withdrawByName(string,double); double getBalanceByName(string); Account getAccountByName(string); main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;AccountManager.hpp&quot;#include &lt;iostream&gt;using namespace std;int main() &#123; AccountManager* am = new AccountManager(); string name; double num; string command; while (cin &gt;&gt; command) &#123; if (command == &quot;open&quot;) &#123; cin &gt;&gt; name; am -&gt; open(name); cout &lt;&lt; &quot;Account &quot; &lt;&lt; name &lt;&lt; &quot; opened.&quot; &lt;&lt; endl; &#125; else if (command == &quot;deposit&quot;) &#123; cin &gt;&gt; name &gt;&gt; num; am -&gt; depositByName(name, num); cout &lt;&lt; name &lt;&lt; &quot; deposited &quot; &lt;&lt; num &lt;&lt; endl; num = am -&gt; getBalanceByName(name); cout &lt;&lt; name &lt;&lt; &quot; has &quot; &lt;&lt; num &lt;&lt; endl; &#125; else if (command == &quot;withdraw&quot;) &#123; cin &gt;&gt; name &gt;&gt; num; if (am -&gt; withdrawByName(name, num)) &#123; cout &lt;&lt; name &lt;&lt; &quot; withdrawed &quot; &lt;&lt; num &lt;&lt; endl; num = am -&gt; getBalanceByName(name); cout &lt;&lt; name &lt;&lt; &quot; has &quot; &lt;&lt; num &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Withdraw failed, check the balance.&quot; &lt;&lt; endl; &#125; &#125; else if (command == &quot;check&quot;) &#123; cin &gt;&gt; name; num = am -&gt; getBalanceByName(name); cout &lt;&lt; name &lt;&lt; &quot; has &quot; &lt;&lt; num &lt;&lt; endl; &#125; else if (command == &quot;openvip&quot;) &#123; cin &gt;&gt; name; Account ac = am -&gt; getAccountByName(name); if (ac.getName() == name) &#123; am -&gt; openSuperVipAccount(ac); cout &lt;&lt; &quot;set &quot; &lt;&lt; name &lt;&lt; &quot; as super vip&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;no such Account&quot; &lt;&lt; endl; &#125; &#125; else if (command == &quot;closevip&quot;) &#123; am -&gt; closeSuperVipAccount(); cout &lt;&lt; &quot;super vip closed&quot; &lt;&lt; endl; &#125; else if (command == &quot;quit&quot;) &#123; delete am; return 0; &#125; else &#123; cout &lt;&lt; &quot;No such command.&quot; &lt;&lt; endl; &#125; &#125; delete am; return 0;&#125; account.hpp(lock) 1234567891011121314151617181920#ifndef _ACCOUNT_HPP_#define _ACCOUNT_HPP_#include &lt;string&gt;using std::string;class Account &#123;public: Account(); Account(string, double); void deposit(double); bool withdraw(double); string getName() const; double getBalance() const;private: string name; double balance;&#125;;#endif accountmanager.hpp(lock) 12345678910111213141516171819202122232425262728293031#ifndef _ACCOUNT_MANAGER_HPP_#define _ACCOUNT_MANAGER_HPP_#include &quot;Account.hpp&quot;#include &lt;string&gt;using std::string;class AccountManager &#123;public: AccountManager(); AccountManager(const AccountManager&amp;); //拷贝构造函数 void open(string); void close(string); void depositByName(string,double); bool withdrawByName(string,double); double getBalanceByName(string); Account getAccountByName(string); void openSuperVipAccount(Account&amp;); //开设超级Vip账户 void closeSuperVipAccount(); //关闭超级Vip账户 bool getBalanceOfSuperVipAccount(double&amp;) const; int getAccountNumber() const; int getManagerNumber() const; ~AccountManager(); //析构函数 private: Account accountlist[100]; int *accountNumber; //记录当前开设的账户总数 Account* SuperVipAccount; //记录超级Vip账户 static int ManagerNumber; //static成员，记录所有管理员总数 &#125;;#endif account.cpp 123456789101112131415161718192021222324252627282930#include&lt;Account.hpp&gt;#include&lt;AccountManager.hpp&gt;Account:: Account()&#123; balance=0;&#125;Account:: Account(string a, double b):name(a),balance(b)&#123;&#125;void Account:: deposit(double a)&#123; balance+=a;&#125;bool Account:: withdraw(double a)&#123; if(a&gt;=balance)&#123; return false; &#125;else&#123; balance-=a; return true; &#125;&#125;string Account:: getName() const&#123; return name;&#125;double Account:: getBalance() const&#123; return balance;&#125; accountmanger.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;Account.hpp&gt;#include&lt;AccountManager.hpp&gt;int AccountManager:: ManagerNumber=0;AccountManager:: AccountManager()&#123; accountNumber=new int (0); ManagerNumber++; SuperVipAccount=NULL;&#125;AccountManager:: AccountManager(const AccountManager&amp; a)&#123; accountNumber=new int (a.getAccountNumber()); *accountNumber = *a.accountNumber; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; accountlist[i]=a.accountlist[i]; &#125; if(a.SuperVipAccount != NULL)&#123; SuperVipAccount = new Account(*a.SuperVipAccount); &#125; ManagerNumber++;&#125;void AccountManager:: open(string a)&#123; accountlist[this-&gt;getAccountNumber()] = Account(a,0); (*accountNumber)++;&#125;void AccountManager:: close(string a)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; for(int j=i;j&lt;this-&gt;getAccountNumber()-1;j++)&#123; accountlist[j]=accountlist[j+1]; &#125; &#125; &#125; (*accountNumber)--;&#125;void AccountManager:: depositByName(string a,double b)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; accountlist[i].deposit(b); &#125; &#125;&#125;bool AccountManager:: withdrawByName(string a,double b)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; return accountlist[i].withdraw(b); &#125; &#125;&#125;double AccountManager:: getBalanceByName(string a)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; return accountlist[i].getBalance(); &#125; &#125;&#125;Account AccountManager:: getAccountByName(string a)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; return accountlist[i]; &#125; &#125;&#125;void AccountManager:: openSuperVipAccount(Account&amp; a)&#123; SuperVipAccount=new Account (a);&#125; //开设超级Vip账户 void AccountManager:: closeSuperVipAccount()&#123; if(SuperVipAccount != NULL)&#123; delete SuperVipAccount; &#125;&#125; //关闭超级Vip账户 bool AccountManager:: getBalanceOfSuperVipAccount(double&amp; a) const&#123; if(SuperVipAccount!=NULL)&#123; a=SuperVipAccount-&gt;getBalance(); return true; &#125; return false;&#125;int AccountManager:: getAccountNumber() const&#123; return *accountNumber;&#125;int AccountManager:: getManagerNumber() const&#123; return ManagerNumber;&#125;AccountManager:: ~AccountManager()&#123; delete accountNumber; accountNumber = nullptr; if(SuperVipAccount != nullptr)&#123; delete SuperVipAccount; SuperVipAccount = nullptr; &#125;&#125; //析构函数","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(二十)--songlist(拷贝)","slug":"程设/songlist","date":"2022-04-12T06:17:55.001Z","updated":"2022-04-12T06:20:28.725Z","comments":true,"path":"2022/04/12/程设/songlist/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/songlist/","excerpt":"","text":"Description Recently, Xiao Ming is developing a music player, which requires model the SongList. He want to implement a simple SongList object. But in the versions he implemented before, the double free or memory leak mistake always show up. As you are excellent C++ developer, he try to ask help from you. He has already written down the declaration of the functions in songList.h. You only need to accomplish the songList.cpp. 小明最近在开发一个音乐播放器，需要对歌单进行建模。他希望实现一个简单的歌单类，但是在之前他自己实现的版本中，总是出现double free或者memory leak的错误，他听闻你C++学得不错，向你求助来了。他在songList.h头文件中已经写好了函数的声明，希望你能在songList.cpp中将定义完善。 Sample Input The first line is an int variable numSongs, which indicates the number of songList1. And the next numSongs line are the songs' name. 第一行是一个整型变量numSongs，记录第一个歌单的个数，接下来的numSongs行分别是歌曲名字。 1232We Choose To Go To The MoonA Lovely Wedding - Snowand Sky Sample Output The output will show songList1、songList2、songList3, the songList1will be initiated by the songs in the input and add toAddAndRemoved twice, but the songList should do the elimination so it should be store once. songList2 is copied from songList1 and will remove toAddAndRemoved, songList3 is initiated from songList2 but clear it songs after that, so it shoule be empty. 输出会显示三个歌单，songList1通过输出的歌曲初始化，并添加两次歌曲toAddAndRemoved（Lights Frightened The Captain），但因为去重的原因实际只添加一次。songList2通过songList1拷贝得到，并删除toAddAndRemoved。songList3通过songList2初始化，并清空歌单。 123456789101112owner:MakaBakaSongs:We Choose To Go To The MoonA Lovely Wedding - Snowand SkyLights Frightened The Captainowner:MakaBakaSongs:We Choose To Go To The MoonA Lovely Wedding - Snowand SkyMakaBaka&#x27;s SongList is Empty. Note 输出运算符重载： 如果歌单为空，则输出&lt;owner&gt;'s SongList is Empty.，其中owner是歌单类的成员变量。 如果歌单不为空，则输出 12345owner:&lt;owner&gt;Songs:&lt;song1&gt;&lt;song2&gt;... Hint 清空歌曲是否需要真的把歌曲删除？ 拷贝函数需要考虑什么？ 赋值拷贝函数需要考虑哪三件事？ songlist.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;string&gt;#include &lt;iostream&gt;#include&lt;songList.h&gt;using namespace std;SongList:: SongList(const std::string _owner, unsigned int _size, unsigned int _capacity, std::string *_songs)&#123; owner=_owner; size=_size; capacity=_capacity; songs=new string[capacity]; for(int i=0;i&lt;size;i++)&#123; songs[i]=_songs[i]; &#125;&#125;SongList:: SongList(const SongList &amp;a)&#123; owner=a.owner; size=a.size; capacity=a.capacity; songs=new string[capacity]; for(int i=0;i&lt;size;i++)&#123; songs[i]=a.songs[i]; &#125;&#125;void SongList:: addSong(const std::string &amp;song)&#123; for(int i=0;i&lt;size;i++)&#123; if(song==songs[i]) return; &#125; if(size==capacity)&#123; string *newsongs=new string [capacity+1]; int i; for(i=0;i&lt;size;i++)&#123; newsongs[i]=songs[i]; &#125; newsongs[i]=song; delete [] songs; songs=new string [capacity+1]; for(i=0;i&lt;size+1;i++)&#123; songs[i]=newsongs[i]; &#125; delete [] newsongs; size++; capacity++; &#125;else&#123; songs[size]=song; size++; &#125;&#125; // 删除指定歌曲，歌曲不存在则无动作void SongList:: removeSong(const std::string &amp;song)&#123; for(int i=0;i&lt;size;i++)&#123; if(songs[i]==song)&#123; for(int j=i;j&lt;size-1;j++)&#123; songs[j]=song[j+1]; &#125; size--; return; &#125; &#125;&#125; // 清空歌曲void SongList:: clearSong()&#123; size=0;&#125;SongList &amp; SongList::operator=(const SongList &amp;a)&#123; if (&amp;a != this) &#123; *this=SongList(a); &#125; return *this;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;os, const SongList &amp;a)&#123; if(a.size==0)&#123; os&lt;&lt;a.owner&lt;&lt;&quot;&#x27;s SongList is Empty.&quot;&lt;&lt;endl; return os; &#125;else&#123; os&lt;&lt;&quot;owner:&quot;&lt;&lt;a.owner&lt;&lt;endl; os&lt;&lt;&quot;Songs:&quot;&lt;&lt;endl; for(int i=0;i&lt;a.size;i++)&#123; os&lt;&lt;a.songs[i]&lt;&lt;endl; &#125; return os; &#125;&#125;SongList:: ~SongList()&#123; delete [] songs;&#125; songlist.h(lock) 12345678910111213141516171819202122232425262728293031323334353637383940#ifndef SONGLIST_H#define SONGLIST_H#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class SongList &#123; std::string owner; // 歌单拥有者 unsigned int size; // 歌单中有效歌曲的数量 unsigned int capacity; // 歌单的最大容量 std::string *songs; // 歌曲列表，一个string数组public: // 初始化的歌曲列表中会保证没有重复歌曲 SongList(const std::string _owner, unsigned int _size, unsigned int _capacity, std::string *_songs); SongList(const SongList &amp;songList); // 添加歌曲，请考虑去重的情况（如果歌曲已经存在则不添加）、歌单已经满了需要扩容的情况，扩容方案自选 // 扩容方案1：原地扩容，C语言中有个realloc函数可以实现 // 扩容方案2：重新开辟一个更大容量songs歌曲列表，并将当前的数据迁移过去 void addSong(const std::string &amp;song); // 删除指定歌曲，歌曲不存在则无动作 void removeSong(const std::string &amp;song); // 清空歌曲 void clearSong(); SongList &amp;operator=(const SongList &amp;songList); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const SongList &amp;songList); ~SongList();&#125;;#endif //SONGLIST_H framework.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;songList.h&quot;using namespace std;int main() &#123; int numSongs; cin &gt;&gt; numSongs; getchar(); //读取换行符 string name2 = &quot;MakaBaka&quot;; string *songs = new string[numSongs]; for (int i = 0; i &lt; numSongs; ++i) &#123; getline(cin, songs[i]); &#125; string toAddAndRemoved = &quot;Lights Frightened The Captain&quot;; SongList songList1(name2, numSongs, numSongs, songs); songList1.addSong(toAddAndRemoved); songList1.addSong(toAddAndRemoved); delete []songs; SongList songList2(songList1); songList2 = songList2; songList2.removeSong(toAddAndRemoved); SongList songList3 = songList2; songList3.clearSong(); cout &lt;&lt; songList1 &lt;&lt; endl; cout &lt;&lt; songList2 &lt;&lt; endl; cout &lt;&lt; songList3 &lt;&lt; endl; return 0;&#125;/* * 示例输入： * 2 * We Choose To Go To The Moon * A Lovely Wedding - Snowand Sky * * 示例输出： * owner:MakaBaka * Songs: * We Choose To Go To The Moon * A Lovely Wedding - Snowand Sky * Lights Frightened The Captain * * owner:MakaBaka * Songs: * We Choose To Go To The Moon * A Lovely Wedding - Snowand Sky * * MakaBaka&#x27;s SongList is Empty. */","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十九)--make list","slug":"程设/make list","date":"2022-04-12T06:14:03.981Z","updated":"2022-05-08T08:25:22.000Z","comments":true,"path":"2022/04/12/程设/make list/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/make%20list/","excerpt":"","text":"Description Input multiple lines of numbers from the console, please to allocate arrays of double variable to store these lines. Then, use a pointer array to store the addresses of these double arrays. You need to implement the two functions: double** make_list(double data[], int sizes[]) and void free_lists(double* lists[]) . Input format There are N lines input and each line contains no more than M double number( 1&lt;=N&lt;=20, 1&lt;=M&lt;=10). Output format The same numbers as input. Example input 1234560.288 0.919 0.130 0.610 0.696 0.616 0.7790.949 0.982 0.861 0.608 0.156 0.6170.294 0.384 0.980 0.203 0.5020.286 0.157 0.866 0.329 0.7330.269 0.370 0.6690.473 0.829 0.509 0.714 Example output 1234560.288 0.919 0.130 0.610 0.696 0.616 0.7790.949 0.982 0.861 0.608 0.156 0.6170.294 0.384 0.980 0.203 0.5020.286 0.157 0.866 0.329 0.7330.269 0.370 0.6690.473 0.829 0.509 0.714 source.h 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;double** make_list(double data[], int sizes[])&#123; double** a=NULL; int i=0,num=0; for(i=0;sizes[i]!=0;i++)&#123;&#125; a=new double*[i+1]; a[i]=NULL; for(int j=0;sizes[j]!=0;j++)&#123; a[j]= new double[sizes[j]]; &#125; for(int m=0;m&lt;i;m++)&#123; for(int n=0;n&lt;sizes[m];n++)&#123; a[m][n]=data[num++]; &#125; &#125; return a; &#125;void free_lists(double* lists[])&#123; for(int i=0;lists[i]!=NULL;i++)&#123; delete [] lists[i]; &#125; delete [] lists;&#125; main.cpp 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &quot;source.h&quot;void print_list(double list[], int size) &#123; for (int i = 0; i &lt; size; ++ i) printf(&quot;%.3lf &quot;, list[i]); putchar(&#x27;\\n&#x27;);&#125;void print_lists(double * lists[], int sizes[]) &#123; for (int i = 0; ; ++ i) &#123; if (lists[i] == NULL) break; print_list(lists[i], sizes[i]); &#125;&#125;// read a number of double data in a signle line, returns the number of data redint read_data_line(double data[]) &#123; char line[1000]; if (fgets(line, 1000, stdin) == NULL) return 0; return sscanf(line, &quot;%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf&quot;, data, data+1, data+2, data+3, data+4, data+5, data+6, data+7, data+8, data+9);&#125;int main() &#123; double data[1000]; int num_data_per_line[20] = &#123;0&#125;; int total = 0; for (int i = 0; i &lt; 20; ++ i) &#123; int num_data = read_data_line(data + total); if (num_data &lt;= 0) num_data = 0; total += num_data; num_data_per_line[i] = num_data; if (num_data == 0) break; &#125; // TODO: allocate a list of pointers to allocated lists of doubles double ** lists = make_list(data, num_data_per_line); print_lists(lists, num_data_per_line); free_lists(lists);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十八)--cat and catfamily","slug":"程设/cat and catfamily","date":"2022-04-12T06:11:15.041Z","updated":"2022-04-12T06:13:18.428Z","comments":true,"path":"2022/04/12/程设/cat and catfamily/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/cat%20and%20catfamily/","excerpt":"","text":"题目 以下是一个简单的信息系统的例子。这个例子中缺少Cat类和CatFamily类（假设CatFamily中至多有100只猫）。 请阅读C++主程序，并了解类你需要实现一些什么。 EXAMPLE INPUT 2 CWIGAKZPB 4 4 3 PAUGOCDWM 4 1 XLAQWFT 10 2 ZINYSVEH 4 2 ZTYMHJGO 3 YITJLASK 4 2 CIXSDKMZ 4 2 XLAQWFT 2 KLPMURWX 4 2 USFTVBJMK 4 1 HAFGM 2 1 NVUIH 4 0 EXAMPLE OUTPUT Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: CWIGAKZPB Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game No such cat: PAUGOCDWM Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully added cat: XLAQWFT Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: ZINYSVEH Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: XLAQWFT of 10years old Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: ZTYMHJGO Add a cat Remove a cat Find a cat Print all cats Exit this game No such cat: YITJLASK Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: XLAQWFT of 10years old Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: CIXSDKMZ Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: XLAQWFT of 10years old Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully removed cat: XLAQWFT Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: KLPMURWX Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: USFTVBJMK Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully added cat: HAFGM Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully added cat: NVUIH Add a cat Remove a cat Find a cat Print all cats Exit this game See you Hint 为了实现访问cat_family[i]，你需要在类里面实现下面这个成员函数 123string operator[] (int num) const &#123;//return 一点什么东西呢 &#125; source.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std;class Cat&#123; public: int cat_age; string cat_name;&#125;;class CatFamily&#123; public: CatFamily() &#123; numofcat = 0; &#125; int remove_a_cat(string name)&#123; if(has_cat(name) ==1 )&#123; for(int i=0;i&lt;number_of_cats();i++)&#123; if( a[i].cat_name==name ) &#123; a[i] = a[number_of_cats() - 1]; numofcat--; return 1; &#125; &#125; &#125; return 0; &#125; int has_cat(string b)const&#123; for(int i=0;i&lt;number_of_cats();i++)&#123; if( a[i].cat_name==b ) return 1; &#125; return 0; &#125; Cat get_cat(string name)const&#123; for(int i=0;i&lt;number_of_cats();i++)&#123; if( a[i].cat_name==name ) return a[i]; &#125; return a[99]; &#125; int add_a_cat(string cat_name,int cat_age)&#123; if(number_of_cats()&lt;=100 &amp;&amp; has_cat(cat_name)==0 )&#123; a[number_of_cats()].cat_name=cat_name; a[number_of_cats()].cat_age=cat_age; numofcat++; return 1; &#125; return 0; &#125; int number_of_cats()const&#123; return numofcat; &#125; string operator[] (int num) const &#123; return a[num].cat_name; &#125;//return 一点什么东西呢 public: Cat a[100]; int numofcat;&#125;; framework.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#include &quot;source.cpp&quot;int main_menu() &#123; cout &lt;&lt; &quot;1. Add a cat&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2. Remove a cat&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3. Find a cat&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4. Print all cats&quot; &lt;&lt; endl; cout &lt;&lt; &quot;0. Exit this game&quot; &lt;&lt; endl; int choice; cin &gt;&gt; choice; return choice;&#125;void add_a_cat(CatFamily &amp; cat_family) &#123; string cat_name; int cat_age; cin &gt;&gt; cat_name &gt;&gt; cat_age; if (cat_family.add_a_cat(cat_name, cat_age)) cout &lt;&lt; &quot;Successfully added cat: &quot; &lt;&lt; cat_name &lt;&lt; endl; else cout &lt;&lt; &quot;Fail to add cat: &quot; &lt;&lt; cat_name &lt;&lt; endl;&#125;void remove_a_cat(CatFamily &amp; cat_family) &#123; string cat_name; cin &gt;&gt; cat_name; if (cat_family.remove_a_cat(cat_name)) cout &lt;&lt; &quot;Successfully removed cat: &quot; &lt;&lt; cat_name &lt;&lt; endl; else cout &lt;&lt; &quot;Fail to remove cat: &quot; &lt;&lt; cat_name &lt;&lt; endl;&#125;void find_a_cat(CatFamily &amp; cat_family) &#123; string cat_name; cin &gt;&gt; cat_name; if (cat_family.has_cat(cat_name)) &#123; cout &lt;&lt; &quot;Here is your cat: &quot; &lt;&lt; cat_family.get_cat(cat_name).cat_name &lt;&lt; &quot; of &quot; &lt;&lt; cat_family.get_cat(cat_name).cat_age &lt;&lt; &quot;years old&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;No such cat: &quot; &lt;&lt; cat_name &lt;&lt; endl;&#125;void print_all_cats(CatFamily &amp; cat_family) &#123; cout &lt;&lt; &quot;We have these cats:&quot; &lt;&lt; endl; for (int i = 0; i &lt; cat_family.number_of_cats(); ++ i) &#123; string cat_name = cat_family[i]; cout &lt;&lt; &#x27;\\t&#x27; &lt;&lt; cat_family.get_cat(cat_name).cat_name &lt;&lt; &quot; of &quot; &lt;&lt; cat_family.get_cat(cat_name).cat_age &lt;&lt; &quot;years old&quot; &lt;&lt; endl; &#125; &#125;int main() &#123; CatFamily cat_family; while (true) &#123; int choice = main_menu(); switch (choice) &#123; case 0: cout &lt;&lt; &quot;See you&quot; &lt;&lt; endl; exit(0); case 1: add_a_cat(cat_family); break; case 2: remove_a_cat(cat_family); break; case 3: find_a_cat(cat_family); break; case 4: print_all_cats(cat_family); &#125; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十七)--格式控制(重载)","slug":"程设/格式控制(重载)","date":"2022-04-12T06:08:54.657Z","updated":"2022-04-12T06:10:44.884Z","comments":true,"path":"2022/04/12/程设/格式控制(重载)/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6(%E9%87%8D%E8%BD%BD)/","excerpt":"","text":"Description My books want to have different kinds of formats of a booklist. To improve the reuseability of the code, we should use the object-oriented thought. I design the class Book as below: 123456789class Book&#123; string name; string code; double cost;public: Book(string s,string c,double co):name(s),code(c),cost(co)&#123;&#125;&#125;; The default output format of a Book object requires Each field being right-justified Each field having the same field width: 15 Each number (double) having a forced 6 digits after the decimal dot. The leftform output format of a Book object requires Each field being left-justified Each field having the same field width: 15 Each number (double) having a forced 2 digits after the decimal dot. The rightform output format of a Book object requires Each field being right-justified Each field having the same field width: 15 Each number (double) having a forced 2 digits after the decimal dot. The main function is : 12345678910111213141516171819202122int main() &#123; int N; string name; string code; double cost; cin &gt;&gt; N; int i = 0; Book *books[N]; for(i=0;i&lt;N;i++)&#123; cin &gt;&gt; name &gt;&gt; code &gt;&gt; cost; books[i] = new Book(name, code, cost); &#125; for(i=0;i&lt;N;i++)&#123; cout &lt;&lt; &quot;-----:&quot; &lt;&lt; *books[i]; &#125; for(i=0;i&lt;N;i++)&#123; cout &lt;&lt; leftform &lt;&lt; *books[i]; &#125; for(i=0;i&lt;N;i++)&#123; cout &lt;&lt; rightform &lt;&lt; *books[i]; &#125;&#125; Input First line is the integer N followed by N lines. Each line contains the name, code and cost. The input has been handled by the test framework. Output Please refer to the main function and the sample output. The output has been handled by the test framework. Sample Input 12343book1 123456 342.13book2 456789 23book3 789123 1.2321 Sample Output 123456789-----: book1 123456 342.130000-----: book2 456789 23.000000-----: book3 789123 1.232100left :book1 123456 342.13 left :book2 456789 23.00 left :book3 789123 1.23 right: book1 123456 342.13right: book2 456789 23.00right: book3 789123 1.23 Hint 为了实现cout&lt;&lt;*book[i];你需要在类声明处实现这样一个函数 123456789class Book&#123;//...其他成员public:friend ostream &amp; operator &lt;&lt; (ostream &amp; os, const Book &amp; b) &#123;//像下面这个语句来写//os&lt;&lt; &quot;something&quot;; return os; &#125;&#125; 另外，为了实现cout&lt;&lt;leftform;你需要实现一个这样的函数（在最外部，不在类里面） 123456ostream &amp; leftform(ostream&amp; strm) &#123;//像下面这样写//strm &lt;&lt; &quot;right:&quot;;//strm &lt;&lt; setw(15);return strm;&#125; framwork.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;source.h&quot;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stdio.h&gt;using namespace std;int main() &#123; //freopen(&quot;2.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;2.out&quot;,&quot;w&quot;,stdout); int N, M; string name; string code; double cost; cin &gt;&gt; N; M = N; int i = 0; Book *books[N]; while (i++ &lt; N) &#123; cin &gt;&gt; name &gt;&gt; code &gt;&gt; cost; books[i] = new Book(name, code, cost); &#125; i = 0; while (i++ &lt; M) &#123; cout &lt;&lt; &quot;-----:&quot; &lt;&lt; *books[i]; &#125; i = 0; while (i++ &lt; M) &#123; cout &lt;&lt; leftform &lt;&lt; *books[i]; &#125; i = 0; while (i++ &lt; M) &#123; cout &lt;&lt; rightform &lt;&lt; *books[i]; &#125;&#125; source.h 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stdio.h&gt;using namespace std;class Book&#123; string name; string code; double cost;public: Book(string s,string c,double co):name(s),code(c),cost(co)&#123;&#125; friend ostream &amp; operator &lt;&lt; (ostream &amp; os, const Book &amp; b) &#123; //os&lt;&lt; &quot;something&quot;; return os&lt;&lt;setw(15)&lt;&lt;b.name&lt;&lt;setw(15)&lt;&lt;b.code&lt;&lt;setw(15)&lt;&lt;setiosflags(ios::fixed)&lt;&lt;b.cost&lt;&lt;endl; &#125;&#125;;ostream &amp; leftform(ostream&amp; strm) &#123;//像下面这样写//strm &lt;&lt; &quot;right:&quot;;//strm &lt;&lt; setw(15);strm &lt;&lt; &quot;left :&quot;;strm &lt;&lt; setw(15)&lt;&lt;left;strm &lt;&lt; fixed&lt;&lt;setprecision(2);return strm;&#125;ostream &amp; rightform(ostream&amp; strm) &#123;//像下面这样写//strm &lt;&lt; &quot;right:&quot;;//strm &lt;&lt; setw(15);strm &lt;&lt; &quot;right:&quot;;strm &lt;&lt; setw(15)&lt;&lt;right;strm &lt;&lt; fixed&lt;&lt;setprecision(2);return strm;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十六)--格式控制","slug":"程设/格式控制2","date":"2022-04-12T06:06:39.078Z","updated":"2022-04-12T06:07:21.009Z","comments":true,"path":"2022/04/12/程设/格式控制2/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B62/","excerpt":"","text":"题目 Write a program to read a list containing item name (std::string), item code (std::string), and item cost (double) interactively and produce a three-column output satisfying: name and code are left-justified; cost is right-justified with a precision of two digits. Trailing zeros are shown; The field width for name, code and cost are 15, 15, 10, respectively. Input First line is an integer N to specify the number of books, followed with N lines. Each line contains the name, code and cost. Output For each item, output it in the aforementioned format. Sample Input 12343book1 2312123 342.13book2 342 123book3 342 1.2321 Sample Output 123book1 2312123 342.13book2 342 123.00book3 342 1.23 source.cpp 1234567891011121314151617181920#include&lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; string name,code; double cost; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;name&gt;&gt;code&gt;&gt;cost; cout&lt;&lt;setw(15)&lt;&lt;left&lt;&lt;name; cout&lt;&lt;setw(15)&lt;&lt;left&lt;&lt;code; cout&lt;&lt;setw(10)&lt;&lt;right&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;cost&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十五)--格式控制","slug":"程设/格式控制","date":"2022-04-12T06:03:38.422Z","updated":"2022-04-12T06:05:51.155Z","comments":true,"path":"2022/04/12/程设/格式控制/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/","excerpt":"","text":"题目 It is important to control the format of outputs. Now, an output is given. 1234567891011121314151617181920212223242526control the format of numeric value, 123456789.9876543Default:1.23457e+08Using fixed:123456789.987654With precision 7:123456789.9876543Scientific with precision 3:1.235e+08---------------------------control the base of numeric value, 16Hex:10Oct:20Dec:16---------------------------control the width and alignment, and the width is 6 spacesright aligned 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768left aligned1 2 4 816 32 64 128256 512 1024 20484096 8192 16384 32768---------------------------control the fillment of 123456Original: 123456 Filled:**123456 Your task is to write a program to print the output above. main.cpp 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; double x=123456789.9876543; cout&lt;&lt;&quot;control the format of numeric value, 123456789.9876543\\n&quot;; cout&lt;&lt;&quot;Default:&quot;&lt;&lt; scientific &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; endl; cout&lt;&lt;&quot;Using fixed:&quot; &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; x &lt;&lt; endl; cout&lt;&lt;&quot;With precision &quot;&lt;&lt;7&lt;&lt;&quot;:&quot; &lt;&lt;fixed &lt;&lt; setprecision(7) &lt;&lt; x&lt;&lt; endl; cout&lt;&lt;&quot;Scientific with precision &quot;&lt;&lt;3&lt;&lt;&quot;:&quot;&lt;&lt;scientific &lt;&lt; setprecision(3) &lt;&lt; x &lt;&lt; endl; cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;control the base of numeric value, 16&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Hex:&quot;&lt;&lt;hex&lt;&lt;16&lt;&lt;endl; cout&lt;&lt;&quot;Oct:&quot;&lt;&lt;oct&lt;&lt;16&lt;&lt;endl; cout&lt;&lt;&quot;Dec:&quot;&lt;&lt;dec&lt;&lt;16&lt;&lt;endl; cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;control the width and alignment, and the width is 6 spaces&quot;&lt;&lt;endl; cout&lt;&lt;&quot;right aligned&quot;&lt;&lt;endl; cout &lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 1&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 2&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 4&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 8&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 16&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 32&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 64&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 128&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 256&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 512&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 1024&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 2048&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 4096&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 8192&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 16384&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 32768&lt;&lt;endl; cout&lt;&lt;&quot;left aligned&quot;&lt;&lt;endl; cout &lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 1&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 2&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 4&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 8&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 16&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 32&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 64&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 128&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 256&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 512&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 1024&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 2048&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 4096&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 8192&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 16384&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 32768&lt;&lt;endl; cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;control the fillment of 123456&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Original: 123456&quot;&lt;&lt;endl; cout&lt;&lt;&quot; Filled:&quot;&lt;&lt;setw(8)&lt;&lt; setfill(&#x27;*&#x27;)&lt;&lt;right&lt;&lt;123456&lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"第八章- COUNTER(计数器)","slug":"数字电路汇总/数字电路第八章","date":"2022-04-11T07:36:39.536Z","updated":"2022-07-21T07:27:26.818Z","comments":true,"path":"2022/04/11/数字电路汇总/数字电路第八章/","link":"","permalink":"http://example.com/2022/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%85%AB%E7%AB%A0/","excerpt":"","text":"异步计数器计算(Asynchronous) 2位异步计数器 3位异步计数器 传输延迟 异步计数器被称为行波计数器,存在传输延迟 ****异步触发可能导致多级延迟（最长延迟必须小于 时钟周期）、错误的暂态 异步译码计数器 计数器可以有\\(2^{n}\\)个状态,n是触发器个数 模10截断 异步清0导致毛刺 74LS93 （CTR DIV n代表n个状态的计数器） 74LS93可以做模10或者模16的计数器 同步计数器计算(Synchronous) 2位同步二进制计数器 传输延迟 时序图 3位同步二进制计数器 信号重用 4位同步二进制计数器 如何做一个模10的 需要求得每个JK触发器的逻辑输入公式 74HC163 4位同步二进制计数器 同步置数，同步清零 计数使能条件：ENT和ENP同为1 末端计数TC=15时进位输出RCO=1 加减同步计数器(双向计数器) 对于\\(J_1\\)和\\(K_1\\) 对于加（UP）时序，\\(Q_1\\)在\\(Q_0=1\\)的下一个时钟脉冲到来时改变状态。对于减（DOWN）时序，\\(Q_1\\)在\\(Q_0=0\\)的下一个时钟脉冲到来时改变状态。 对于\\(J_2\\)和\\(K_2\\) 对于加时序来说，\\(Q2\\)在\\(Q_0＝Q_1＝1\\)的下一个时钟脉冲到来时改变状态。对于减时序来说，\\(Q_2\\)在\\(Q_0＝Q_1＝0\\)的下一个时钟脉冲到来时改变状态。因此，在下面的等式所表达的条件下，FF2的\\(J_2\\)和\\(K_2\\)输入必须等于1： 74HC190 加减十进制计数器 \\(D/\\bar{U}\\)表示DOWN/UP,加减控制输入 \\(\\overline{CTEN}\\)表示计数使能端(count enable) 同步计数器的设计(重点) 时序逻辑电路的一般模型：状态机 •输入：\\((I_0,I_1,…,I_m)；\\)输出：\\((O_0,O_1,…,O_m)；\\) 激励：\\((Y_0,Y_1,…,Y_p)；\\)状态：\\((Q_0,Q_1,…,Q_x)\\) •Moore型：输出仅与当前状态相关，\\(O=F(Q)\\) •Mealy型：输出与当前状态和输入相关，\\(O=F(I,Q)\\) •同步：所有触发器用同一个时钟信号,状态变化同时发生 •异步：触发器没有统一的时钟信号,状态变化时间有先后 时序逻辑电路设计步骤 准备：画状态图，作次态表、触发器的转换表。 化简：作卡诺图，求触发器的输入逻辑表达式。 设计：作电路逻辑图。 以设计格雷码为例 用J-K触发器设计同步3位双向格雷码计数器 级联计数器Cascaded counters 目的：级联多个计数器来扩大计数器的模 异步级联 总的模为32;表现为32分频计数器 同步级联 级联信号：计数使能CTEN，末端计数TC 低位片的TC作为高位片的计数使能信号 多个级联的同步计数器构成递减计数链 •计数器的模等于各级计数器的模的乘积 •从低位到高位的TC信号频率等于时钟频率依次除以各级计数器的模 用4片74HC161设计模为40000的计数器 (截断时序的级联计数器) 思路：先把4片74HC161级联为一个模65536的计数器，再改造为模40000的计数器 65536-40000=25536（十六进制为\\(63C0_{16}\\)），计数序列：25536~65535 计数到达65535，最高位片RCO=1，计数器状态设为25536 计数器状态译码 目的：检测计数器的特定状态来输出有效信号，例子：TC 计数器应用 显示“时：分：秒”的数字钟系统 停车场出入控制系统 并行—串行数据转换系统 交通信号灯控制系统 小结 异步计数器中的异步指的是什么? 一个模14计数器有多少状态？需要至少多少个触发器来实现它？ 一个同步计数器和一个异步计时器的区别是什么？ 解释计数器的预置位功能，例如74HC163。 74HC163 解释74HC163计数器的输入ENP、ENT和输出RCO的用途。 一个4位加／减计数器处于减模式，并且为1010状态。下一个时钟脉冲到来时，计数器的状态是什么？ 处在加模式的4位加／减计时器的最后一个状态是什么？当处于减模式时，下一个状态是什么？ 完成一个1000分频的计数器需要多少个十进制计数器?10000分频的呢? 给出如何获取如下分频的一般框图.使用触发器、十进制计数器、4位二进制计数器或他们的组合： （a） 20分频（b） 32分频（c） 160分频（d） 320分频 4位二进制异步计数器状态变化如下,可能发生的瞬间状态是什么? (a)2-3 (b)3-4 (c)10-11 (d)15-0 关联标记,字母C、M、G表示什么 哪个字母表示数据存储?","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"程设记录--多态(虚函数)","slug":"程设/figure(虚函数)","date":"2022-04-06T12:24:16.277Z","updated":"2022-04-07T05:27:02.935Z","comments":true,"path":"2022/04/06/程设/figure(虚函数)/","link":"","permalink":"http://example.com/2022/04/06/%E7%A8%8B%E8%AE%BE/figure(%E8%99%9A%E5%87%BD%E6%95%B0)/","excerpt":"","text":"There are 4 classes, Figure is the base class, both Triangle, Rectangle and Circle are all inherited from it. Figure class is like following: 1234567class FIGURE &#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()被声明为纯虚函数protected: double x_size, y_size;&#125;; You should implement Figure, Triangle, Rectange, Circle class. Sample Output 123Area of triangle is 60Area of rectangle is 120Area of circle is 706.858 figure.h 12345678class FIGURE&#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()被声明为纯虚函数protected: double x_size, y_size;&#125;; main.cpp 123456789101112131415161718192021222324252627#include &quot;Figure.h&quot;#include &quot;Triangle.h&quot;#include &quot;Rectangel.h&quot;#include &quot;Circle.h&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; TRIANGLE triangle; RECTANGLE rectangle; CIRCLE circle; // 处理三角形 triangle.set_size(15, 8); // 设置三角形的底和高 cout &lt;&lt; &quot;Area of triangle is &quot; &lt;&lt; triangle.get_area() &lt;&lt; &quot;\\n&quot;; // 处理矩形 rectangle.set_size(15, 8); // 设置矩形的长和宽 cout &lt;&lt; &quot;Area of rectangle is &quot; &lt;&lt; rectangle.get_area() &lt;&lt; &quot;\\n&quot;; // 处理圆 circle.set_size(15); // 设置圆的半径 cout &lt;&lt; &quot;Area of circle is &quot; &lt;&lt; circle.get_area() &lt;&lt; &quot;\\n&quot;; return 0;&#125; 后面是需要完成的内容 figure.cpp 12345678910111213#include&quot;Figure.h&quot;using namespace std; double FIGURE::get_area()&#123;&#125;void FIGURE::set_size(double x, double y)&#123; x_size = x; y_size = y;&#125; triangle.h 123456789101112#include&quot;Figure.h&quot;class TRIANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size / 2; &#125;&#125;; rectangle.h 123456789101112#include&quot;Figure.h&quot;class RECTANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size ; &#125;&#125;; circle.h 123456789101112#include&quot;Figure.h&quot;class CIRCLE:public FIGURE&#123;public:void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * x_size * PI; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录--实现栈类","slug":"程设/用链表实现栈类","date":"2022-04-06T08:59:06.541Z","updated":"2022-04-06T09:22:43.963Z","comments":true,"path":"2022/04/06/程设/用链表实现栈类/","link":"","permalink":"http://example.com/2022/04/06/%E7%A8%8B%E8%AE%BE/%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%B1%BB/","excerpt":"","text":"栈类 12345678910111213141516171819202122232425262728#ifndef STACK_HPP#define STACK_HPP#include &lt;stddef.h&gt;class Stack &#123; struct node &#123; int num; node* next; node() &#123; num = 0; next = NULL; &#125; node(int n, node* p = NULL) &#123; num = n; next = p; &#125; &#125;; node* data;public: Stack(); // 构造一个空栈 Stack(const Stack&amp;); // 拷贝构造函数 ~Stack(); // 注意内存回收 void push(int); // 入栈 void pop(); // 出栈 int top() const; // 查看栈顶元素，若栈为空，返回0 bool empty() const; // 判断栈是否为空 void clear(); // 清空栈&#125;;#endif 补充 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;Stack.hpp&gt;#include&lt;iostream&gt;using namespace std;Stack::Stack()&#123; data=new node;&#125;Stack::Stack(const Stack&amp; a) &#123; Stack b; for(node *i=a.data;i-&gt;next!=NULL;i=i-&gt;next) b.push(i-&gt;num); data=new node; for(;!b.empty();b.pop()) push(b.top());&#125;Stack::~Stack()&#123; clear(); delete data;&#125;void Stack:: push(int n)&#123; data=new node(n,data);&#125;// 入栈void Stack:: pop()&#123; if(empty()) return; node* temp=data; data=data-&gt;next; delete temp; &#125;// 出栈int Stack:: top() const&#123; return data-&gt;num;&#125;// 查看栈顶元素，若栈为空，返回0bool Stack:: empty() const&#123; return data-&gt;next==NULL;&#125;// 判断栈是否为空void Stack:: clear()&#123; while(!empty())&#123; pop(); &#125;&#125; 拷贝构造函数也可以这样子写 123456789101112131415161718stack:: stack(const stack &amp; a)&#123; node* p=a.data; data=new node; data-&gt;num=p-&gt;num; data-&gt;next=NULL; p=p-&gt;next; while(p!=NULL) &#123; node *s=data; while(s-&gt;next!=NULL) s=s-&gt;next; node *k=new node; s-&gt;next=k; k-&gt;num=p-&gt;num; k-&gt;next=NULL; p=p-&gt;next; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"第七章- LATCHES,FLIP-FLOPS,TIMERS(锁存器\\触发器\\定时器)","slug":"数字电路汇总/数字电路第七章(二)","date":"2022-04-06T07:46:41.576Z","updated":"2022-04-16T13:47:13.390Z","comments":true,"path":"2022/04/06/数字电路汇总/数字电路第七章(二)/","link":"","permalink":"http://example.com/2022/04/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0(%E4%BA%8C)/","excerpt":"","text":"Flip-Flop Operating Character(边沿触发器的运算特性) propagation delay time传输延迟时间 set-up time and hold time 剩余概念 最大时钟频率：触发器可靠工作的最高时钟频率 （最小）脉冲宽度：时钟（高、低时长），置一，清零 Flip-Flop application触发器应用 并行数据储存:寄存器(同步时序) 分频器(异步时序) 可以实现不断二分频 计数器 One-shot 单稳态触发器 可重复触发和不可重复触发波形 74121:不可重复触发单稳态触发器 \\(R_{INT}\\)连接在一个2KΩ的电阻上 输出脉冲宽度由电阻值(\\(R_{INT}=2kΩ和R_{EXT}\\)) \\[ t_{w}=0.7RC_{EXT} \\] 注意单位:\\(R(kΩ)\\) \\(C_{EXT}(pF)\\) \\(t_{w}(ns)\\) 74LS122可重复触发单稳态触发器 \\[ t_{w}=0.32RC_{EXT}(1+\\frac{0.7}{R}) \\] 单稳态触发器能作为定时器使用 555定时器 \\[ 脉冲宽度t_{w}=1.1R_1C_1 \\] 非稳态多谐振荡器 UTP和LTP不相同 555定时器构成多谐振荡器 \\[ 振荡频率f=\\frac{1.44}{(R_1+2R_2)C_1} \\] 输出为高电平的时间\\(t_H\\)是C1从三分之一充电到三分之二所花的时间 输出为低电平的时间\\(t_L\\)是C1从三分之二放电到三分之一所花的时间 \\[ t_{H}=0.7(R_1+R_2)C_1 \\] \\[ t_L=0.7R_2C_1 \\] 占空比 \\[ 占空比=(\\frac{R_1+R_2}{R_1+2R_2}) \\] 为了让占空比小于50%,增加一个二极管后 \\[ 占空比=(\\frac{R_1}{R_1+R_2}) \\]","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"第七章- LATCHES,FLIP-FLOPS,TIMERS(锁存器\\触发器\\定时器)","slug":"数字电路汇总/数字电路第七章","date":"2022-03-28T12:47:15.450Z","updated":"2022-04-15T13:21:31.212Z","comments":true,"path":"2022/03/28/数字电路汇总/数字电路第七章/","link":"","permalink":"http://example.com/2022/03/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"Latches 掌握知识点 S-R锁存器的操作 门控S-R锁存器 D锁存器的操作 用逻辑门补充S-R和R锁存器 74LS297A和74LS75 S-R锁存器(S-R Latches) S--set R-reset 锁存器的输出总是反相的 基本结构 真值表 波形图 application(触点抖动消除器) 74LS279 A The Gated S-R Latch 波形图 The Gated D(Data) Latches 74LS75 D LATCH Edge-Triggered Flio-Flops 掌握知识点 解释时针,边沿触发器; 锁存器和触发器的区别 通过逻辑符号定义边沿触发的触发器 正边沿触发和负边沿触发的触发器的区别 比较S-R,D,J-K边沿触发器操作以及真值表的区别 74AHC74和74HC112 S-R 三种情况 真值表 是如何产生脉冲的 利用门电路的延迟特性 D J-K 波形图 异步预置位输入和清零输入 S-R,D,K-K都是同步输入 PRE和CLR的输入会直接改变输出,而不受前面电路影响 74AHC74 双D触发器 74HC112 双J-K触发器 巩固","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"程设记录(十四)--Overload simple clock","slug":"程设/Overload simple clock","date":"2022-03-23T12:40:55.114Z","updated":"2022-03-23T14:05:36.719Z","comments":true,"path":"2022/03/23/程设/Overload simple clock/","link":"","permalink":"http://example.com/2022/03/23/%E7%A8%8B%E8%AE%BE/Overload%20simple%20clock/","excerpt":"","text":"题目所给代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;SimpleClock.h&quot;int main() &#123; Clock clock1; cin &gt;&gt; clock1; cout &lt;&lt; &quot;cin &gt;&gt; clock1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl &lt;&lt; endl; Clock clock2(clock1); cout &lt;&lt; &quot;clock2(clock1)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock2 ---- &quot; &lt;&lt; clock2 &lt;&lt; endl &lt;&lt; endl; Clock clock3 = clock1 ++; Clock clock4 = ++ clock2; cout &lt;&lt; &quot;clock3 = clock1 ++&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock4 = ++ clock2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock2 ---- &quot; &lt;&lt; clock2 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock3 ---- &quot; &lt;&lt; clock3 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock4 ---- &quot; &lt;&lt; clock4 &lt;&lt; endl &lt;&lt; endl; Clock clock5(11, 45, 14); Clock clock6 = clock1 + clock5; cout &lt;&lt; &quot;clock5(11, 45, 14)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock6 = clock1 + clock5&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock5 ---- &quot; &lt;&lt; clock5 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock6 ---- &quot; &lt;&lt; clock6 &lt;&lt; endl &lt;&lt; endl; Clock clock7; clock7 += clock5; clock7 += clock6; cout &lt;&lt; &quot;clock7()&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock7 += clock5&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock7 += clock6&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock5 ---- &quot; &lt;&lt; clock5 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock6 ---- &quot; &lt;&lt; clock6 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock7 ---- &quot; &lt;&lt; clock7 &lt;&lt; endl; return 0;&#125; simpleclock.h 123456789101112131415161718192021222324252627282930313233#ifndef SIMPLECLOCK_H#define SIMPLECLOCK_H#include &lt;iostream&gt;using namespace std;class Clock &#123;private: int hour; int minute; int second; public: // Implemented. Clock(): hour(0), minute(0), second(0) &#123;&#125; Clock( int hour_, int minute_, int second_): hour(hour_), minute(minute_), second(second_) &#123;&#125; // Not implemented. Clock&amp; operator += (const Clock &amp;right); Clock operator + (const Clock &amp;right) const; Clock&amp; operator ++ (); Clock operator ++ (int) ; friend istream &amp; operator &gt;&gt; (istream &amp;is, Clock &amp;object); friend ostream &amp; operator &lt;&lt; (ostream &amp;os, const Clock &amp;object);&#125;;#endif 所写代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Clock Clock::operator + (const Clock &amp;right) const &#123; Clock c; // Deal with hour. c.hour = (this-&gt;hour + right.hour) % 24; // Deal with minute. c.hour = (c.hour + (this-&gt;minute + right.minute) / 60) % 24; c.minute = (this-&gt;minute + right.minute) % 60; // Deal with second. c.hour = (c.hour + (c.minute + (this-&gt;second + right.second) / 60) / 60) % 24; c.minute = (c.minute + (this-&gt;second + right.second) / 60) % 60; c.second = (this-&gt;second + right.second) % 60; return c;&#125;Clock&amp; Clock::operator += (const Clock &amp;right) &#123; // Deal with hour. this-&gt;hour = (this-&gt;hour + right.hour) % 24; // Deal with minute. this-&gt;hour = (this-&gt;hour + (this-&gt;minute + right.minute) / 60) % 24; this-&gt;minute = (this-&gt;minute + right.minute) % 60; // Deal with second. this-&gt;hour = (this-&gt;hour + (this-&gt;minute + (this-&gt;second + right.second) / 60) / 60) % 24; this-&gt;minute = (this-&gt;minute + (this-&gt;second + right.second) / 60) % 60; this-&gt;second = (this-&gt;second + right.second) % 60; return *this;&#125;Clock &amp; Clock::operator ++ () &#123; Clock adder(0, 0, 1); *this += adder; return *this;&#125;Clock Clock::operator ++ (int) &#123; Clock c(*this); ++ *this; return c;&#125;istream &amp; operator &gt;&gt; (istream &amp;is, Clock &amp;object) &#123; int hour, minute, second; is &gt;&gt; hour &gt;&gt; minute &gt;&gt; second; hour %= 24; hour = (hour + minute / 60) % 24; minute %= 60; hour = (hour + (minute + second / 60) / 60) % 24; minute = (minute + second / 60) % 60; second %= 60; object.hour = hour; object.minute = minute; object.second = second; return is;&#125;ostream &amp; operator &lt;&lt; (ostream &amp;os, const Clock &amp;object) &#123; os &lt;&lt; object.hour &lt;&lt; &quot;:&quot; &lt;&lt; object.minute &lt;&lt; &quot;:&quot; &lt;&lt; object.second; return os;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十三)--virtual class","slug":"程设/virtual class","date":"2022-03-23T12:18:35.991Z","updated":"2022-03-23T12:40:54.109Z","comments":true,"path":"2022/03/23/程设/virtual class/","link":"","permalink":"http://example.com/2022/03/23/%E7%A8%8B%E8%AE%BE/virtual%20class/","excerpt":"","text":"最后这些类的关系变成了一个圈 vitural的应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;cstring&gt;#include &lt;fstream&gt;using namespace std;#include &quot;source.h&quot;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); int n; cin&gt;&gt;n; for (int i=0;i&lt;n;i++) &#123; char name[20],job[20],dep[20],major[20],prof[20]; int age; cin&gt;&gt;name&gt;&gt;age&gt;&gt;job&gt;&gt;dep&gt;&gt;major&gt;&gt;prof; chairman man; man.setname(name); man.setage(age); man.setjob(job); man.setdep(dep); man.setmajor(major); man.setprof(prof); cout&lt;&lt;&quot;name: &quot;&lt;&lt;man.getname()&lt;&lt;&quot; age: &quot;&lt;&lt;man.getage()&lt;&lt;&quot; dep: &quot;&lt;&lt;man.getdep() &lt;&lt;&quot; job: &quot;&lt;&lt;man.getjob()&lt;&lt;endl; cout&lt;&lt;&quot;prof: &quot;&lt;&lt;man.getprof()&lt;&lt;&quot; major: &quot;&lt;&lt;man.getmajor()&lt;&lt;endl; &#125; return 0;&#125;//所需完成的代码#include &lt;iostream&gt;#include &lt;cstring&gt;class base &#123; char name[20]; int age; public: base() &#123;&#125; void setname(char arr[]) &#123; strcpy(name, arr); &#125;; void setage(int age) &#123; this-&gt;age = age; &#125;; char* getname() &#123; return name; &#125;; int getage() &#123; return age; &#125;;&#125;;class leader: virtual public base &#123; private: char job[20]; char department[20]; public: void setjob(char arr[]) &#123; strcpy(job, arr); &#125;; void setdep(char arr[]) &#123; strcpy(department, arr); &#125;; char * getjob() &#123; return job; &#125; char * getdep() &#123; return department; &#125;&#125;;class engineer: virtual public base &#123; private: char major[20]; char profession[20]; public: void setmajor(char arr[]) &#123; strcpy(major, arr); &#125;; void setprof(char arr[]) &#123; strcpy(profession, arr); &#125;; char * getmajor() &#123; return major; &#125; char * getprof() &#123; return profession; &#125;&#125;;class chairman: public leader, public engineer &#123;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十二)--多继承","slug":"程设/多继承","date":"2022-03-23T11:38:26.105Z","updated":"2022-05-08T08:31:55.408Z","comments":true,"path":"2022/03/23/程设/多继承/","link":"","permalink":"http://example.com/2022/03/23/%E7%A8%8B%E8%AE%BE/%E5%A4%9A%E7%BB%A7%E6%89%BF/","excerpt":"","text":"Description 写作和赛车是韩少的两大最爱，但在生活的不同时期还是要有所取舍。 韩少的原则是： 周末：写作优先； 周内：赛车优先； 这些可以提现在Weekend和Workday的对象构造中，类继承关系如下： 123Racing Writing \\ / Weekend/Workday 其中Racing和Writing如下： 12345678910111213141516171819class Writing &#123;public: Writing() &#123; cout&lt;&lt;&quot;Writing constructor&quot;&lt;&lt;endl; &#125; ~Writing()&#123; cout&lt;&lt;&quot;~Writing&quot;&lt;&lt;endl; &#125;&#125;;class Racing &#123;public: Racing()&#123; cout&lt;&lt;&quot;Racing constructor&quot;&lt;&lt;endl; &#125; ~Racing()&#123; cout&lt;&lt;&quot;~Racing&quot;&lt;&lt;endl; &#125;&#125;; 主函数如下： 1234int main() &#123; Weekend end; Workday day;&#125; Sample Output 123456789101112Writing constructorRacing constructorWeekend constructorRacing constructorWriting constructorWorkday constructor~Workday~Writing~Racing~Weekend~Racing~Writing Hint 提交main函数之外的所有类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;class Writing &#123;public: Writing() &#123; cout&lt;&lt;&quot;Writing constructor&quot;&lt;&lt;endl; &#125; ~Writing()&#123; cout&lt;&lt;&quot;~Writing&quot;&lt;&lt;endl; &#125;&#125;;class Racing &#123;public: Racing()&#123; cout&lt;&lt;&quot;Racing constructor&quot;&lt;&lt;endl; &#125; ~Racing()&#123; cout&lt;&lt;&quot;~Racing&quot;&lt;&lt;endl; &#125;&#125;;class Weekend:public Writing,public Racing&#123;public: Weekend()&#123; cout&lt;&lt;&quot;Weekend constructor&quot;&lt;&lt;endl; &#125; ~Weekend()&#123; cout&lt;&lt;&quot;~Weekend&quot;&lt;&lt;endl; &#125;&#125;; class Workday: public Racing,public Writing&#123; public: Workday()&#123; cout&lt;&lt;&quot;Workday constructor&quot; &lt;&lt; endl; &#125; ~Workday()&#123; cout&lt;&lt;&quot;~Workday&quot; &lt;&lt; endl; &#125;&#125;; main.cpp 123456int main() &#123; Weekend end; Workday day;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"第六章-Functions of Combinational Logic","slug":"数字电路汇总/数字电路第六章","date":"2022-03-21T06:11:36.947Z","updated":"2022-04-14T12:53:42.440Z","comments":true,"path":"2022/03/21/数字电路汇总/数字电路第六章/","link":"","permalink":"http://example.com/2022/03/21/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"Basic Adders The Half-Adder (半加器) \\[ 0+0=0 \\] \\[ 0+1=1 \\] \\[ 1+0=1\\\\ \\] \\[ 1+1+0\\\\ \\] \\(C_{out}\\)是输出进位,Sum是当前位 Full-adder (全加器) 两个半加器组成一个全加器 全加器内部结构 Parallel Binary Adders 完成多位相加的操作 两位相加 三位数字相加(101和011) 全加器组合 投票系统 Ripple Carry versus Look-Ahead Carry Adders(异步进位和超前进位) Ripple carry adder: the carry output of each fulladder is connected to the carry input of the next higher-order stage. – Time delay The look-ahead carry adder: anticipates the output carry of each stage, and based on the inputs, produces the output carry by either carry generation or carry propagation (进位生成或进位传输) The output carry for each full-adder stage is dependent only on the initial input carry (\\(C_{in1}\\)), the \\(C_g\\) and \\(C_p\\) functions of that stage, and the \\(C_g\\) and \\(C_p\\) functions of the preceding stages. 三级延迟 Comparators 同或门或者异或门实现 两位数比较 不相等的情况 判断大于小于 74HC85 四个比特的比较器 74HC85 也可以级联成进行八个比特位比较 最低位的输入等号一定要为高电平,大于和小于输入一定要为低电平 Decoders 译码器就相当于将输入和输出建立映射关系,一一对应 二进制译码门 如果要译四位,那么需要16个译码门 十六选一 四位译码器 74HC154(十六选一译码器) 使用74HC154进行5位数的译码 BCD译码门 低电平为有效输出 74HC42(bcd转换位十进制) 74LS47(BCD到7段) Encoders 十进制到BCD Logic symbol for a decimal-to-BCD encoder 逻辑电路 74HC147 decimal-to-BCD priority encoder 74LS148 8-line-to-3-line encoder EI Enable input (active LOW) EO Enable output (LOW when EI is LOW and none active inputs) GS Output for expansion (LOW when EI is LOW and any of the inputs is active) Multiplexers(Data Selectors) 举例 74LS151 8-input data selector/multiplexer Use 74LS151s and any other logic necessary to multiplex 16 data lines onto a single data-output line 重要例子(考试警告) Demultiplexers(多路分配器) 74HC154多路分配器 Parity Generators/Checkers 74LS280(9位奇偶校验器/发生器)","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"第五章-combination logic analysis","slug":"数字电路汇总/数字电路第五章","date":"2022-03-21T06:11:22.472Z","updated":"2022-03-21T06:57:30.751Z","comments":true,"path":"2022/03/21/数字电路汇总/数字电路第五章/","link":"","permalink":"http://example.com/2022/03/21/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"","text":"Basic combinational logic circuits 与或逻辑(AND-OR Logic) SOP expressions can be implemented with An AND gate for each product term One OR gate for summing all of the product terms X= AB+ BC +AC 与或非逻辑(AND-OR-Invert Logic ) SOP can be implemented with AND-OR logic directly POS expressions can be implemented with AND-OR-Invert logic 异或逻辑(Exclusive -OR Logic) 同或逻辑(Exclusive -NOR Logic) Implementing Combinational Logic 布尔表达式转换为逻辑电路 真值表转换为逻辑电路 The Universal Property of NAND and NOR Gates The NAND Gate as a Universal Logic Element Be used to produce the NOT, the AND, the OR, and the NOR functions. The NOR gate as a universal logic element Be used to produce the NOT, the AND, the OR, and the NAND functions. Combinational Logic Using NAND and NOR Gates Logic Circuit Operation with Pulse Waveform 先写出布尔逻辑表达式,然后化简,最后画波形图 总结 Basic Combinational Logic Circuits Implementing Combinational Logic From a Boolean expression to a Logic Circuit From a Truth Table to a Logic Circuit The Universal Property of NAND and NOR Gates Logic Circuit Operation with Pulse Waveform Inputs How to design a combinational Logic?","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"离散数学--一阶逻辑公式的语法和语义","slug":"离散数学/一阶逻辑公式的语法和语义","date":"2022-03-19T14:48:54.492Z","updated":"2022-03-20T03:23:23.383Z","comments":true,"path":"2022/03/19/离散数学/一阶逻辑公式的语法和语义/","link":"","permalink":"http://example.com/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E5%85%AC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89/","excerpt":"","text":"•能自己给出一组一阶逻辑公式的解释和个体变量指派函数 •能在给定的解释和个体变量指派函数时确定一个公式的真值 •能在论域有限时，正确使用类似等值演算的形式确定量词公式的真值 •能判断一个一阶逻辑公式是否是命题逻辑公式的替换实例 •能判断一个一阶逻辑公式是否是永真式、矛盾式还是非永真的可满足式，并说明理由 学会画语法树 找出子公式 找出量词的辖域,以及每个个体变量符号是指示变量,约束出现还是自由出现,并说明每个个体变量是公式的自由变量还是约束变量. 对约束变量改名 如何解释 确定一阶逻辑公式的真值 类似等值演算过程! 命题逻辑公式的替换实例 判断一阶逻辑公式是永真式矛盾式还是可满足式","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"离散数学--命题逻辑的应用","slug":"离散数学/命题逻辑的应用","date":"2022-03-19T14:40:23.367Z","updated":"2022-03-19T14:48:44.476Z","comments":true,"path":"2022/03/19/离散数学/命题逻辑的应用/","link":"","permalink":"http://example.com/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"自然语言命题的符号化 判断原子命题和复合命题 判断复合命题和原子命题 条件命题的符号化 条件命题的符号化 普通逻辑问题的符号化分析 符号化下面的推理，并构造论证验证其有效性 如果小王来，则小张和小李中恰好有一人来。如果小张来，则小赵就不来。所以，如果小赵来了，但小李没来，则小王也没来。","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"离散数学--命题逻辑的推理理论","slug":"离散数学/命题逻辑的推理理论","date":"2022-03-19T14:22:02.818Z","updated":"2022-03-19T14:38:34.458Z","comments":true,"path":"2022/03/19/离散数学/命题逻辑的推理理论/","link":"","permalink":"http://example.com/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E6%8E%A8%E7%90%86%E7%90%86%E8%AE%BA/","excerpt":"","text":"自然推理系统的推理规则 例题 附加前提法 验证该公式的有效性? \\[ p \\wedge q \\rightarrow s \\vee r, q \\rightarrow p, r \\rightarrow s \\Rightarrow q \\rightarrow s \\] 验证结论为蕴涵式的推理的有效性需要使用附加前提法 将结论中的蕴涵式的前件作为附加的前提一起来推出它的后件 即 将q也作为附加前提,与其他条件结合,共同推出条件s 反证法 例题","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"程设记录(十一)--Virtual World","slug":"程设/Virtual World","date":"2022-03-16T11:44:43.454Z","updated":"2022-03-18T00:53:16.819Z","comments":true,"path":"2022/03/16/程设/Virtual World/","link":"","permalink":"http://example.com/2022/03/16/%E7%A8%8B%E8%AE%BE/Virtual%20World/","excerpt":"","text":"所给的测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116using namespace std; void test_1() &#123; person mike, jack, lily, carson, sucie; group school(0), family_1(1), family_2(1); // make group (act as a society) school.addMember(mike); school.addMember(jack); school.addMember(lily); family_1.addMember(mike); family_1.addMember(carson); family_2.addMember(jack); family_2.addMember(lily); family_2.addMember(sucie); // construct relationship in the society school.makeFriend(mike, jack); school.makeFriend(mike, lily); // display the society cout &lt;&lt; &quot;\\n------ SCHOOL -----\\n&quot;; school.displayGroup(); cout &lt;&lt; &quot;\\n------ FAMILY_1 -----\\n&quot;; family_1.displayGroup(); cout &lt;&lt; &quot;\\n------ FAMILY_2 -----\\n&quot;; family_2.displayGroup();&#125; void test_2() &#123; person Baidu, Alibaba, Tencent, NTES, Kingsoft_Antivirus, _360safe; group BAT(1), ECommerce(1), Security(1); // make group (act as a society) BAT.addMember(Baidu); BAT.addMember(Alibaba); BAT.addMember(Tencent); ECommerce.addMember(Baidu); ECommerce.addMember(Alibaba); ECommerce.addMember(Tencent); ECommerce.addMember(NTES); Security.addMember(Kingsoft_Antivirus); Security.addMember(_360safe); // display the society cout &lt;&lt; &quot;\\n------ BAT -----\\n&quot;; BAT.displayGroup(); cout &lt;&lt; &quot;\\n------ ECommerce -----\\n&quot;; ECommerce.displayGroup(); cout &lt;&lt; &quot;\\n------ Security -----\\n&quot;; Security.displayGroup();&#125; void test_3() &#123; person p0, p1, p2, p3, p4; group g0(0), g1(0), g2(1); // make group (act as a society) g0.addMember(p0); g0.addMember(p1); g0.addMember(p2); g1.addMember(p0); g1.addMember(p3); g2.addMember(p3); g2.addMember(p4); // construct relationship in the society g1.makeFriend(p0, p3); g2.breakRelation(p3, p4); g0.deleteMember(p2); // display the society cout &lt;&lt; &quot;\\n------ G0 -----\\n&quot;; g0.displayGroup(); cout &lt;&lt; &quot;\\n------ G1 -----\\n&quot;; g1.displayGroup(); cout &lt;&lt; &quot;\\n------ G2 -----\\n&quot;; g2.displayGroup();&#125; void test_4() &#123; person p[50]; group g0(0), g1(1); int p_count; cin &gt;&gt; p_count; // make group (act as a society) for (int i = 0; i &lt; p_count/2; i++) g0.addMember(p[i]); for (int i = p_count/2; i &lt; p_count; i++) g1.addMember(p[i]); // construct relationship in the society for (int i = 0; i &lt; p_count/5; i += 2) g0.makeFriend(p[i], p[i+1]); for (int i = p_count/2; i &lt; p_count*3/4-1; i += 2) g1.breakRelation(p[i], p[i+1]); for (int i = p_count/4; i &lt; p_count/2; i++) g0.deleteMember(p[i]); for (int i = p_count*3/4; i &lt; p_count; i++) g1.deleteMember(p[i]); // display the society cout &lt;&lt; &quot;\\n------ G0 -----\\n&quot;; g0.displayGroup(); cout &lt;&lt; &quot;\\n------ G1 -----\\n&quot;; g1.displayGroup();&#125; int main() &#123; int test_id; cin &gt;&gt; test_id; switch (test_id) &#123; case 1: test_1(); break; case 2: test_2(); break; case 3: test_3(); break; case 4: test_4(); break; default: cout &lt;&lt; &quot;wrong input\\n&quot;; &#125; return 0;&#125; 所完成的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;iostream&gt;using namespace std;class person&#123;public: person()&#123; id=total_person; total_person++; friend_num=0; &#125; friend class group; bool addFriend(int a)&#123; for(int i=0;i&lt;friend_num;i++)&#123; if(friends[i]==a) return false; &#125; friends[friend_num]=a; friend_num++; return true; &#125; bool deleteFriend(int a)&#123; for(int i=0;i&lt;friend_num;i++)&#123; if(friends[i]==a)&#123; int j; for(j=i;j&lt;friend_num-1;j++)&#123; friends[j]=friends[j+1]; &#125; friends[j]=-1; friend_num--; return true; &#125; &#125; return false; &#125;//private: int id; int friend_num; static int total_person; int friends[100];&#125;; int person:: total_person=0; class group&#123;public: person persons[100]; int group_number; int para;public: group(int a)&#123; para=a; group_number=0; &#125; void displayGroup()&#123; for(int i=0;i&lt;group_number;i++)&#123; cout&lt;&lt;&quot;Person_&quot;&lt;&lt;persons[i].id&lt;&lt;&quot;: &quot;; if(persons[i].friend_num!=0)&#123; for(int j=0;j&lt;persons[i].friend_num-1;j++)&#123; cout&lt;&lt;persons[i].friends[j]&lt;&lt;&quot;,&quot;; &#125; cout&lt;&lt;persons[i].friends[persons[i].friend_num-1]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;null&quot;&lt;&lt;endl; &#125; &#125; &#125; bool addMember(person &amp;p)&#123; if(para==1)&#123; persons[group_number++]=p; for(int i=0;i&lt;group_number-1;i++)&#123; makeFriend(persons[group_number-1],persons[i]); &#125; &#125;else&#123; persons[group_number++]=p; &#125; &#125; bool deleteMember(person &amp;p)&#123; for(int i=0;i&lt;group_number;i++)&#123; persons[i].deleteFriend(p.id); if(persons[i].id==p.id)&#123; for(int j=i;j&lt;group_number-1;j++)&#123; persons[j]=persons[j+1]; &#125; &#125; &#125; group_number--; return true; &#125; bool makeFriend(person &amp;p1, person &amp;p2)&#123; int m=-1,n=-1; for(int i=0;i&lt;group_number;i++)&#123; if(p1.id==persons[i].id) m=i; if(p2.id==persons[i].id) n=i; &#125; if(m==-1||n==-1)return false; persons[m].friends[persons[m].friend_num++]=p2.id; persons[n].friends[persons[n].friend_num++]=p1.id; return true; &#125; bool breakRelation(person &amp;p1, person &amp;p2)&#123; int m=-1,n=-1; for(int i=0;i&lt;group_number;i++)&#123; if(p1.id==persons[i].id) m=i; if(p2.id==persons[i].id) n=i; &#125; for(int i=0;i&lt;p1.friend_num;i++)&#123; if(persons[m].friends[i]==p2.id)&#123; int j; for(j=i;j&lt;p1.friend_num-1;j++)&#123; persons[m].friends[j]=persons[m].friends[j+1]; &#125; persons[m].friends[j]=-1; &#125; &#125; persons[m].friend_num--; for(int i=0;i&lt;p2.friend_num;i++)&#123; if(persons[n].friends[i]==p1.id)&#123; int j; for(j=i;j&lt;p2.friend_num-1;j++)&#123; persons[n].friends[j]=persons[n].friends[j+1]; &#125; persons[n].friends[j]=-1; return true; &#125; &#125; persons[n].friend_num--; return false; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(十)--Constructor and Inheritance","slug":"程设/继承的顺序","date":"2022-03-13T08:32:09.137Z","updated":"2022-04-12T06:01:45.785Z","comments":true,"path":"2022/03/13/程设/继承的顺序/","link":"","permalink":"http://example.com/2022/03/13/%E7%A8%8B%E8%AE%BE/%E7%BB%A7%E6%89%BF%E7%9A%84%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"完成类B 12345678910111213class B: public A &#123; public: B(int x, int y): A(x), b(y) &#123;&#125;; void show() &#123; A::show(); cout&lt;&lt;&quot;b=&quot; &lt;&lt; b &lt;&lt; endl; &#125;; private: int b;&#125;; 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class A&#123;public: A(int a0):a(a0) &#123;&#125; void show() &#123; cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; &#125;private: int a;&#125;;#include &quot;source.h&quot;int main()&#123;// freopen(&quot;test01.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;test01.out&quot;, &quot;w&quot;, stdout); B b(10,15); b.show(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(九)--animal and human","slug":"程设/animal and human","date":"2022-03-13T08:05:40.835Z","updated":"2022-03-13T08:32:33.247Z","comments":true,"path":"2022/03/13/程设/animal and human/","link":"","permalink":"http://example.com/2022/03/13/%E7%A8%8B%E8%AE%BE/animal%20and%20human/","excerpt":"","text":"题目所给代码 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;animal.h&quot;#include &quot;human.h&quot;int main() &#123; std::string s, n; int e; std::cin &gt;&gt; s &gt;&gt; e &gt;&gt; n; animal * p = new animal(s, e); p-&gt;print_eyes(); delete p; human h(n); p = &amp;h; p-&gt;print_eyes(); const human &amp; q = h; q.greeting(); return 0;&#125; 自己完成的代码 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; class animal&#123;private: string _species; int _eyes;public: animal(string a,int b):_species(a),_eyes(b)&#123;&#125; void print_eyes()&#123; cout&lt;&lt;_species&lt;&lt;&quot; has &quot;&lt;&lt;_eyes&lt;&lt;&quot; eyes.&quot;&lt;&lt;endl; &#125; &#125;;class human: public animal&#123;private: string _name;public: human(string a):animal(&quot;Human&quot;,2)&#123; _name=a; &#125; void greeting()const&#123; cout&lt;&lt;&quot;Hello, I&#x27;m &quot;&lt;&lt;_name&lt;&lt;endl; &#125;&#125;; 测试 输入 1234Spider8Citron 输出 1234Spider has 8 eyes.Human has 2 eyes.Hello, I&#x27;m Citron.","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(八)--继承 red car","slug":"程设/继承car","date":"2022-03-13T06:42:18.853Z","updated":"2022-03-13T07:28:23.206Z","comments":true,"path":"2022/03/13/程设/继承car/","link":"","permalink":"http://example.com/2022/03/13/%E7%A8%8B%E8%AE%BE/%E7%BB%A7%E6%89%BFcar/","excerpt":"","text":"sample output 123456789101112131415//--- build car ---Construct a car//--- build wheel ---Construct a wheel//--- build red car ---Construct a carConstruct a wheelConstruct a wheelConstruct a wheelConstruct a wheelConstruct a red car Red Car 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class Car&#123;public: Car()&#123; cout&lt;&lt;&quot;Construct a car&quot;&lt;&lt;endl; &#125;&#125;; class Wheel&#123;public: Wheel()&#123; cout&lt;&lt;&quot;Construct a wheel&quot;&lt;&lt;endl; &#125;&#125;;class RedCar: public Car&#123; Wheel a,s,d,f;public: RedCar():Car()&#123; cout&lt;&lt;&quot;Construct a red car&quot;&lt;&lt;endl; &#125;&#125;;int main() &#123; cout &lt;&lt; &quot;--- build car ---&quot; &lt;&lt; endl; Car car; cout &lt;&lt; endl; cout &lt;&lt; &quot;--- build wheel ---&quot; &lt;&lt; endl; Wheel wheel; cout &lt;&lt; endl; cout &lt;&lt; &quot;--- build red car ---&quot; &lt;&lt; endl; RedCar redcar; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"第四章-Boolean Algebra and Logic Simplification  (二)","slug":"数字电路汇总/数字电路第四章(二)","date":"2022-03-13T06:10:42.920Z","updated":"2022-03-17T08:42:35.094Z","comments":true,"path":"2022/03/13/数字电路汇总/数字电路第四章(二)/","link":"","permalink":"http://example.com/2022/03/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E4%BA%8C)/","excerpt":"","text":"卡诺图化简重点 传统方法化简 这种化简方法还是有些复杂 卡诺图化简 Karnaugh Map A systematic method for simplifying Boolean expressions Produce the simplest SOP or POS expression Presents all of the possible values of input variables An array of cells Each cell represents a binary value of the input variables Adjacency in position equivalents to adjacency in Boolean algebra 相邻单元格之间只能有一个位是不同的(格雷码) 以sop举例 圈\\(2^n\\)数目的格子,比如说能圈1、４、８个格子,留下相同的项,比如C图的左上角那个四个格子,四个项则化简为\\(\\bar A\\bar C\\) Group the ‘1’s Maximize the size of the groups Minimize the number of groups Rules A group must contain \\(2^n\\) cells Each cell must be adjacent to one or more cells in that group Include ‘1’s as much as possible Each ‘1’ on the map must be included at least one group Cell with ‘1’ can be included into more than one group 关于中间那条线轴对称的元素也是位置相邻. 5个变量的话也可以画两个四个变量的卡诺图,然后叠起来,上下相邻的元素也是位置相邻","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"程设记录(七)--继承","slug":"程设/继承各种类的顺序","date":"2022-03-11T01:14:31.531Z","updated":"2022-03-13T06:43:21.958Z","comments":true,"path":"2022/03/11/程设/继承各种类的顺序/","link":"","permalink":"http://example.com/2022/03/11/%E7%A8%8B%E8%AE%BE/%E7%BB%A7%E6%89%BF%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"这题关于继承的时候各种类的创建和销毁顺序 1234567891011121314151617181920212223 #include &lt;iostream&gt;#include &quot;Inheritance.hpp&quot;using std::cin;using std::cout;using std::endl;using std::string;int main() &#123; int token; cin &gt;&gt; token; cout &lt;&lt; &quot;test token: &quot; &lt;&lt; token &lt;&lt; endl; cout &lt;&lt; &quot;\\ncreat base A&quot; &lt;&lt; endl; baseA ba; cout &lt;&lt; &quot;\\ncreat base B&quot; &lt;&lt; endl; baseB bb; cout &lt;&lt; &quot;\\ncreat derived A&quot; &lt;&lt; endl; derivedA da; cout &lt;&lt; &quot;\\ncreat derived B&quot; &lt;&lt; endl; derivedB db; cout &lt;&lt; &quot;\\ncreat C&quot; &lt;&lt; endl; C c; cout &lt;&lt; &quot;\\ndestructor&quot; &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132 #include &quot;Inheritance.hpp&quot; baseA::baseA() &#123; cout &lt;&lt; &quot;base A&quot; &lt;&lt; endl;&#125; baseA::~baseA() &#123; cout &lt;&lt; &quot;~ base A&quot; &lt;&lt; endl;&#125; baseB::baseB() &#123; cout &lt;&lt; &quot;base B&quot; &lt;&lt; endl;&#125; baseB::~baseB() &#123; cout &lt;&lt; &quot;~ base B&quot; &lt;&lt; endl;&#125; derivedA::derivedA() &#123; cout &lt;&lt; &quot;derived A&quot; &lt;&lt; endl;&#125; derivedA::~derivedA() &#123; cout &lt;&lt; &quot;~ derived A&quot; &lt;&lt; endl;&#125; derivedB::derivedB() &#123; cout &lt;&lt; &quot;derived B&quot; &lt;&lt; endl;&#125; derivedB::~derivedB() &#123; cout &lt;&lt; &quot;~ derived B&quot; &lt;&lt; endl;&#125; C::C() &#123; cout &lt;&lt; &quot;C&quot; &lt;&lt; endl;&#125; C::~C() &#123; cout &lt;&lt; &quot;~ C&quot; &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243\\\\所需输出test token: 6590creat base Abase Acreat base Bbase Bcreat derived Abase Aderived Acreat derived Bbase Abase Bderived Bcreat Cbase Aderived Abase Abase Bderived BCdestructor~ C~ derived B~ base B~ base A~ derived A~ base A~ derived B~ base B~ base A~ derived A~ base A~ base B~ base A 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class baseA&#123;public: baseA(); ~baseA();&#125;;class baseB&#123;public: baseB(); ~baseB();&#125;;class derivedA:public baseA&#123;public: derivedA(); ~derivedA();&#125;;class derivedB:public baseA, public baseB&#123;public: derivedB(); ~derivedB();&#125;;class C:public derivedA, public derivedB&#123;public: C(); ~C();&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(六)--一道巨巨长的题目","slug":"程设/分数(较难)","date":"2022-03-09T12:25:22.126Z","updated":"2022-03-11T01:22:52.709Z","comments":true,"path":"2022/03/09/程设/分数(较难)/","link":"","permalink":"http://example.com/2022/03/09/%E7%A8%8B%E8%AE%BE/%E5%88%86%E6%95%B0(%E8%BE%83%E9%9A%BE)/","excerpt":"","text":"两百五十行代码给我写麻了 题目所给代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef RATIONAL_H_#define RATIONAL_H_#include &lt;string&gt;using namespace std;class Rational &#123; public: Rational(); Rational(long numerator, long denominator); long getNumerator(); long getDenominator(); Rational add(Rational &amp;secondRational); Rational subtract(Rational &amp;secondRational); Rational multiply(Rational &amp;secondRational); Rational divide(Rational &amp;secondRational); int compareTo(Rational &amp;secondRational); bool equals(Rational &amp;secondRational); int intValue(); //Returns the numerator/denominator double doubleValue(); //Returns 1.0*numberator/denominator string toString(); bool operator&lt;(Rational &amp;secondRational); bool operator&lt;=(Rational &amp;secondRational); bool operator&gt;(Rational &amp;secondRational); bool operator&gt;=(Rational &amp;secondRational); bool operator!=(Rational &amp;secondRational); bool operator==(Rational &amp;secondRational); Rational operator+(Rational &amp;secondRational); Rational operator-(Rational &amp;secondRational); Rational operator*(Rational &amp;secondRational); Rational operator/(Rational &amp;secondRational); Rational operator+=(Rational &amp;secondRational); Rational operator-=(Rational &amp;secondRational); Rational operator*=(Rational &amp;secondRational); Rational operator/=(Rational &amp;secondRational); Rational operator++(); Rational operator--(); Rational operator++(int dummy); Rational operator--(int dummy); Rational operator+(); Rational operator-(); long&amp; operator[] (int ); friend ostream &amp;operator&lt;&lt;(ostream &amp;stream, Rational &amp;rational); friend istream &amp;operator&gt;&gt;(istream &amp;stream, Rational &amp;rational); operator double(); private: long numerator; //﹞?℅車. long denominator; //﹞???㏒?2??邦?a0. static long gcd(long n, long d);&#125;;#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;string&gt;#include &quot;Rational.h&quot;using namespace std;int main()&#123; // Create and initialize two rational numbers r1 and r2. Rational r1(3, 2); Rational r2(2, 3); // Test relational operators cout &lt;&lt; r1 &lt;&lt; &quot; &gt; &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &gt; r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &gt;= r1) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; &lt; &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &lt; r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &lt;= r1) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; == &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 == r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; == &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 == r1) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; != &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 != r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; != &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 != r1) &lt;&lt; endl; // Test toString, add, substract, multiply, and divide operators cout &lt;&lt; r1 &lt;&lt; &quot; + &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 + r2 &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; - &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 - r2 &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; * &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 * r2 &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; / &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 / r2 &lt;&lt; endl; // Test shorthand operators Rational r3(1, 2); r3 += r1; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; r3 -= r1; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; // Test function operator [] Rational r4(1, 2); r4[0] = 3; r4[1] = 4; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; // Test function operators for // prefix ++ and -- // postfix ++ and -- r3 = r4++; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; r3 = r4--; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; r3 = ++r4; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; r3 = --r4; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; // Test function operator for conversion cout &lt;&lt; &quot;1 + &quot; &lt;&lt; r4 &lt;&lt; &quot; is &quot; &lt;&lt; (1 + r4) &lt;&lt; endl; return 0;&#125; 完成的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179long Rational:: gcd(long n,long d)&#123; for(int i=min(n,d);i&gt;=2;i--)&#123; if(n%i==0&amp;&amp;d%i) return i; &#125; return 1;&#125;Rational:: Rational()&#123; numerator=0; denominator=1;&#125;Rational:: Rational(long a,long b):numerator(a),denominator(b)&#123;&#125;long Rational::getNumerator()&#123;return numerator;&#125;long Rational::getDenominator()&#123;return denominator;&#125;Rational Rational::add(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator+secondRational.numerator*denominator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;Rational Rational:: subtract(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator-secondRational.numerator*denominator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;Rational Rational::multiply(Rational &amp;secondRational)&#123; long a=numerator*secondRational.numerator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;Rational Rational:: divide(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator; long b=denominator*secondRational.numerator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;int Rational::compareTo(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator-secondRational.numerator*denominator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); if(a&gt;0) return 1; if(a==0) return 0; if(a&lt;0) return -1;&#125;bool Rational:: equals(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator-secondRational.numerator*denominator; if(a==0) return true; else return false;&#125;int Rational::intValue()&#123; return numerator/denominator;&#125;double Rational:: doubleValue()&#123; return 1.0*numerator/denominator;&#125;bool Rational:: operator==(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==0) return true; else return false;&#125;bool Rational:: operator!=(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==0) return false; else return true;&#125;bool Rational:: operator&gt;(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==1) return true; else return false;&#125;bool Rational:: operator&lt;(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==-1) return true; else return false;&#125;bool Rational:: operator&gt;=(Rational &amp;secondRational)&#123; if(compareTo(secondRational) &gt;=0) return true; else return false;&#125;bool Rational:: operator&lt;=(Rational &amp;secondRational)&#123; if(compareTo(secondRational) &lt;=0) return true; else return false;&#125;Rational Rational:: operator+(Rational &amp;secondRational)&#123; return add(secondRational);&#125;Rational Rational:: operator-(Rational &amp;secondRational)&#123; return subtract(secondRational);&#125;Rational Rational:: operator*(Rational &amp;secondRational)&#123; return multiply(secondRational);&#125;Rational Rational:: operator/(Rational &amp;secondRational)&#123; return divide(secondRational);&#125;Rational Rational:: operator+=(Rational &amp;secondRational)&#123; *this=add(secondRational); return *this;&#125;Rational Rational:: operator-=(Rational &amp;secondRational)&#123; *this=subtract(secondRational); return *this;&#125;Rational Rational:: operator*=(Rational &amp;secondRational)&#123; *this=multiply(secondRational); return *this;&#125;Rational Rational:: operator/=(Rational &amp;secondRational)&#123; *this=divide(secondRational); return *this;&#125;long&amp; Rational::operator[] (int a)&#123; if(a) return denominator; else return numerator;&#125;Rational Rational:: operator+()&#123; return Rational(numerator,denominator);&#125;Rational Rational:: operator-()&#123; return Rational(-1*numerator,-1*denominator);&#125;Rational:: operator double()&#123; return 1.0*numerator/denominator;&#125;Rational Rational:: operator++()&#123; numerator+=denominator; return *this;&#125;Rational Rational:: operator--()&#123; numerator-=denominator; return *this;&#125;Rational Rational:: operator++(int dummy)&#123; numerator+=denominator; return Rational(numerator-denominator,denominator);&#125;Rational Rational:: operator--(int dummy)&#123; numerator-=denominator; return Rational(numerator+denominator,denominator); &#125;string Rational::toString() &#123; char s[50]; if ( denominator == 1) &#123; sprintf(s,&quot;%ld&quot;,numerator); &#125; else &#123; sprintf(s,&quot;%ld/%ld&quot;,numerator,denominator); &#125; return string(s);&#125;ostream&amp; operator&lt;&lt;(ostream &amp;str, Rational &amp;rational)&#123; cout &lt;&lt; rational.toString(); return str;&#125;istream&amp; operator&gt;&gt;(istream &amp;input ,Rational &amp; k)&#123; string s; int i = 0; input &gt;&gt; s; while (s[i] != &#x27;/&#x27;) k.numerator = k.numerator * 10 + s[i] - &#x27;0&#x27;; ++i; while (i &lt; s.length()) k.denominator = 10 * k.denominator + s[i] - &#x27;0&#x27;; return input;&#125; 遇到的问题 ostream在定义的时候不用加rational:: 因为ostream是友元函数,友元函数不属于成员函数 ostream的格式 123456ostream&amp; operator&lt;&lt;(ostream &amp;str, Rational &amp;rational)&#123; cout &lt;&lt; rational.toString(); return str;&#125; 类型转换函数 1234long&amp; Rational::operator[] (int a)&#123; if(a) return denominator; else return numerator;&#125; 前置和后置 12345678Rational Rational:: operator--()&#123; numerator-=denominator; return *this;&#125;Rational Rational:: operator--(int dummy)&#123; numerator-=denominator; return Rational(numerator+denominator,denominator); &#125; 有点疑惑 1234Rational Rational:: operator/=(Rational &amp;secondRational)&#123; *this=divide(secondRational); return *this;&#125; 这也能将*this赋值,明明没有重载=号,难道跟昨天做的是一个类型的吗.也是因为lei","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(五)--complex operator(一道平平无奇的重载运算符)","slug":"程设/complex operator","date":"2022-03-09T08:28:42.451Z","updated":"2022-05-08T07:52:42.333Z","comments":true,"path":"2022/03/09/程设/complex operator/","link":"","permalink":"http://example.com/2022/03/09/%E7%A8%8B%E8%AE%BE/complex%20operator/","excerpt":"","text":"Description 实现复数的操作符重载，你需要做的是，将complex.h文件的函数声明，全部在complex.cpp中实现。 类的声明如下： 1234567891011121314151617181920class COMPLEX&#123;public: COMPLEX(double r = 0, double i = 0); // 构造函数 COMPLEX(const COMPLEX &amp;other); // 拷贝构造函数 void print(); // 打印复数 // 重载加法运算符（二元） COMPLEX operator+(const COMPLEX &amp;other); // 重载减法运算符（二元） COMPLEX operator-(const COMPLEX &amp;other); COMPLEX operator-(); // 重载求负运算符（一元） // 重载赋值运算符（二元） COMPLEX operator=(const COMPLEX &amp;other); COMPLEX &amp; operator++(); //重载前置++ COMPLEX operator++(int); //重载后置++ COMPLEX &amp; operator--(); //重载前置-- COMPLEX operator--(int); //重载后置--protected: double real, image; // 复数的实部与虚部&#125;; Sample Output 123456789101+2i-5-6i-5-6i-4-5i-4-5i-5-6i-6-7i-6-7i-5-6i-5-6i 感觉没啥需要注意的,大家自己看吧(๑•̀ㅂ•́)و✧ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;#ifndef COMPLEX_H#define COMPLEX_Hclass COMPLEX&#123;public: COMPLEX(double r = 0, double i = 0); // 构造函数 COMPLEX(const COMPLEX &amp;other); // 拷贝构造函数 void print(); // 打印复数 // 重载加法运算符（二元） COMPLEX operator+(const COMPLEX &amp;other); // 重载减法运算符（二元） COMPLEX operator-(const COMPLEX &amp;other); COMPLEX operator-(); // 重载求负运算符（一元） // 重载赋值运算符（二元） COMPLEX operator=(const COMPLEX &amp;other); COMPLEX &amp;operator++(); //重载前置++ COMPLEX operator++(int); //重载后置++ COMPLEX &amp;operator--(); //重载前置-- COMPLEX operator--(int); //重载后置--protected: double real, image; // 复数的实部与虚部&#125;;#endifCOMPLEX::COMPLEX(double r,double i):real(r),image(i)&#123;&#125;COMPLEX::COMPLEX(const COMPLEX &amp;other)&#123; real=other.real; image=other.image;&#125;void COMPLEX::print()&#123; if(!real &amp;&amp; !image ) cout &lt;&lt; 0 &lt;&lt; endl; else if(!real) cout &lt;&lt; noshowpos &lt;&lt; image &lt;&lt; &#x27;i&#x27;; else if(!image) cout&lt;&lt; noshowpos&lt;&lt; real; else cout &lt;&lt; noshowpos&lt;&lt; real &lt;&lt;showpos &lt;&lt; image &lt;&lt; &#x27;i&#x27;; cout &lt;&lt; endl &lt;&lt; noshowpos;&#125;COMPLEX COMPLEX::operator+(const COMPLEX &amp;other)&#123; return COMPLEX(other.real+real,other.image+image);&#125;COMPLEX COMPLEX::operator-(const COMPLEX &amp;other)&#123; return COMPLEX(real-other.real,image-other.image);&#125; COMPLEX COMPLEX::operator-()&#123; return COMPLEX(-1*real,-1*image);&#125; COMPLEX COMPLEX::operator=(const COMPLEX &amp;other)&#123; real=other.real; image=other.image; return *this;&#125;COMPLEX &amp;COMPLEX::operator++()&#123; real++; return *this;&#125;COMPLEX COMPLEX::operator++(int)&#123; COMPLEX temp (*this); real++; return temp;&#125;COMPLEX &amp;COMPLEX::operator--()&#123; real--; return *this;&#125;COMPLEX COMPLEX::operator--(int)&#123; COMPLEX temp(*this); real--; return temp; &#125;int main()&#123; COMPLEX c1(1, 2); // 定义一个值为1 + 2i的复数c1 COMPLEX c2(2); // 定义一个值为2的复数c2 COMPLEX c3(c1); // 用拷贝构造函数创建一个值同c1的新复数 c3.print(); // 打印c3的值 c1 = c1 + c2 + c3; // 将c1加上c2再加上c3赋值给c1 c2 = -c3; // c2等于c3求负 c3 = c2 - c1; // c3等于c2减去c1 c3.print(); // 再打印运算后c3的值 COMPLEX temp= c3++; temp.print(); c3.print(); temp=c3--; temp.print(); c3.print(); temp=--c3; temp.print(); c3.print(); temp=++c3; temp.print(); c3.print(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(四)--simple String","slug":"程设/simple string(复习)","date":"2022-03-08T11:17:18.765Z","updated":"2022-05-08T08:02:27.198Z","comments":true,"path":"2022/03/08/程设/simple string(复习)/","link":"","permalink":"http://example.com/2022/03/08/%E7%A8%8B%E8%AE%BE/simple%20string(%E5%A4%8D%E4%B9%A0)/","excerpt":"","text":"一道比较综合的题目 Description 实现一个名为CSimpleString的类，该类可以完成简单的字符串操作。你需要实现类中的这类成员函数： CSimpleString();构造函数，产生一个空字符串。 CSimpleString(char*);构造函数，产生一个串，并用一个char 型字符串初始化它。 ~CSimpleString();析构函数。 const char&amp; operator[](unsigned int pos);重载[]运算符，返回串中第pos号字符，下标从 0 开始。 CSimpleString&amp; operator=(const CSimpleString &amp;other);重载=运算符，将一个CSimpleString对象中的内容copy到另一个CSimpleString对象中。 CSimpleString operator+(const CSimpleString &amp;other);重载+运算符，将两个CSimpleString对象中的串拼接起来并产生新串。 unsigned int length();返回串长度。 题目所给代码 12345678910111213class CSimpleString &#123; char *str; unsigned int len;public: CSimpleString(); CSimpleString(char*); CSimpleString(const CSimpleString&amp; other); ~CSimpleString(); const char&amp; operator[](unsigned int pos); CSimpleString&amp; operator=(const CSimpleString &amp;other); CSimpleString operator+(const CSimpleString &amp;other); unsigned int length();&#125;; 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;SimpleString.hpp&quot;using std::cin;using std::cout;using std::endl;int main() &#123; char str[100]; cin &gt;&gt; str; CSimpleString s1(str); cin &gt;&gt; str; CSimpleString s2(str); CSimpleString s3; s1 = s1 + s3; s2 = s3 + s2; s3 = s1 + s2; s1 = s1; s1 = s3 + s2; for(unsigned int i = 0; i &lt; s1.length(); ++i) cout &lt;&lt; s1[i]; cout &lt;&lt; endl; return 0;&#125; 静态成员函数没有this指针 我的答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include&lt;string.h&gt;using std::cin;using std::cout;using std::endl;class CSimpleString &#123; char *str; unsigned int len;public: CSimpleString(); CSimpleString(char*); CSimpleString(const CSimpleString&amp; other); ~CSimpleString(); const char&amp; operator[](unsigned int pos); CSimpleString&amp; operator=(const CSimpleString &amp;other); CSimpleString operator+(const CSimpleString &amp;other); unsigned int length();&#125;;CSimpleString::CSimpleString()&#123; str=NULL; str=new char[100]; str[0]=&#x27;\\0&#x27;; len=0;&#125;CSimpleString::CSimpleString(char* a)&#123; str=NULL; str=new char[100]; str[0]=&#x27;\\0&#x27;; strcpy(str,a); len=strlen(a);&#125;CSimpleString::~CSimpleString()&#123; delete []str; &#125;CSimpleString::CSimpleString(const CSimpleString&amp; other)&#123; len=other.len; strcpy(str,other.str); str[len]=&#x27;\\0&#x27;;&#125;CSimpleString &amp; CSimpleString:: operator=(const CSimpleString &amp;other)&#123; len=other.len; strcpy(str,other.str); str[len]=&#x27;\\0&#x27;; return *this;&#125;CSimpleString CSimpleString:: operator+(const CSimpleString &amp;other)&#123; CSimpleString temp; temp.len=this-&gt;len+other.len; strcpy(temp.str,this-&gt;str); strcat(temp.str,other.str); return temp;&#125;unsigned int CSimpleString::length()&#123; return len;&#125; const char&amp; CSimpleString::operator[](unsigned int pos)&#123; return this-&gt;str[pos];&#125; 参考答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstring&gt;#include &quot;SimpleString.hpp&quot;#include &lt;new&gt;CSimpleString::CSimpleString() &#123; new(this) CSimpleString(&quot;&quot;);&#125;CSimpleString::CSimpleString(char *s) &#123; len = strlen(s); str = new char[len + 1]; strcpy(str, s);&#125;CSimpleString::CSimpleString(const CSimpleString&amp; other)&#123; new(this) CSimpleString(other.str); //return *this;&#125;CSimpleString::~CSimpleString() &#123; delete [] str;&#125;const char&amp; CSimpleString::operator[](unsigned int pos) &#123; return str[pos];&#125;CSimpleString&amp; CSimpleString::operator=(const CSimpleString&amp; other) &#123; if(this != &amp;other) &#123; delete [] str; new(this) CSimpleString(other.str); &#125; return *this;&#125;CSimpleString CSimpleString::operator+(const CSimpleString&amp; other) &#123; CSimpleString ans; delete [] (ans.str); ans.len = len + other.len; ans.str = new char[ans.len + 1]; strcpy(ans.str, str); strcat(ans.str, other.str); return ans;&#125;unsigned int CSimpleString::length() &#123; return len;&#125; 任小狗代码(◆゜∀゜）b 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&quot;SimpleString.hpp&quot;#include&lt;stddef.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;CSimpleString::CSimpleString():str(NULL), len(0)&#123; str = new char[1]; str[0] = &#x27;\\0&#x27;;&#125;CSimpleString::CSimpleString(char*aa)&#123; len = strlen(aa); str = new char[len + 1]; strcpy(str, aa); str[len] = &#x27;\\0&#x27;;&#125;unsigned int CSimpleString::length()&#123; return len;&#125;CSimpleString::~CSimpleString()&#123; if(str) delete [] str;&#125;const char&amp; CSimpleString::operator[](unsigned int pos)&#123; return str[pos];&#125;CSimpleString&amp; CSimpleString::operator=(const CSimpleString &amp;other)&#123; if(str) delete [] str; len = other.len; str = new char[len + 1]; unsigned int i; for(i = 0; i &lt; len; i++)&#123; str[i] = other.str[i]; &#125; str[i] = &#x27;\\0&#x27;; return *this; &#125;CSimpleString CSimpleString::operator+(const CSimpleString &amp;other)&#123; char* aa = NULL; aa = new char [len + other.len + 1]; unsigned int i = 0; while(i &lt; len)&#123; aa[i] = str[i]; i++; &#125; int j = 0; while(i &lt; len + other.len)&#123; aa[i] = other.str[j]; j++; i++; &#125; aa[i] = &#x27;\\0&#x27;; CSimpleString temp(aa); delete [ ] aa; return temp;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(三)--随便记记简单题","slug":"程设/重载操作符()","date":"2022-03-08T11:07:02.430Z","updated":"2022-03-08T11:13:31.881Z","comments":true,"path":"2022/03/08/程设/重载操作符()/","link":"","permalink":"http://example.com/2022/03/08/%E7%A8%8B%E8%AE%BE/%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6()/","excerpt":"","text":"重载操作符() 重载操作符 ()，使得能够对象能够像函数一样调用（函数对象）. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdlib&gt;#ifndef Matrix_H#define Matrix_Hclass Exchange&#123; public: void operator()(int&amp;, int&amp;);&#125;;#endifvoid Exchange:: operator()(int &amp;i,int &amp;j)&#123; int t = i; i = j; j = t;&#125; using namespace std;int main()&#123; Exchange swap; int i = 20; int j = 30; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; swap(i, j); cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(二)--一道很全面的重载题目","slug":"程设/重载运算符","date":"2022-03-08T05:54:37.232Z","updated":"2022-03-23T11:38:17.397Z","comments":true,"path":"2022/03/08/程设/重载运算符/","link":"","permalink":"http://example.com/2022/03/08/%E7%A8%8B%E8%AE%BE/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"记录一道初学很头疼的题 题目所给代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void g()&#123; Int a=0; Int b(1); Int c(2.5); Int d = 99.5; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; b.getI() &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; d += 1; d += 1.5; cout &lt;&lt; c+d &lt;&lt; endl; cout &lt;&lt; 1+c &lt;&lt; endl; cout &lt;&lt; c+1 &lt;&lt; endl; cout &lt;&lt; 1.5+c &lt;&lt; endl; cout &lt;&lt; c+1.5 &lt;&lt; endl; cout &lt;&lt; a + b + c + d &lt;&lt; endl; d -= 1; d -= 1.5; cout &lt;&lt; c-d &lt;&lt; endl; cout &lt;&lt; 1-c &lt;&lt; endl; cout &lt;&lt; c-1 &lt;&lt; endl; cout &lt;&lt; 1.5-c &lt;&lt; endl; cout &lt;&lt; c-1.5 &lt;&lt; endl; d *= 1; d *= 1.5; cout &lt;&lt; c*d &lt;&lt; endl; cout &lt;&lt; 9*c &lt;&lt; endl; cout &lt;&lt; c*9 &lt;&lt; endl; cout &lt;&lt; 19.4*c &lt;&lt; endl; cout &lt;&lt; c*19.4 &lt;&lt; endl; d /= 2; d /= 2.5; cout &lt;&lt; d/c &lt;&lt; endl; cout &lt;&lt; 2/c &lt;&lt; endl; cout &lt;&lt; c/2 &lt;&lt; endl; cout &lt;&lt; 2.5/c &lt;&lt; endl; cout &lt;&lt; c/2.5 &lt;&lt; endl; cout &lt;&lt; b%c &lt;&lt; endl; cout &lt;&lt; 5%c &lt;&lt; endl; cout &lt;&lt; c%2 &lt;&lt; endl; cout &lt;&lt; c++ &lt;&lt; endl; cout &lt;&lt; ++c &lt;&lt; endl; cout &lt;&lt; c-- &lt;&lt; endl; cout &lt;&lt; --c &lt;&lt; endl; cout &lt;&lt; -c &lt;&lt; endl; int c1 = c; cout &lt;&lt; c1 &lt;&lt; endl; c1 = c; cout &lt;&lt; c1 &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl;&#125; 任小狗的代码(:) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class Int&#123;private: int i;public: int getI() const&#123; return i; &#125; Int(const int ii):i(ii)&#123;&#125; Int(const Int&amp; ii):i(ii.getI())&#123;&#125; Int operator+=(const double ii)&#123; i +=ii; return *this; &#125; Int operator-=(const double ii)&#123; i -=ii; return *this; &#125; Int operator*=(const double ii)&#123; i *=ii; return *this; &#125; Int operator/=(const double ii)&#123; i /=ii; return *this; &#125; operator int()&#123; return (int) i; &#125; int operator+(const int ii)&#123; return i + ii; &#125; int operator+(const Int ii)&#123; return i + ii.getI(); &#125; double operator+(const double ii)&#123; return double(i) + ii; &#125; int operator-(const int ii)&#123; return i - ii; &#125; int operator-(const Int ii)&#123; return i - ii.getI(); &#125; double operator-(const double ii)&#123; return double(i) - ii; &#125; int operator*(const int ii)&#123; return i * ii; &#125; int operator*(const Int ii)&#123; return i * ii.getI(); &#125; double operator*(const double ii)&#123; return double(i) * ii; &#125; int operator/(const int ii)&#123; return i / ii; &#125; int operator/(const Int ii)&#123; return i / ii.getI(); &#125; double operator/(const double ii)&#123; return double(i) / ii; &#125; int operator%(const int ii)&#123; return i % ii; &#125; int operator%(const Int ii)&#123; return i % ii.getI(); &#125; int operator++()&#123; i++; return i; &#125; int operator++(int)&#123; i++; return i - 1; &#125; int operator--()&#123; i--; return i; &#125; int operator--(int)&#123; i--; return i + 1; &#125; friend ostream&amp; operator&lt;&lt;( ostream&amp; output, const Int &amp; number)&#123; output &lt;&lt; number.getI(); return output; &#125; friend istream&amp; operator&gt;&gt;( istream&amp; input,Int &amp; number)&#123; input &gt;&gt; number.i; return input; &#125; friend int operator+(const int ii, const Int&amp; num )&#123; return ii + num.getI(); &#125; friend double operator+(const double ii, const Int&amp; num )&#123; return ii + (double)num.getI(); &#125; friend int operator-(const int ii, const Int&amp; num )&#123; return ii -num.getI(); &#125; friend double operator-(const double ii, const Int&amp; num )&#123; return ii - (double)num.getI(); &#125; friend int operator*(const int ii, const Int&amp; num )&#123; return ii * num.getI(); &#125; friend double operator*(const double ii, const Int&amp; num )&#123; return ii * (double)num.getI(); &#125; friend int operator/(const int ii, const Int&amp; num )&#123; return ii / num.getI(); &#125; friend double operator/(const double ii, const Int&amp; num )&#123; return ii / (double)num.getI(); &#125; friend int operator%(const int ii, const Int&amp; num )&#123; return ii % num.getI(); &#125;&#125;; 参考答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 #include &lt;iostream&gt;using namespace std;class Int&#123; int i;public: int getI() &#123; return i; &#125; //constructor Int(int a):i(a)&#123;&#125;; Int(double a)&#123;i = a;&#125;; //type transform operator int() &#123; return i; &#125; //ostream &amp;&amp; istream friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Int&amp; a) &#123; out &lt;&lt; a.i; return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, Int&amp; a) &#123; in &gt;&gt; a.i; return in; &#125; //operator += Int operator +=(int a) &#123; this-&gt;i += a; return *this; &#125; Int operator +=(double a) &#123; this-&gt;i += a; return *this; &#125; //operator -= Int operator -=(int a) &#123; this-&gt;i -= a; return *this; &#125; Int operator -=(double a) &#123; this-&gt;i -= a; return *this; &#125; //operator *= Int operator *=(int a) &#123; this-&gt;i *= a; return *this; &#125; Int operator *=(double a) &#123; this-&gt;i *= a; return *this; &#125; //operator / Int operator /=(int a) &#123; this-&gt;i /= a; return *this; &#125; Int operator /=(double a) &#123; this-&gt;i /= a; return *this; &#125; //operator ++ Int&amp; operator ++() &#123; ++this-&gt;i; return *this; &#125; Int operator ++(int a) &#123; Int temp = *this; ++this-&gt;i; return temp; &#125; //operator -- Int&amp; operator --() &#123; --this-&gt;i; return *this; &#125; Int operator --(int a) &#123; Int temp = *this; --this-&gt;i; return temp; &#125; //operator = Int operator =(int a) &#123; this-&gt;i = a; return *this; &#125; Int operator =(double a) &#123; this-&gt;i = a; return *this; &#125; //add any member function needed here&#125;; 知识点 第一 加减乘除重载运算符的基本操作 第二 二元运算符涉及顺序时需要使用友元函数 123friend double operator-(const double ii, const Int&amp; num )&#123; return ii - (double)num.getI();&#125; 第三 什么时候return this指针 +=,-=这种的时候return this指针会比较方便 重载&lt;&gt; 1234friend ostream&amp; operator&lt;&lt;( ostream&amp; output, const Int &amp; number)&#123;output &lt;&lt; number.getI();return output;&#125; 自增运算和自减运算 递增和递减分为前置和后置情况，a = ++b;(前置)， a = b++;(后置)。因为符号一样，所以给后置版本加一个int 1234567891011ca operator++()&#123; pos++; return *this;&#125;//后置递增就是增加当前对象的pos的值，并且返回增加pos之前的该对象ca operator++(int)&#123; ca ret = *this; ++*this; //这个会调用上面的函数，其实这里可以换成pos++; return ret;&#125; ++ 在前面叫做前自增（例如 ++a）。前自增先进行自增运算，再进行其他操作。 ++ 在后面叫做后自增（例如 a++）。后自增先进行其他操作，再进行自增运算。 转换函数 原文链接：https://blog.csdn.net/liyazhen2011/article/details/86349255 设计一个类Fraction表示分数，包含分子和分母。我们希望它能自动转换为double类型，并参与运算。 12345678910111213141516171819202122232425class Fraction&#123;public: Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) &#123; &#125; //转换函数 operator double() const &#123; return (double)m_numerator / m_denominator; &#125; private: int m_numerator; //分子 int m_denominator; //分母&#125;; int main()&#123; Fraction f(3,5); double sum = 4 + f; std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; //sum = 4.6 return 0;&#125; 12//测试代码double sum = 4 + f; 首先，它会寻找+操作符是否有重载了参数为double和Fraction的函数。很明显，我们并没有为刚刚新建的类Fraction重载+操作符，编译器的该次尝试以失败告终。 接着，不轻言放弃的编译器发现操作符+可以接收两个double类型的参数，那么是否可以将Fraction转换为double，从而调用该版本的函数呢？这次编译器成功了，因为我们刚刚实现了转换为double的函数。 最终，编译器成功实现了求和操作，输出了结果4.6。 **可以发现 参考答案中,并没有重载+-*/,因为通过转换函数,也能实现想要的输出** 我自己的疑惑 为什么任小狗的代码没有重载=号,编译器也不报错 参考答案中重载了=号 1Int a=0; 这个是怎么完成赋值的呢? 原来这个是隐式类型转换函数.如果在构造函数种使用了explict关键词,这种隐式类型转换就会报错 2022.3.23补充 学了一些知识之后我就懂了,这个等号会自动调用构造函数,前提是在声明变量的时候初始化会调用,而不是调用重载等号的函数. 而且c++会有一个隐式类型转换 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Point &#123;public: int x, y; Point(int x = 0, int y = 0) : x(x), y(y) &#123;&#125;&#125;;void displayPoint(const Point&amp; p) &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;int main()&#123; displayPoint(1); Point p = 1;&#125; 我们定义了一个再简单不过的Point类, 它的构造函数使用了默认参数. 这时主函数里的两句话都会触发该构造函数的隐式调用. (如果构造函数不使用默认参数, 会在编译时报错) 显然, 函数displayPoint需要的是Point类型的参数, 而我们传入的是一个int, 这个程序却能成功运行, 就是因为这隐式调用. 另外说一句, 在对象刚刚定义时, 即使你使用的是赋值操作符=, 也是会调用构造函数, 而不是重载的operator=运算符. 这样悄悄发生的事情, 有时可以带来便利, 而有时却会带来意想不到的后果. explicit关键字用来避免这样的情况发生. explicit关键字","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"程设记录(一)-meow","slug":"程设/meow","date":"2022-03-07T12:58:12.259Z","updated":"2022-04-12T05:59:20.743Z","comments":true,"path":"2022/03/07/程设/meow/","link":"","permalink":"http://example.com/2022/03/07/%E7%A8%8B%E8%AE%BE/meow/","excerpt":"","text":"几个易错点: 第一 const int id; 这个常量需要使用列表来初始化 第二 string和字符数组如何相互转换 12345678910111213141516void main()&#123; //字符串转字符数组 string name = &quot;哈哈哈哈&quot;; char buf[] = &#123;0&#125;; strcpy(buf , name.c_str());//字符串转字符数组，使用strcpy cout &lt;&lt; name.c_str() &lt;&lt; endl;//name.c_str()将字符串转换成字符数组 cout &lt;&lt; buf &lt;&lt; endl; //字符数组转字符串 char buf1[]= &quot;哈哈哈哈&quot;; string name1; name1 = buf1; cout &lt;&lt; name1 &lt;&lt; endl;&#125; 第三 12345678910111213141516171819202122class Meow &#123;public: //constructor Meow(int id_, string name_); //copy constructor Meow(const Meow &amp;other); //desctructor ~Meow(); //return the count of cats static int getCount(); //print some infomation void print() const &#123; cout &lt;&lt; &quot;Cat &quot; &lt;&lt; id &lt;&lt; &quot;. My name is &quot; &lt;&lt; name &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125;int Meow:: getCount()&#123; return count;&#125; 虽然getcount是静态函数,但是在定义的时候不能加static 第四 ​ char *name; 要使用new和delete 参考答案 1234567891011121314151617181920212223242526#include &quot;Meow.h&quot;#include &lt;cstring&gt;Meow::Meow(int id_, string name_) : id(id_) &#123; name = new char[name_.size()+1]; strcpy(name, name_.c_str()); count++;&#125;Meow::Meow(const Meow &amp;other) : id(other.id) &#123; name = new char[strlen(other.name)+1]; strcpy(name, other.name); count++;&#125;Meow::~Meow() &#123; delete []name; name = NULL; count--;&#125;int Meow::getCount() &#123; return count;&#125;int Meow::count = 0; 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class Meow &#123;public: //constructor Meow(int id_, string name_); //copy constructor Meow(const Meow &amp;other); //desctructor ~Meow(); //return the count of cats static int getCount(); //print some infomation void print() const &#123; cout &lt;&lt; &quot;Cat &quot; &lt;&lt; id &lt;&lt; &quot;. My name is &quot; &lt;&lt; name &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125;private: const int id; char *name; static int count; // the count of cats&#125;;int Meow:: count=0;Meow::Meow(int id_, string name_):id(id_),name(NULL)&#123; name=new char[100]; strcpy(name , name_.c_str()); count++;&#125;Meow::Meow(const Meow &amp;other):id(other.id),name(NULL)&#123; name=new char[100]; strcpy(name,other.name); count++;&#125;int Meow:: getCount()&#123; return count;&#125;Meow::~Meow()&#123; count--; delete [] name;&#125; void printCount() &#123; cout &lt;&lt; &quot;Number of Cat: &quot; &lt;&lt; Meow::getCount() &lt;&lt; endl;&#125;int main() &#123; string name = &quot;Madara&quot;; int num; cin &gt;&gt; num; Meow cat(0, name), *p; for (int i = 1; i &lt;= num; ++i) &#123; cin &gt;&gt; name; Meow a(i, name); if (i % 2 != 0) &#123; p = new Meow(i, name); printCount(); p-&gt;print(); delete p; &#125; else &#123; Meow b(a); printCount(); b.print(); &#125; &#125; printCount(); cat.print(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"第四章-Boolean Algebra and Logic Simplification  (一)","slug":"数字电路汇总/数字电路第四章(一)","date":"2022-03-07T08:11:06.361Z","updated":"2022-03-13T06:10:07.096Z","comments":true,"path":"2022/03/07/数字电路汇总/数字电路第四章(一)/","link":"","permalink":"http://example.com/2022/03/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E4%B8%80)/","excerpt":"","text":"概念 variable: complement:the inverse of a variable Boolean addition: or Boolean multiplication: 布尔运算和表达式 布尔加法 或门是布尔加法的表示形式 0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 1 布尔乘法 与门是布尔乘法的表示形式 布尔代数定律和法则 布尔代数定律 交换律 \\[ A+B=B+A \\] \\[ AB=BA \\] 结合律 \\[ A+(B+C)=(A+B)+C \\] \\[ A(BC)=(AB)C \\] 分配律 \\[ A(B+C)=AB+AC \\] 分配律的应用 布尔代数法则 与离散数学相似 狄摩根定理 第一定理: \\[ \\overline{XY}=\\bar X+\\bar Y \\] 第二定理: \\[ \\overline{X+Y} =\\bar X+ \\bar Y \\] 布尔代数法则总结 不熟悉的公式推导: \\[ A+\\bar AB=A+AB+\\bar AB=A+B \\] \\[ A\\cdot B+A\\cdot \\bar B=A(B+\\bar B)=A \\] \\[ A\\cdot B+\\bar A \\cdot C+B\\cdot C=A\\cdot B+\\bar A \\cdot C+A\\cdot B\\cdot C+\\bar A\\cdot B\\cdot C=A\\cdot B+\\bar A \\cdot C \\] 逻辑电路的电路分析 Standard Forms of Boolean SOP and POS The sum-of-products (SOP) form A single overbar cannot extend over more than one variable; More than one variable in a term can have an overbar The product-of-sums (POS) form A single overbar cannot extend over more than one variable More than one variable in a term can have an overbar Expressions SOP \\[ AB\\bar C \\bar D+\\bar ACD +AC \\] POS \\[ (A + B)(B + C + D)(A + C) \\] ## standard SOP Form and POS Form standard SOP Form All the variables in the domain appear in each product term in the expression 离散数学中的主析取范式(极小项) Standard POS Form 离散数学中的主合取范式(极大项) image-20220313140158717 Converting standard SOP to standard POS from truth table to boolen expression","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路-作业遇到的问题","slug":"数字电路汇总/数电作业遇到的问题","date":"2022-03-06T08:11:33.547Z","updated":"2022-03-13T05:39:02.753Z","comments":true,"path":"2022/03/06/数字电路汇总/数电作业遇到的问题/","link":"","permalink":"http://example.com/2022/03/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E7%94%B5%E4%BD%9C%E4%B8%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"十进制小数转二进制 不断乘二,一旦结果大于一,那么就舍去进位 二进制十进制间小数怎么转换 这种会慢慢逼近,保留5到8位即可 0的补码形式 +0:000000000 -0:000000000 浮点数公式 带符号数的减法以补码形式 BCD码相加 要是两个BCD码加起来为三位数,那就用12位表示 计算 5+8： 解：将 5 和 8 以 8421 BCD输入机器，则运算如下： 0 1 0 1 +) 1 0 0 0 1 1 0 1 结果大于 9 +) 0 1 1 0 加 6 修正 1 0 0 1 1 即13 的 BCD码 结果是 0011，即十进制数3，还产生了进位。5+8=13。 二进制转格雷码 Parity Method (奇偶校验法) a的ascII编码是110001,A的ascII编码是100001 a的编码有奇数个1,所以他的parity bit 是0, A的编码有奇数个1,所以他的parity bit 是1 Even（偶） Parity Even（偶） Parity Odd Parity Odd Parity P BCD P BCD 0 0000 1 0000 1 0001 0 0001 1 0010 0 0010 0 0011 1 0011 1 0100 0 0100 0 0101 1 0101 0 0110 1 0110 1 0111 0 0111 1 1000 0 1000 0 1001 1 1001 Add odd parity system received the code group, 00110111, 11110000, which one is incorrect? 00110111, has 5 1s, it is odd, this code is OK. 11110000, has 4 1s, it is even, it is incorrect a和c是错的,因为他们的1的个数是偶数个 循环冗余校验码 两种题型 模-2运算就是异或运算 image-20220306190035271","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Fixed Function Logic","slug":"数字电路汇总/数字电路第三章(二)","date":"2022-03-06T03:34:54.029Z","updated":"2022-03-06T04:04:44.653Z","comments":true,"path":"2022/03/06/数字电路汇总/数字电路第三章(二)/","link":"","permalink":"http://example.com/2022/03/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0(%E4%BA%8C)/","excerpt":"","text":"这块内容没学模电基本啥都不懂,不是数电重点 ttl和cmos Two major fixed function logic families are TTL and CMOS. A third technology is BiCMOS, which combines the first two. Packaging for fixed function logic is shown . CMOS是场效应管构成（单极性电路），电压控制器件 TTL是双极晶体管构成（双极性电路），电流控制器件 (依旧不懂,没学模电) CMOS逻辑电平范围大（ 5-15V），抗干扰性强，噪声容限大，驱动负载能力强 TTL（ 5V以下），抗干扰性强差， 噪声容限小，速度快，传输延迟短，功耗大 CMOS电路的特点 功耗小： CMOS门工作时， 总是一管导通另一管 截止， 因而几乎不由电源吸取电流其功耗极小； CMOS集成电路功耗低内部发热量小， 集成度可 大大提高； 抗幅射能力强， MOS管是多数载流子工作， 射线 辐射对多数载流子浓度影响不大； 电压范围宽： CMOS门电路输出高电平\\(V_{OH}\\) ≈ \\(V_{DD}\\),低电平\\(V_{OL}\\) ≈ 0V 输出驱动电流比较大：扇出能力较大， 一般可 以大于50； 在使用和存放时应注意静电屏蔽， 焊接时电烙 铁应接地良好","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Logic Gate","slug":"数字电路汇总/数字电路第三章(一)","date":"2022-03-05T07:45:11.254Z","updated":"2022-03-06T03:50:45.172Z","comments":true,"path":"2022/03/05/数字电路汇总/数字电路第三章(一)/","link":"","permalink":"http://example.com/2022/03/05/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0(%E4%B8%80)/","excerpt":"","text":"数电老师太催眠了,自学!! Selected Key Terms Inverter(反相器): A logic circuit that inverts or complements its inputs Truth table(真值表): A table showing the inputs and corresponding output(s) of a logic circuit. Timing diagram(时序图): A diagram of waveforms showing the proper time relationship of all of the waveforms. Boolean algebra(布尔代数): The mathematics of logic circuits. AND gate (与): A logic gate that produces a HIGH output only when all of its inputs are HIGH. OR gate(或): A logic gate that produces a HIGH output when one or more inputs are HIGH . NAND gate(与非): A logic gate that produces a LOW output only when all of its inputs are HIGH. NOR gate(与或): A logic gate that produces a LOW output when one or more inputs are HIGH Exclusive-OR gate(异或) A logic gate that produces a HIGH output only when its two inputs are at opposite levels. Exclusive-NOR gate (同或): A logic gate that produces a LOW output only when its two inputs are at opposite levels. The Inverter (反相器) Boolean expression for an inverter is \\[X = \\bar A\\]. input output a x low(0) high(1) high(1) low(0) The AND Gate Input Input Output A B X 0 0 0 0 1 0 1 0 0 1 1 1 expression:\\[X = A \\cdot B \\]or\\[ X = AB \\] OR Gate Input Input OUTPUT A B X 0 0 0 0 1 1 1 0 1 1 1 1 \\[X = A + B \\] 下面几种门我主要列出不熟悉的符号表达和门长什么样,真值表就不列了 The NAND Gate \\[ X = \\overline {A \\cdot B} \\] \\[ X = \\overline {AB} \\] The NOR Gate \\[ X = \\overline{A + B} \\] The XOR Gate \\[ X = A \\oplus B \\] \\[ X = \\bar A B + A\\bar B \\\\ \\] The XNOR Gate \\[ X = A \\odot B \\\\ \\] \\[ X = \\bar A\\bar B + AB \\]","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"数字电路-数字系统\\运算\\编码","slug":"数字电路汇总/数字电路第二章","date":"2022-02-24T13:18:07.560Z","updated":"2022-03-13T04:42:25.230Z","comments":true,"path":"2022/02/24/数字电路汇总/数字电路第二章/","link":"","permalink":"http://example.com/2022/02/24/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"十进制数 二进制数 十进制转换二进制 image-20220224215626755 二进制算术 加法 image-20220224215818222 与十进制列竖式同理 减法 借位 乘法 除法 二进制的反码和补码 无符号二进制 反码 01转换 补码 反码加一 另一种方法: 改变最低有效1左边的全部位 带符号数 最左边为符号位,0代表正数,1代表负数 带符号数的反码 对于正数 正数的反码是其本身 即反码等于补码等于原码 对于负数 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. 负数的反码也可以表示为对应正数的各位取反; 比如-1的反码等于+1的原码的各位取反 带符号数的补码 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 带符号数的十进制 原码 反码 补码 带符号整数的表示范围 二进制数的取值范围取决于数的位数(n) 对于补码带符号数,n位数的数值范围是\\(-2^{n-1}\\)到\\(+(2^{n-1}-1)\\) 例如:8位数可以表示-128到+127 浮点数 单精度(32)(64)(80) 仅仅讨论单精度 \\[ 数=(-1)^{S}(1+F)(2^{E-127}) \\] 带符号数的算术运算 加法 当两个数符号相同时,有可能发生溢出 负数都是用补码的形式表示的 溢出条件 减法 正二进制或者负二进制数的符号通过求此数的补码而改变. 乘法 计算步骤 确定被乘数和乘数的符号是相同还是相异的 将所有的负数变为原码形式 类比十进制乘法,列竖式 如果步骤一确定的符号是负的,那就对积取补码,如果是正的,那就保持原码 补充符号位 例子 除法 步骤 十六进制数 二-十进制编码(BCD) 数字编码 格雷码 特征：两个相邻码字之间只有一位不同 可以减少出错概率 Binary-to-Gray Code Conversion 第一行是二进制第二行是格雷码 最高有效位相同,从左到右,逐项异或 比如说格雷码的第二位是二进制的第一位和第二位异或产生的数 Gray Code-to-Binary Conversion 二进制最高位和格雷码最高位相同，都是 1，次高位为二进制的高位和次高位格雷码相异或得到，即 bit2 为 0=1^1。 ASCII码 错误检测码 Parity Method (奇偶校验法) a的ascII编码是110001,A的ascII编码是100001 a的编码有奇数个1,所以他的parity bit 是0, A的编码有奇数个1,所以他的parity bit 是1 CRC (cyc;ic redundancy check)循环冗余校验 用于检验大规模的数据 后续补充: 最高有效位，英文全称是：the Most Significant Bit，缩写为：msb，是指一个n位二进制数字中的n-1位，具有最高的权值2^(n-1)。与之相反的称之为最低有效位。在大端序中，msb即指最左端的位。","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Lumerical脚本语言学习( 四)-Simulation region","slug":"Lumerical/lumerical脚本语言学习4","date":"2022-02-23T12:27:01.187Z","updated":"2022-02-23T14:12:55.548Z","comments":true,"path":"2022/02/23/Lumerical/lumerical脚本语言学习4/","link":"","permalink":"http://example.com/2022/02/23/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A04/","excerpt":"","text":"参考了csdn的文章,属于转载 自动精度 12345678910111213addfdtd;set(&quot;dimension&quot;,2);#三维仿真区域(重点)set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z min&quot;,-10*nm);set(&quot;z max&quot;,2*um);set(&quot;x span&quot;,0.2*um);set(&quot;y span&quot;,0.4*um);set(&quot;x min bc&quot;,&quot;periodic&quot;);#设置x方向周期边界条件(重点)set(&quot;y min bc&quot;,&quot;periodic&quot;);#设置y方向周期边界条件set(&quot;Mesh type&quot;,&quot;auto non-uniform&quot;);#仿真网格为自动精度set(&quot;Mesh accuracy&quot;,3);#高精度 set(“dimension”,2)：仿真空间维度，“dimension”参数一般有两个值：1和2，其中1表示仿真的区域是二维区域，2表示仿真三维区域。这里设置为2，表示我们仿真的是一个三维区域 set(“x min bc”,“periodic”)：边界条件，根据实际的仿真区域（维度）设置，有\"x max bc\"，“x min bc”，“y max bc”等多个边界，可选用的边界条件见下表： 边界条件 说明 PML(100% absorption, 0% reflection) 完美匹配层 Metal(0% absorption, 100% reflection) 金属边界 Periodic 周期边界 Symmetric 对称边界 Anti-Symmetric 非对称边界 Bloch 适合斜入射 PMC 理想磁导体 set(“Mesh type”,“auto non-uniform”)：网格类型，有“auto non-uniform”、“custom non-uniform”、\"uniform\"三种可选，一般默认为“auto non-uniform”，若不需更改网格类型，本条代码可不写。这里使用的是默认的自动精度 set(“Mesh accuracy”,3)：自动网格精度，在“auto non-uniform”模式下设置。有1~8一共8个等级，精度随着数字的增大而提高，一般默认为2，不建议太高，容易给CPU带来很大的负担。这里设置为3，属于高精度仿真.","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"数字电路-introduction concept","slug":"数字电路汇总/数字电路(一)","date":"2022-02-21T08:18:33.708Z","updated":"2022-02-21T10:08:15.670Z","comments":true,"path":"2022/02/21/数字电路汇总/数字电路(一)/","link":"","permalink":"http://example.com/2022/02/21/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF(%E4%B8%80)/","excerpt":"","text":"Key terms: Analog 模拟 Digital 数字 Inverter: 逆变器? Pulse: 脉冲 Duty cycle: 占空比 Integrated circuit(IC) 集成电路 Fixed-function logic 固定功能逻辑 Timing diagram 时序图 Troubleshooting 故障 排除 Serial 串行 Parallel并行 SPLD ( Simple Programmable Logic Device) 简单可编程逻辑器件 CPLD (Complex Programming logic device) 复杂可编程逻辑器件 FPGA （Field-Programmable Gate Array） 现场可编程逻辑门阵列 Compiler 编译器 1.1 digital and analogy quantities definition 模拟量具有连续的数值，数字量具有离散的数值。 the digital advantage(数字量优点) 数字量的优点 在电学应用方面，数字量表示法和模拟量表示法相比有一定的优势。 数字数据和模拟数据相比，前者在处理和传输方面更有效、更可靠。 数字数据在需要保存时，更显示了它的优越性。例如，转换成数字形式的音乐，要比相对应的模拟形式更简洁，复制时更精确、更清晰。噪声（不需要的电压波动）几乎不会影响数字数据，但会影响模拟信号。 1.2 binary digits,logic levels,and digital waveforms(二进制数、逻辑电平和数字波形) 1.2.1 binary digits positive logic (正逻辑): HIGH=1,LOW=0 1.2.2 logic levels 1.2.3 digital waveforms 理想脉冲 The Pulse A pulse has two edges: a leading edge that occurs first at time to and a trailing edge that occurs last at time 非理想脉冲 \\[ f=\\frac{1}{T}\\\\ duty cycle(占空比)=(\\frac{t_w}{T})\\times100\\% \\] 1.2.4 A Digital Waveform Carries Binary Information(数字波形携带二进制信息) 例子 timing diagram 1.2.5 data transfer(数据转换) 两种方式:serial and parallel(串行和并行) 1.3 basic logic operations(基本逻辑操作) image-20220221175827593 image-20220221175845207","categories":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Lumerical脚本语言学习(三)-结构搭建","slug":"Lumerical/lumerical脚本语言学习3","date":"2022-02-20T08:13:58.028Z","updated":"2022-02-20T09:03:43.612Z","comments":true,"path":"2022/02/20/Lumerical/lumerical脚本语言学习3/","link":"","permalink":"http://example.com/2022/02/20/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A03/","excerpt":"","text":"参考文档(61条消息) FDTD快速入门之Lumerical脚本语言Pickup（三）结构(Structure)搭建_ArcSight的博客-CSDN博客 FDTD solution中的仿真模型包含两个核心部分：材料(material)和几何结构(structure)。通常用包含吸收参数的材料的复折射率控制material属性，而用3D模型参数控制structure属性。下面介绍几种常用的structure。 一、（长方体）矩形（Rectangle） 12345678910111213addrect;set(&quot;name&quot;,&quot;rect&quot;);#名称 set(&quot;material&quot;,&quot;SiO2 (Glass) - Palik&quot;);#材料set(&quot;render type&quot;,&quot;wireframe&quot;); # 渲染方式：线框，减小显卡压力set(&quot;x&quot;,0);#设置x中心点坐标 set(&quot;y&quot;,0);#设置y中心点坐标set(&quot;x span&quot;,1e-6);#设置x方向宽度set(&quot;y span&quot;,1e-6);#设置y方向宽度set(&quot;z max&quot;,1e-7);#设置z方向最大值set(&quot;z min&quot;,-1e-6);#设置z方向最小值set(&quot;first axis&quot;,&quot;x&quot;);#设置第一转轴set(&quot;rotation 1&quot;,45);#设置第一旋转角 效果展示 下面详细介绍每段代码的用途： addrect：随机生成一个一定大小，材料为一定折射率介电材料的矩形模型。 set(“name”,“rect”)：名称。设定矩形的名称为“rect” set(“material”,“SiO2 (Glass) - Palik”)：材料——这里的材料必须是材料库中存在的，且必须按照材料库中原有的名字命名。设定矩形的材料为二氧化硅 set(“render type”,“wireframe”)：渲染方式——有detailed和wireframe两种，系统默认为detailed，如有需要，可改为wireframe。设定矩形的渲染方式为线框 set(“x”,“0”)：中心坐标(x轴)，类似地还可设置y和z的中心坐标。设定矩形的中心坐标（x轴）为0 set(“x span”,“1e-6”)：x轴向宽度（或范围），类似地还可设置y和z的轴向宽度。设定矩形的x轴向宽度为1e-6，即1微米 set(“z max”,“1e-7”)：z方向最大值，类似地还有z min、x max、x min、y max、y min。设定矩形的z方向最大为1e-7，即100纳米 set(“first axis”,“x”)：第一转轴。设定矩形的第一转轴(first axis)为x轴 set(“rotation 1”,45)：绕第一转轴的旋转角。设定矩形绕x轴的转角为45° 二、多边形柱体（Ploygon） 1.多边形柱 123456789101112um=1e-6;nm=1e-9;vtx=[2,0;1,1;-1,1; -2,0;-1,-1;1,-1]*um; #向量组addpoly;set(&quot;name&quot;,&quot;poly&quot;);#名称set(&quot;index&quot;,1.5);#折射率set(&quot;vertices&quot;,vtx);#控制向量组set(&quot;x&quot;,0.5*um);#中心坐标set(&quot;y&quot;,1*um);set(&quot;z&quot;,-0.5*um);set(&quot;z span&quot;,0.4*um);#z方向宽度 addpoly：添加一个参数随机的多边形结构。 set(“index”,1.5)：折射率。多边形材料为介电材料，折射率为1.5 set(“vertices”,vtx)：向量组。设置多边形的xy面二维形状，由传入的向量组vtx中的参数控制 2.三角形柱 123456789101112um=1e-6;nm=1e-9;vtx=[3,0;0,4;-2,0]*um; #向量组addtriangle;set(&quot;name&quot;,&quot;triangle&quot;);#名称set(&quot;index&quot;,1.5);#折射率set(&quot;vertices&quot;,vtx);#控制向量组set(&quot;x&quot;,0.5*um);#中心坐标set(&quot;y&quot;,1*um);set(&quot;z&quot;,-0.5*um);set(&quot;z span&quot;,0.4*um);#z方向宽度 三、（椭）圆柱体（Circle） 1234567891011121314um=1e-6;nm=1e-9;addcircle;set(&quot;name&quot;,&quot;circle&quot;);set(&quot;material&quot;,&quot;Au (Gold) - Palik&quot;);set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,0);set(&quot;z span&quot;,400*nm);set(&quot;radius&quot;,600*nm);#半径/x轴半径set(&quot;make ellipsoid&quot;,1);#生成椭圆set(&quot;radius 2&quot;,800*nm);#y轴半径 set(“radius”,600nm)：半径/x轴半径。若是圆柱体，radius为圆的半径；若是椭圆柱体，radius为椭圆在x轴方向的半轴长（可能是长半轴或短半轴，由radius和radius的相对大小决定）。这里表示椭圆短半轴为600nm set(“make ellipsoid”,1)：生成椭圆。“make ellipsoid”可取两个值：0和1。其中，0表示生成的为圆柱体，1表示生成椭圆柱体（也可以认为1是enable椭圆参数radius 2，为0则radius 2被disable，只生成半径为radius的圆柱）。这里参数为1表示生成一个椭圆柱体。 set(“radius 2”,800nm)：y轴半径，椭圆的第二半轴长。生成一个第二半轴长为800nm的椭圆柱体。 四、（椭）球体（Sphere） 1234567891011121314um=1e-6;nm=1e-9;addsphere;set(&quot;name&quot;,&quot;sphere&quot;);set(&quot;index&quot;,1.5);set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,0);set(&quot;radius&quot;,200*nm);#半径/x轴半径set(&quot;make ellipsoid&quot;,1);#生成椭球set(&quot;radius 2&quot;,400*nm);#y轴半径set(&quot;radius 3&quot;,2*um);#z轴半径 球体的代码和椭圆柱的代码十分相似，区别仅在于多了一个第三半径（radius 3）（事实上是控制了z轴方向的大小） 五、圆环（体）（Ring） 123456789101112131415um=1e-6;nm=1e-9;addring;set(&quot;name&quot;,&quot;ring&quot;);set(&quot;index&quot;,1.5);set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,0);set(&quot;z span&quot;,600*nm);set(&quot;outer radius&quot;,400*nm);#外圆半径set(&quot;inner radius&quot;,200*nm);#内圆半径set(&quot;theta start&quot;,0);#起始角set(&quot;theta stop&quot;,135);#终止角 六、角椎体（Pyramid） 123456789101112131415um=1e-6;nm=1e-9;addpyramid;set(&quot;name&quot;,&quot;pyramid&quot;);set(&quot;index&quot;,1.5);set(&quot;x&quot;,0);set(&quot;x span bottom&quot;,600*nm);#梯形下底长（x轴向）set(&quot;x span top&quot;,100*nm);#梯形上底长（x轴向）set(&quot;y&quot;,0);set(&quot;y span bottom&quot;,400*nm);#梯形下底长（y轴向）set(&quot;y span top&quot;,200*nm);#梯形上底长（y轴向）set(&quot;z&quot;,0);set(&quot;z span&quot;,600*nm); 其中参数\"x span bottom\"、“y span bottom”、“x span top”、\"y span top\"分别控制该角锥体下、上底面的矩形大小。","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"Lumerical脚本语言学习(二)","slug":"Lumerical/lumerical脚本语言学习2","date":"2022-02-20T08:06:26.848Z","updated":"2022-02-20T08:10:43.686Z","comments":true,"path":"2022/02/20/Lumerical/lumerical脚本语言学习2/","link":"","permalink":"http://example.com/2022/02/20/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02/","excerpt":"","text":"参考了(61条消息) FDTD快速入门之Lumerical脚本语言Pickup（二）实用技巧_ArcSight的博客-CSDN博客_fdtd脚本 技巧和习惯 FDTD没有专门的长度单位常量，默认的长度单位是米(m)，所以一般用1e-6和1e-9分别表示微米(um)和纳米(nm)。 注释符号：# 运行脚本快捷键：F5 运行选中代码段快捷键：F9 注释快捷键：Ctrl+R 取消注释快捷键：Ctrl+T 运算符","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"Lumerical脚本语言学习(一)","slug":"Lumerical/lumerical脚本语言学习1","date":"2022-02-20T07:51:30.952Z","updated":"2022-03-20T08:24:24.312Z","comments":true,"path":"2022/02/20/Lumerical/lumerical脚本语言学习1/","link":"","permalink":"http://example.com/2022/02/20/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01/","excerpt":"","text":"这是一段用于验证光从光疏介质入射到光密介质时，反射波中存在半波损失的完整仿真代码。它包含了以下几个部分： 仿真结构(structure) 仿真区域(FDTD) 光源(source) 监视器（monitor） 仿真结果分析(Analysis) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677switchtolayout;selectall;delete;nm=1e-9;#纳米单位um=1e-6;#微米单位#添加矩形addrect;set(&quot;name&quot;,&quot;SiO2&quot;);#名称为SiO2 set(&quot;material&quot;,&quot;SiO2 (Glass) - Palik&quot;);#材料为二氧化硅（玻璃）set(&quot;x&quot;,0);#设置x中心点坐标 set(&quot;y&quot;,0);#设置y中心点坐标set(&quot;x span&quot;,1*um);#设置x方向宽度set(&quot;y span&quot;,1*um);#设置y方向宽度set(&quot;z max&quot;,100*nm);#设置z方向最大值set(&quot;z min&quot;,-1*um);#设置z方向最小值#添加FDTD仿真区域addfdtd;set(&quot;dimension&quot;,2);#仿真区域为三维区域set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z min&quot;,-10*nm);set(&quot;z max&quot;,2*um);set(&quot;x span&quot;,0.2*um);set(&quot;y span&quot;,0.22*um);set(&quot;x min bc&quot;,&quot;periodic&quot;);#设置x方向周期边界条件set(&quot;y min bc&quot;,&quot;periodic&quot;);#设置y方向周期边界条件set(&quot;Mesh type&quot;,&quot;uniform&quot;);#仿真网格为自定义方式Mesh_size=10*nm;#网格精度10nmsetnamed(&quot;FDTD&quot;,&quot;dx&quot;,Mesh_size);setnamed(&quot;FDTD&quot;,&quot;dy&quot;,Mesh_size);#添加平面波addplane;set(&quot;injection axis&quot;,&quot;z&quot;);#入射轴与z轴平行set(&quot;direction&quot;,&quot;backward&quot;);#朝向后方入射set(&quot;x&quot;,0);set(&quot;x span&quot;,0.4*um);set(&quot;y&quot;,0);set(&quot;y span&quot;,0.4*um);set(&quot;z&quot;,1*um);set(&quot;wavelength start&quot;,1.5*um);#波长（最小）set(&quot;wavelength stop&quot;,1.5*um);#波长（最大）#添加点监视器addprofile;set(&quot;name&quot;,&quot;R&quot;);set(&quot;monitor type&quot;,1);#点监视器set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,1.5*um);#添加时间监视器addtime;set(&quot;name&quot;,&quot;time&quot;);run;#运行仿真#获取结果并分析select(&quot;SiO2&quot;);surface_z=get(&quot;z max&quot;);select(&quot;source&quot;);source_z=get(&quot;z&quot;);select(&quot;R&quot;);monitor_z=get(&quot;z&quot;);ex=getdata(&quot;R&quot;,&quot;Ex&quot;);R_z=getdata(&quot;R&quot;,&quot;z&quot;);f=getdata(&quot;R&quot;,&quot;f&quot;);f=pinch(f);lambda=c/f*1e6;phase=pinch(angle(ex));phai=phase-2*pi*(source_z+monitor_z-2*surface_z)*f/c;phai=mod(phai*180/pi,360);plot(lambda,phai,&quot;lambda um&quot;,&quot;phase&quot;);","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"Lumerical仿真实例(一)-微环调制器","slug":"Lumerical/Lumerical仿真实例(一)-微环调制器","date":"2022-01-31T08:03:35.165Z","updated":"2022-02-17T12:28:46.888Z","comments":true,"path":"2022/01/31/Lumerical/Lumerical仿真实例(一)-微环调制器/","link":"","permalink":"http://example.com/2022/01/31/Lumerical/Lumerical%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B(%E4%B8%80)-%E5%BE%AE%E7%8E%AF%E8%B0%83%E5%88%B6%E5%99%A8/","excerpt":"","text":"复现论文结果 论文标题: Ultra-low voltage, ultra-small mode volume silicon microring modulator 几个重要参数 微环调制器示意图 微环半径: 2.5 µm 微环宽度: 500nm 直波导宽度: 350nm 微环和直波导高度: 50nm 外层材料为:\\(SIO_2\\) image-20220131165029262 圆环最后谐振波长为1564nm 操作步骤 进入FDTD 进入FDTD 可以在component直接导入结构或者在structure自定义 设置参数 进入Edit object 设置参数 添加光源--为模式光源 设置光源参数 波长设置为:1.5到1.6 添加监视器 需要检测透射率与波长关系 因此添加frequency-domain field and power 设置监视器 设置方向为2dx-normal frequency points 重要参数 添加仿真区域 x方向和z方向有光,y方向没有光 因此将y方向设置为metal,x和z方向设置为pml 可以加快计算速度 可以添加mesh在耦合区域,增加该区域的计算精度 设置背景材料为\\(sio_2\\) 本次仿真进行的是2D仿真,最后所得参数跟论文结果近乎相同,有些参数没有仔细调,主要是熟悉FDTD的一些操作","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"},{"name":"仿真实例","slug":"Lumerical/仿真实例","permalink":"http://example.com/categories/Lumerical/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"仿真实例","slug":"仿真实例","permalink":"http://example.com/tags/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"}]},{"title":"Lumerical 软件学习(一)-FDTD","slug":"Lumerical/Lumerical软件学习(一)","date":"2022-01-29T13:29:14.835Z","updated":"2022-01-30T08:19:38.326Z","comments":true,"path":"2022/01/29/Lumerical/Lumerical软件学习(一)/","link":"","permalink":"http://example.com/2022/01/29/Lumerical/Lumerical%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)/","excerpt":"","text":"Theory of Lumerical Solvers-FDTD commonly used software FDTD solutions MODE solutions CHARGE solutions HEAT solutions INTERCONNECT etc FDTD: finite-difference time -domain method Maxwell's equations: 等我学完再写(先挖个坑) Discretize the fields in time and space An important parameter: point per wavelength Defined by\"Mesh arruracy\",ranging from 1-10.Usually set to 2 The frequency domain response is calculated by Fourier transform. Many quantities are derived from the frequency domain fields, such as the Poynting vector, transmission and reflection spectrum, the field power profile,etc. frequency domain: 频域 Poynting vector: 坡印亭矢量 field power profile: 场强分布 Essential components of FDTD simulation: Structure(几何结构) Material(材料) Source(光源) Simulation region(仿真区域) Monitor(监视器) Sorce Dipole source: utilized as point source (偶极子光源,用于仿真点光源) Plane wave: ideal source with infinite size (平面波,大小无限大,通常用于周期性结构) TPSF(total-field scatter-field source): inside the source region -incident light(入射光) and scattering light(散射光) outside the source region -only scatter light TPSF示意图 (粉色箭头表示入射光入射方向,蓝色箭头表示电场振动方向) (白色区域内包含入射场和散射场,白色区域外只有散射场,方便计算) Gaussian source: represnts light from laser source(激光器) or light from anobjective lens(物镜) with a given NA (nonperiodic) (Grating Coupler) Mode source: represents eigen modes (e.g. TE/TM) in waveguides(表示波导中的本征模式) 补充: 补充 Simulation region Boundary condition PML: perfectly matched layer, 100% absorption, 0% reflection Metal: perfect electric conductor (PEC) 100% reflection, 0% absorption (usually used when there is nearly no light at the boundaries of simulation region, because it takes the shortest time to simulate using Metal boundaries) Periodic boundaries: used when the structures and field prolife are periodic ,for vertical incident light Bloch boundaries: similar to periodic boundaries, but for angled incident light (periodic/bloch boundaries work with plane wave) Symmetric/anti-symmetric boundaries: used when the structures and field are symmetric or anti-symmetric (e.g. TE mode, positive electric field against negative electric field) tips A tip for set-up: apply symmetric conditions to the boundaries which are parallel to theblue arrow of light (representing the electric field) symmetric/anti-symmetric boundaries 平行于蓝色线设置对称的边界条件 垂直于蓝色线设置设置反对称的边界条件 PML boundaries and dipole sources PML boundaries and dipole sources Materials and Monitor material and monitor 反射谱和透射谱(微环结构) 反射谱和透射谱(微环结构) Applications of FDTD: nanophotonic devices with aribitrary shape application Intergrated Optics: 集成光学 CMOs image sensors: 图像传感器 Solar Cells: 太阳能电池 OLEDs(OrganicLight-Emitting Diode): 有机发光二极管 Nanoparticles: 纳米粒子 Plasmonics: 等离子体 Liquid crystals: 液晶 photonic crystals: 光子晶体 Grating devices: 光栅器件 Lithography: 光刻 Metamaterials: 超材料 Defect detection: 缺陷检测 预告: 下次写MODE","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"文献阅读(二)硅基光栅耦合器","slug":"文献阅读记录/文献阅读-二-硅基光栅耦合器","date":"2022-01-29T12:20:49.000Z","updated":"2022-02-14T15:41:31.124Z","comments":true,"path":"2022/01/29/文献阅读记录/文献阅读-二-硅基光栅耦合器/","link":"","permalink":"http://example.com/2022/01/29/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB-%E4%BA%8C-%E7%A1%85%E5%9F%BA%E5%85%89%E6%A0%85%E8%80%A6%E5%90%88%E5%99%A8/","excerpt":"","text":"光栅耦合器主要性能指标和优点 (个人理解) 1）耦合效率(coupling efficiency)(表示能量损耗) 2）带宽(bandwidth)(表示信息传输的能力) 3）偏振依赖性(polarization dependency) (偏振依赖损耗（PDL）是指具有偏振特性的光信号，在光纤、光器件或由它们组成的网络传输过程中，由于光的偏振特性变化而引起的光功率变化) 4）对准容差(alignment tolerance)(与实际生产工艺有关) 优点 光栅耦合器的主要优点在于其位置比较灵活，可位于芯片中的任意位置，因而可用于晶圆级的在线测试，另外其耦合的对准容差较大，便于封装。但是其耦合效率不太高，并且带宽较小(1dB带宽约30-40nm)，1维GC是偏振敏感的。 光栅耦合器类型和特性 光栅耦合器的主要研究内容包括耦合效率、耦合角度、工作波长带宽、偏振相关性等 光栅耦合器的耦合效率是由衍射强度、方向性效率和耦合光场重叠积分三个部分共同决定的 偏振相关性概念? 硅基光栅耦合器件可分为一维结构和二维结构, 根据光栅单元的周期、占空比、刻蚀深度、刻蚀角度的不同又可分为均匀光栅耦合器、非均匀光栅耦合器以及闪耀光栅耦合器等 啁啾的最简单定义是信号频率随时间变化，在脉冲前后沿由于调制产生频率变化，使信号频谱展宽 高效率非均匀耦合结构 均匀光栅耦合器是指每个光栅的单元周期、占空比、刻蚀深度均为恒定值 ,但是均匀光栅耦合器对的重叠积分受到限制,耦合效率较低 均匀光栅耦合器的优点 CMOS 工艺兼容, 工艺相对简单 对均匀结构的研究比较全面, 加工方法比较成熟 非均匀光栅耦合器, 是指周期和占空比甚至刻蚀深度随光传播方向改变的一种准周期结构 由于工艺上的难题, 这种光栅耦合器结构从理论提出以后发展缓 慢 垂直耦合结构 一直以来, 为了降低二阶反射, 从而提高耦合效率, 光栅耦合器的衍射方向呈 10◦ 左右的偏角 限制实际应用和封装困难 垂直耦合成为了继耦合效率之后限制光栅耦合器实用化的另一待解难题 最理想的消除二阶反射的方法是闪耀光栅 ,但加工要求高,与CMOS工艺不兼容 文献中的课题组提出了一种缓变阶梯型闪耀光栅耦合器,用多阶梯结构替代闪耀光栅的倾斜面 (这是属于正向设计) 二维光栅耦合器 二维光栅耦合器大致可分为两种, 一种是类似光子晶体结构的光栅耦合器, 另一种是弧形光栅耦合器 2D 光子晶体光栅耦合器 二维光子晶体光栅耦合器是为了解决光栅波导内的偏振问题提出的 具体内容还欠缺很多基础知识... 大带宽啁啾光栅 基本概念 频率随时间变化的波叫啁啾波 如果频率随时间增加，先看到低频波后看到高频波，为正啁啾，也就是上升的前沿是低频，下降的后沿是高频。反之为负啁啾。 非均匀光栅耦合器中的啁啾结构, 就是为了提高带宽而提 出的. 相比均匀光栅耦合器, 啁啾光栅增加了一个啁啾量的概念, 通常是光栅单元周期的变化. 带宽的增加主要是由啁啾量决定的 (暂时还不是特别懂) 知识补充 TE叫做横电模，指的是电场方向与传播方向垂直的。 TM叫做横磁模，指的是磁场方向与传播方向垂直的。 TE和TM可以合称LP，线性偏振模。 TEM叫做横电磁模，指的是电场、磁场方向都和传播方向垂直的。 参考 TE、TM、TEM模的区别？ - 知乎 (zhihu.com) img 请想象一下，光线上的一个点，微观的传播方向（相速度方向）是沿着红线的方向的，如果电场方向垂直于纸面向内或向外，磁场方向就是在纸面内，与红线垂直的。那么，电场的方向与纸面垂直，就和纸面内的任意一条线垂直，就和光纤的中心线（那条虚线，群速度方向）垂直，而磁场方向则是不与这条线垂直，这就是TE模。同理，也可理解TM模吧。 传输特性有什么区别呢? 对于TE模来说，临界反射角要大一些（可以到90°？），即可以更平一些，所以在尺寸减小到一定程度时，只有TE模还可以存在。","categories":[{"name":"大创文献","slug":"大创文献","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"}],"tags":[{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"文献","slug":"文献","permalink":"http://example.com/tags/%E6%96%87%E7%8C%AE/"}],"author":"John Doe"},{"title":"文献阅读(一):硅基光栅耦合器的研究进展","slug":"文献阅读记录/文献阅读（一）硅基光栅耦合器的研究进展","date":"2022-01-28T15:47:17.000Z","updated":"2022-06-05T14:20:34.180Z","comments":true,"path":"2022/01/28/文献阅读记录/文献阅读（一）硅基光栅耦合器的研究进展/","link":"","permalink":"http://example.com/2022/01/28/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89%E7%A1%85%E5%9F%BA%E5%85%89%E6%A0%85%E8%80%A6%E5%90%88%E5%99%A8%E7%9A%84%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/","excerpt":"","text":"文献标题: 硅基光栅耦合器的研究进展 研究背景: 电互连由于电子物理特性的局限,无法适应目前日益膨胀数据传输需求. 光子在传输过程中信号较稳定,传输容量大,硅基光子器件与CMOS工艺兼容、抗辐射多种优点. 概念补充知识: 光传递信号的机理是波阻抗变换: 光耦合结构常用两种耦合方式: 端面水平耦合结构 片上垂直耦合结构 耦合器根据光纤和硅芯片的相对位置，一般可分为两种。一种是平面耦合，也称边缘耦合(Edge Coupler)，指光纤和硅芯片位于同一平面，位于芯片的侧面，通过锥形波导等方式进行耦合。另一种是垂直耦合，也就是所讲的光栅耦合(Grating Coupler，GC)。 光栅耦合器的基本原理 入射介值和出射介值折射率分别为\\(n_1\\),\\(n_2\\) 光栅矢量为\\(K\\),大小为\\(K=\\frac{2\\pi}{p}\\),其中\\(p\\)为光栅的周期 入射光波矢为\\(K_{in}\\),大小为\\(K_{in}=\\frac{2\\pi n_1}{\\lambda}\\),\\(\\lambda\\)为光波长 \\(K_{in}\\)在z方向的投影分量为\\(K_{in,z}\\),大小为\\(K_{in,z}=K_{in}sinθ\\), \\(θ\\)为入射光波矢偏离光栅法线的角度 此时各级衍射光波矢在z方向的投影可以通过布拉格条件表示为: \\[ K_{m,z}= K_{in,z}+mK (m = 0;±1;±2;±3;···) \\] \\(m\\)表示表示衍射级数. 该公式的具体含义为: m级衍射波矢在z方向的投影分量等于入射波矢在z方向的投影分量与m倍的光栅矢量之和 因此通过衍射波矢在z方向的投影分量大小和衍射波矢本身的大小可以求出各级衍射波矢的衍射角度 image-20220128233206175 光栅有效折射率\\(n_{eff}\\)的确定 根据下式: \\[ n_{eff}=dc*n_{eff1}+(1-dc)*n_{eff2} \\] \\(dc\\)(duty cycl)表示占空比,\\(n_{eff1}\\)表示未刻蚀部分波导的有效折射率, \\(n_{eff2}\\)表示刻蚀部分波导的有效折射率 img 影响光栅耦合器性能的几个因素 光的偏振方向 TM mode和TE mode在波导中传输时具有不同的有效折射率，因此光栅只能耦合特定偏振方向的光。 光栅周期 根据之前公式，光栅周期越大，衍射的中心波长(刚好满足Bragg条件的波长)也越大。 占空比 占空比越大，有效折射率也越大(宽波导较窄波导，更接近与自由传播，因此有效折射率大)，因此中心波长也越大。 刻蚀深度 刻蚀深度能影响 \\(n_{eff2}\\)，刻蚀越深,\\(n_{eff2}\\) 越小，\\(n_{eff}\\) 也减小，导致中心波长减小。 入射角 入射角越大，中心波长越小。 复习内容: 光栅衍射 光栅常量:\\(d=a+b\\) 光栅方程(明纹):$dsin=k,k=0,1,2... $ 缺级\\(k=k&#39;\\frac{d}{a},k&#39;=1,2,3...\\) 缺级原因: 这是因为光经过光栅时，不仅每个狭缝发生衍射，而且缝与缝之间的衍射光波相遇叠加时还要发生干涉。 倾斜入射的光栅公式：\\(d(sin\\varphi\\pm sin\\theta)=\\pm k \\lambda ,k=0,1,2...\\) 布拉格衍射 布拉格衍射公式:\\(2dsin\\theta=n\\lambda\\),其中n是衍射级数，d是不同层之间的间距。","categories":[{"name":"大创文献","slug":"大创文献","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"}],"tags":[{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"文献","slug":"文献","permalink":"http://example.com/tags/%E6%96%87%E7%8C%AE/"}]},{"title":"多元函数概念及极限","slug":"多元函数概念及极限","date":"2022-01-24T09:34:14.344Z","updated":"2022-01-25T17:32:01.374Z","comments":true,"path":"2022/01/24/多元函数概念及极限/","link":"","permalink":"http://example.com/2022/01/24/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9E%81%E9%99%90/","excerpt":"","text":"多元函数概念 平面点集 \\[ (x, y) \\text { 的 全 体 } R^{2}=\\{(x, y) \\mid x \\in R, y \\in R\\} \\] 定义：坐标平面上具有某种性质的点集 \\[ \\varepsilon =\\left\\{ \\left( x,y \\right) |x^2+y^2&lt;1 \\right\\} \\] \\[ \\varepsilon =\\left\\{ \\left( x,y \\right) |x^2+y^2=1 \\right\\} \\] 邻域 \\[ 设 P_{0}\\left(x_{0}, y_{0}\\right) 是 xoy 平面一个点， \\delta ,\\\\\\quad u\\left(p_{0}, \\delta\\right)=\\left\\{\\left|p p_{0}\\right|&lt;\\delta\\right\\} 为 p_{0}的邻域 \\] 点概念 内点： $ PE $ P周边所有的点都属于E。 外点： \\(P\\notin E\\) P周边所有的点都不属于E。 边界点： P周边和P自己既有属于E的，又有不属于E的。 所有边界点的集合记作\\(\\partial \\text{E}\\) 聚点: 对于任给的\\(\\delta&gt;0\\),点p的去心邻域\\(\\stackrel{\\circ}{U}\\left(P_{0}, \\delta\\right)\\) 内总有E中的点，那么称P是E的聚点。 函数极限 设二元函数\\(f(p)=f(x,y)\\)的定义域为\\(D\\),\\(P_{0}\\left(x_{0}, y_{0}\\right)\\)是\\(D\\)的聚点，如果存在常数\\(A\\)，对于任意给定的正数\\(\\epsilon\\) ,总存在正数\\(\\delta\\)，使得当点\\(p(x,y)∈D∩\\stackrel{\\circ}{U}\\left(P_{0}, \\delta\\right)\\)都有 \\[ |f(P)-A|=|f(x, y)-A|&lt;\\varepsilon \\] 成立，那么就称常数\\(A\\)为函数\\(f(x,y)\\)当\\((x,y)\\rightarrow(x_0,y_0)\\)的极限,记作 \\[ \\lim _{(x, y) \\rightarrow\\left(x_{0}, y_{0}\\right)} f(x, y)=A \\] 函数连续 定义: 设二元函数\\(f(P)=f(x,y)\\)的定义域为\\(D\\) ,\\(P_{0}\\left(x_{0}, y_{0}\\right)\\)为\\(D\\)的聚点,且\\(P_{0}\\in D\\) 如果 \\[ \\lim _{(x, y) \\rightarrow\\left(x_{0}, y_{0}\\right)} f(x, y)=f(x_0,y_0) \\] 那么称函数\\(f(x,y)\\)在点\\(p_0(x_0,y_0)\\)连续.","categories":[{"name":"高数","slug":"高数","permalink":"http://example.com/categories/%E9%AB%98%E6%95%B0/"}],"tags":[{"name":"高数","slug":"高数","permalink":"http://example.com/tags/%E9%AB%98%E6%95%B0/"}]},{"title":"markdown 基本语法","slug":"markdown 基本语法","date":"2022-01-24T05:46:50.120Z","updated":"2022-01-24T09:06:09.752Z","comments":true,"path":"2022/01/24/markdown 基本语法/","link":"","permalink":"http://example.com/2022/01/24/markdown%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"标题语法 123# 一级标题## 二级标题### 三级标题 段落语法 创建段落时使用空白行将多行文本分隔 不要使用空格或锁进府缩进段落 123I really like using Markdown.I think I&#x27;ll use it to format all of my documents from now on. 换行语法 1&lt;br&gt; or 两个或多个空格进行换行 强调语法 123456789101112设置粗体两个星号或两个下划线**内容**（推荐使用）__内容__设置斜体一个星号或一个下划线*内容*（推荐使用）_内容_同时添加粗体和斜体三个星号或三个下划线 引用语法 创建块引用，在段落前添加一个&gt;符号 块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。 实际效果： 嵌套效果： 列表语法 分为有序列表和无序列表 有序列表 序号加上.和空格 1231. first2. second3. third 1. first 2. second 3. third 无序列表 语法：*、+、- first second third indented 代码语法 将单词表示为代码，将单词包裹在反引号`中 代码块 将代码块的每一行缩进至少四个空格或一个制表符 代码块 ​ 分隔线 123***---________ 链接语法 1这是一个链接 [Markdown语法](https://markdown.com.cn)。 超链接Markdown语法代码：[超链接显示名](超链接地址 \"超链接title\") 图片语法 插入图片Markdown语法代码：![图片alt](图片链接 \"图片title\")。 page","categories":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}],"categories":[{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/categories/IELTS/"},{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"},{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"},{"name":"汇率","slug":"汇率","permalink":"http://example.com/categories/%E6%B1%87%E7%8E%87/"},{"name":"量子力学","slug":"量子力学","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"},{"name":"大创文献","slug":"大创文献","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"},{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"仿真实例","slug":"Lumerical/仿真实例","permalink":"http://example.com/categories/Lumerical/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"},{"name":"高数","slug":"高数","permalink":"http://example.com/categories/%E9%AB%98%E6%95%B0/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"writing task2","slug":"writing-task2","permalink":"http://example.com/tags/writing-task2/"},{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"inverse design","slug":"inverse-design","permalink":"http://example.com/tags/inverse-design/"},{"name":"柯西公式","slug":"柯西公式","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%85%AC%E5%BC%8F/"},{"name":"不定积分","slug":"不定积分","permalink":"http://example.com/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"},{"name":"柯西定理","slug":"柯西定理","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%86/"},{"name":"复变函数","slug":"复变函数","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"汇率","slug":"汇率","permalink":"http://example.com/tags/%E6%B1%87%E7%8E%87/"},{"name":"薛定谔方程","slug":"薛定谔方程","permalink":"http://example.com/tags/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B/"},{"name":"多值函数","slug":"多值函数","permalink":"http://example.com/tags/%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0/"},{"name":"数学物理方法","slug":"数学物理方法","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"},{"name":"量子力学作业","slug":"量子力学作业","permalink":"http://example.com/tags/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%BD%9C%E4%B8%9A/"},{"name":"德布罗意波","slug":"德布罗意波","permalink":"http://example.com/tags/%E5%BE%B7%E5%B8%83%E7%BD%97%E6%84%8F%E6%B3%A2/"},{"name":"波尔理论","slug":"波尔理论","permalink":"http://example.com/tags/%E6%B3%A2%E5%B0%94%E7%90%86%E8%AE%BA/"},{"name":"黑体辐射\\光电效应\\康普顿散射","slug":"黑体辐射-光电效应-康普顿散射","permalink":"http://example.com/tags/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84-%E5%85%89%E7%94%B5%E6%95%88%E5%BA%94-%E5%BA%B7%E6%99%AE%E9%A1%BF%E6%95%A3%E5%B0%84/"},{"name":"script","slug":"script","permalink":"http://example.com/tags/script/"},{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"},{"name":"Grating Coupler","slug":"Grating-Coupler","permalink":"http://example.com/tags/Grating-Coupler/"},{"name":"数字电路","slug":"数字电路","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"离散数学","slug":"离散数学","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"仿真实例","slug":"仿真实例","permalink":"http://example.com/tags/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"},{"name":"大创","slug":"大创","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"文献","slug":"文献","permalink":"http://example.com/tags/%E6%96%87%E7%8C%AE/"},{"name":"高数","slug":"高数","permalink":"http://example.com/tags/%E9%AB%98%E6%95%B0/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}