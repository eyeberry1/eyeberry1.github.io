{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-01-21T06:33:28.741Z","updated":"2022-01-21T06:33:28.733Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"email: zhengbw7@mail2.sysu.edu.cn QQ: 1031266377"},{"title":"tags","date":"2022-01-20T16:16:45.000Z","updated":"2022-01-20T16:29:06.691Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"talk","date":"2022-01-20T09:14:15.000Z","updated":"2022-09-25T14:01:31.741Z","comments":true,"path":"talk/index.html","permalink":"http://example.com/talk/index.html","excerpt":"","text":"è¿˜ä¸çŸ¥é“è·Ÿå„ä½è¯´ä»€ä¹ˆå‘¢ï¼Ÿï¼šï¼‰"}],"posts":[{"title":"The Impact of Increasing Proportion of Elderly Population","slug":"IELTS/writing/å¤§ä½œæ–‡èŒƒæ–‡2","date":"2024-03-19T09:21:53.373Z","updated":"2024-03-19T10:25:48.366Z","comments":true,"path":"2024/03/19/IELTS/writing/å¤§ä½œæ–‡èŒƒæ–‡2/","link":"","permalink":"http://example.com/2024/03/19/IELTS/writing/%E5%A4%A7%E4%BD%9C%E6%96%87%E8%8C%83%E6%96%872/","excerpt":"","text":"Q In many countries, the proportion of older people is steadily increasing. Does this trend have positive or negative effects on society. A In numerous countries, there is a noticeable and consistent rise in the proportion of elderly individuals. This trend has sparked debates regarding its potential positive or negative effects on society. This essay delves into the possible ramifications of this phenomenon and arrives at a conclusion. To begin with, the growing elderly population could yield several positive effects on society. Firstly, advancements in medical technology have made high-quality healthcare services more accessible, leading to extended lifespans. This implies that a greater number of elderly individuals can continue contributing to society by imparting knowledge and experience, thus fostering societal stability and development. Furthermore, elderly individuals can play vital caregiving roles within families and communities, supporting the growth and development of the younger generation. However, the increase in the elderly population may also bring about certain negative repercussions. Primarily, it could exert pressure on governments and social welfare systems, as they would need to provide more pensions and medical services. This might lead to issues such as increased fiscal burdens and uneven resource allocation. Additionally, aging could result in labor market strains, as the decrease in labor supply might lead to decreased productivity and slowed economic growth. In conclusion, the increasing elderly population has both positive and negative impacts on society. Nevertheless, through prudent planning and policy formulation, it is possible to maximize the potential of the elderly demographic and promote the sustained development of society. Therefore, I believe that the impact of this trend on society is twofold, contingent upon how we address and harness the opportunities and challenges posed by the growth of the elderly population. two-edged sword Good phase and sentence S1 This trend has sparked debates regarding its potential positive or negative effects on society. S2 This essay delves into the possible ramifications of this phenomenon and arrives at a conclusion. S3 Firstly, advancements in medical technology have made high-quality healthcare services more accessible, leading to extended lifespans life expectancy lifespan[C.] S4 Furthermore, elderly individuals can play vital caregiving roles within families and communities, supporting the growth and development of the younger generation. S5 Primarily, it could exert pressure on governments and social welfare systems, as they would need to provide more pensions and medical services. S6 This might lead to issues such as increased fiscal burdens and uneven resource allocation. S7 Additionally, aging could result in labor market strains, as the decrease in labor supply might lead to decreased productivity and slowed economic growth. S8 Nevertheless, through prudent planning and policy formulation, it is possible to maximize the potential of the elderly and promote the sustained development of society. ç¤¾ä¼šæŒç»­å‘å±• S9 Therefore, I believe that the impact of this trend on society is twofold, contingent upon how we address and harness the opportunities and challenges posed by the growth of the elderly population. contingent upon ï¼š depending on something else in the future in order to happen P yield several positive effects impart knowledge and experience, thus fostering societal stability and development. foster societal bring about certain negative repercussions. repercussionsï¼šthe effect that an action, event, or decision has on something, especially a bad effect fiscal burdens and uneven resource allocation fiscal è´¢æ”¿çš„ï¼Œå›½åº“çš„ connected with (public) money labor market strains prudent planing prudent: sensible and careful when you make judgements and decisions; avoiding unnecessary risks prudent finance prudent investment prudent shopping policy formulation æ”¿ç­–è§„åˆ’ï¼›æ”¿ç­–åˆ¶å®šï¼›æ”¿ç­–å½¢æˆ address and harness","categories":[{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/categories/IELTS/"}],"tags":[{"name":"writing task2","slug":"writing-task2","permalink":"http://example.com/tags/writing-task2/"}]},{"title":"æ”¿åºœæ˜¯å¦è¯¥æ”¯æŒæœ¬åœŸç”µå½±","slug":"IELTS/writing/å¤§ä½œæ–‡èŒƒæ–‡1","date":"2024-03-17T13:47:45.209Z","updated":"2024-03-17T13:53:02.411Z","comments":true,"path":"2024/03/17/IELTS/writing/å¤§ä½œæ–‡èŒƒæ–‡1/","link":"","permalink":"http://example.com/2024/03/17/IELTS/writing/%E5%A4%A7%E4%BD%9C%E6%96%87%E8%8C%83%E6%96%871/","excerpt":"","text":"Q Many people prefer to watch foreign films rather than locally produced films. Why could this be? Should governments give more financial support to local film industries? A â€‹ It is true that foreign films are more popular in many countries than domestically produced films. There could be several reasons why this is the case, and I believe that governments should promote local film-making by subsidising the industry. â€‹ There are various reasons why many people find foreign films more enjoyable than the films produced in their own countries. Firstly, the established film industries in certain countries have huge budgets for action, special effects and to shoot scenes in spectacular locations. Hollywood blockbusters like â€˜Avatarâ€™ or the James Bond films are examples of such productions and the global appeal that they have. Another reason why these big-budget films are so successful is that they often star the most famous actors and actresses, and they are made by the most accomplished producers and directors. The poor quality, low-budget filmmaking in many countries suffers in comparison. â€‹ In my view, governments should support local film industries financially. In every country, there may be talented amateur film-makers who just need to be given the opportunity to prove themselves. To compete with big-budget productions from overseas, these people need money to pay for film crews, actors and a host of other costs related to producing high-quality films. If governments did help with these costs, they would see an increase in employment in the film industry, income from film sales, and perhaps even a rise in tourist numbers. New Zealand, for example, has seen an increase in tourism related to the 'Lord of the Rings' films, which were partly funded by government subsidies. â€‹ In conclusion, I believe that increased financial support could help to raise the quality of locally made films and allow them to compete with the foreign productions that currently dominate the market.","categories":[{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/categories/IELTS/"}],"tags":[{"name":"writing task2","slug":"writing-task2","permalink":"http://example.com/tags/writing-task2/"}]},{"title":"inverse design of grating coupler -- process presentation","slug":"Lumerical/inverse designè¿‡ç¨‹å±•ç¤º(è¯¦ç»†)","date":"2022-10-20T11:35:03.690Z","updated":"2022-10-20T12:19:39.806Z","comments":true,"path":"2022/10/20/Lumerical/inverse designè¿‡ç¨‹å±•ç¤º(è¯¦ç»†)/","link":"","permalink":"http://example.com/2022/10/20/Lumerical/inverse%20design%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA(%E8%AF%A6%E7%BB%86)/","excerpt":"","text":"preliminary_design_lms ä¿®æ”¹ä¸ºæ‰€éœ€çš„ç»“æ„ å…¶æ¬¡éœ€è¦ä¿®æ”¹preliminary_design_lsfå†…çš„å‚æ•° å¯ä¿®æ”¹çš„å‚æ•°æœ‰ å…¥å°„è§’åº¦ æ³¢å¯¼çš„åšåº¦ waveguide_thickness èš€åˆ»æ·±åº¦ etch(ä¸»è¦) åˆå§‹çš„å ç©ºæ¯”(ä¸»è¦) ææ–™çš„æŠ˜å°„ç‡ å…‰æ …å¼€å§‹çš„èµ·å§‹ä½ç½® å˜è¿¹ç³»æ•°R base.fsp æ‰«æå…‰æºä½ç½®çš„è®¾ç½® å…‰æºçš„è®¾ç½® åŸºæœ¬ç»“æ„çš„è®¾ç½® base.lsfå‚æ•°ä¿®æ”¹ å¯ä»¥é€šè¿‡ä¸­æ–­pythonçš„è¿‡ç¨‹åœ¨baseæ–‡ä»¶ä¸­åŠ å…¥æ³¢å¯¼ç»“æ„ apodized.fsp è¿è¡Œapodized.pyçš„è„šæœ¬ï¼Œå°†æ³¢å¯¼ç»“æ„ç¡®å®šä¿å­˜åˆ°apodized.fspå†… final.fsp è¿è¡Œetch.pyçš„è„šæœ¬","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"inverse design","slug":"inverse-design","permalink":"http://example.com/tags/inverse-design/"}]},{"title":"æŸ¯è¥¿å…¬å¼","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/æŸ¯è¥¿å…¬å¼","date":"2022-10-05T08:54:43.427Z","updated":"2022-10-05T10:54:47.954Z","comments":true,"path":"2022/10/05/æ•°å­¦ç‰©ç†æ–¹æ³•/æŸ¯è¥¿å…¬å¼/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E6%9F%AF%E8%A5%BF%E5%85%AC%E5%BC%8F/","excerpt":"","text":"å•è¿é€šåŒºåŸŸ å¤è¿é€šåŒºåŸŸ ä¾‹é¢˜ æ— ç•ŒåŒºåŸŸå†…çš„æŸ¯è¥¿å…¬å¼ é«˜é˜¶å¯¼æ•° ä¾‹é¢˜","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"æŸ¯è¥¿å…¬å¼","slug":"æŸ¯è¥¿å…¬å¼","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%85%AC%E5%BC%8F/"}]},{"title":"ä¸å®šç§¯åˆ†","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/ä¸å®šç§¯åˆ†","date":"2022-10-05T08:40:20.967Z","updated":"2022-10-05T08:54:07.130Z","comments":true,"path":"2022/10/05/æ•°å­¦ç‰©ç†æ–¹æ³•/ä¸å®šç§¯åˆ†/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/","excerpt":"","text":"ä¾‹é¢˜","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"ä¸å®šç§¯åˆ†","slug":"ä¸å®šç§¯åˆ†","permalink":"http://example.com/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"}]},{"title":"æŸ¯è¥¿å®šç†","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/æŸ¯è¥¿å®šç†","date":"2022-10-05T08:32:46.247Z","updated":"2022-10-05T08:54:51.194Z","comments":true,"path":"2022/10/05/æ•°å­¦ç‰©ç†æ–¹æ³•/æŸ¯è¥¿å®šç†/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%86/","excerpt":"","text":"é‡è¦ä¾‹é¢˜","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"æŸ¯è¥¿å®šç†","slug":"æŸ¯è¥¿å®šç†","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%86/"}]},{"title":"å¤å˜å‡½æ•°--ç§¯åˆ†","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/å¤å˜å‡½æ•°ç§¯åˆ†","date":"2022-10-05T08:08:02.730Z","updated":"2022-10-05T08:32:33.162Z","comments":true,"path":"2022/10/05/æ•°å­¦ç‰©ç†æ–¹æ³•/å¤å˜å‡½æ•°ç§¯åˆ†/","link":"","permalink":"http://example.com/2022/10/05/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86/","excerpt":"","text":"è®¡ç®—æ–¹æ³•ä¸€ è®¡ç®—æ–¹æ³•äºŒ ç§¯åˆ†æ€§è´¨ ä¾‹é¢˜","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"å¤å˜å‡½æ•°","slug":"å¤å˜å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"","slug":"Lumerical/å‚æ•°è®¾ç½®è®°å½•","date":"2022-10-04T07:04:13.563Z","updated":"2022-10-04T08:49:49.674Z","comments":true,"path":"2022/10/04/Lumerical/å‚æ•°è®¾ç½®è®°å½•/","link":"","permalink":"http://example.com/2022/10/04/Lumerical/%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/","excerpt":"","text":"title: å‚æ•°è®¾ç½®è®°å½• categories: Lumerical tags: Lumerical Grating Coupler å…¥å°„è§’åº¦å›ºå®šä¸º15Â° åˆ»èš€æ·±åº¦å›ºå®šä¸º0.8um","categories":[],"tags":[]},{"title":"æ±‡ç‡","slug":"stock stares/æ±‡ç‡","date":"2022-09-30T16:53:25.302Z","updated":"2022-09-30T17:02:23.715Z","comments":true,"path":"2022/10/01/stock stares/æ±‡ç‡/","link":"","permalink":"http://example.com/2022/10/01/stock%20stares/%E6%B1%87%E7%8E%87/","excerpt":"","text":"å®šåˆ¶æ±‡ç‡ è´­ä¹°åŠ›å¹³ä»·ç†è®º ä¸€ç¯®å­å•†å“çš„ä»·æ ¼è¿›è¡ŒåŠ æƒå¹³å‡ é‡‘å¹³ä»· è´§å¸ä¸­çš„é‡‘å±ä»·å€¼ è¿›å‡ºå£çš„è´¸æ˜“é¡ºå·®å’Œé€†å·® å½±å“æ±‡ç‡ è´§å¸æ”¿ç­–çš„è‡ªä¸»å’Œä¾èµ– é‡‘èå¸‚åœºçš„å¼€æ”¾ä¸å°é—­ è’™ä»£å°”ä¸å¯èƒ½ä¸‰è§’å½¢ èµ„æœ¬è‡ªç”±æµåŠ¨ è´§å¸æ”¿ç­–ç‹¬ç«‹ æ±‡ç‡çš„å›ºå®š ä¸‰é€‰äºŒ ä¸­å›½æ˜¯é€‰çš„åä¸¤ä¸ª æ³°å›½çš„é‡‘èå±æœº","categories":[{"name":"æ±‡ç‡","slug":"æ±‡ç‡","permalink":"http://example.com/categories/%E6%B1%87%E7%8E%87/"}],"tags":[{"name":"æ±‡ç‡","slug":"æ±‡ç‡","permalink":"http://example.com/tags/%E6%B1%87%E7%8E%87/"}]},{"title":"è–›å®šè°”æ–¹ç¨‹","slug":"é‡å­åŠ›å­¦/W2/è–›å®šè°”æ–¹ç¨‹","date":"2022-09-12T06:44:34.940Z","updated":"2022-09-12T06:45:37.158Z","comments":true,"path":"2022/09/12/é‡å­åŠ›å­¦/W2/è–›å®šè°”æ–¹ç¨‹/","link":"","permalink":"http://example.com/2022/09/12/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W2/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"é‡å­åŠ›å­¦","slug":"é‡å­åŠ›å­¦","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"è–›å®šè°”æ–¹ç¨‹","slug":"è–›å®šè°”æ–¹ç¨‹","permalink":"http://example.com/tags/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B/"}]},{"title":"å¤šå€¼å‡½æ•°","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/å¤šå€¼å‡½æ•°","date":"2022-09-11T08:15:07.465Z","updated":"2022-09-11T08:57:23.320Z","comments":true,"path":"2022/09/11/æ•°å­¦ç‰©ç†æ–¹æ³•/å¤šå€¼å‡½æ•°/","link":"","permalink":"http://example.com/2022/09/11/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0/","excerpt":"","text":"åˆç­‰è§£æå‡½æ•°ä¸¾ä¾‹ å•å€¼å‡½æ•° æ•´æ•°å¹‚å‡½æ•°\\(Z^n\\) æŒ‡æ•°å‡½æ•°e^z ä¸‰è§’å‡½æ•° åŒæ›²å‡½æ•° å¤šå€¼å‡½æ•° æ ¹å¼å‡½æ•° é»æ›¼é¢ å¯¹æ•°å‡½æ•°","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"å¤šå€¼å‡½æ•°","slug":"å¤šå€¼å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0/"},{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}]},{"title":"é‡å­åŠ›å­¦ç¬¬ä¸€ç« ä½œä¸š","slug":"é‡å­åŠ›å­¦/W1/ç¬¬ä¸€ç« ä½œä¸š","date":"2022-09-11T07:33:01.889Z","updated":"2024-03-17T13:46:51.485Z","comments":true,"path":"2022/09/11/é‡å­åŠ›å­¦/W1/ç¬¬ä¸€ç« ä½œä¸š/","link":"","permalink":"http://example.com/2022/09/11/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"Q1 æ³¢é•¿ä¸ºÎ»= 1Ã…çš„Xå…‰ï¼Œæ±‚å…‰å­çš„è´¨é‡? è§£: æ ¹æ®å¾·å¸ƒç½—æ„æ³¢é•¿å…¬å¼ \\[ \\lambda=\\frac{h}{\\sqrt{2Em}}\\tag{1} \\] \\[ \\begin{align} E&amp;=hv\\\\ &amp;=h\\frac{c}{\\lambda}\\tag{2} \\end{align} \\] ç»¼åˆ(1)å¼(2)å¼ \\[ \\begin{align} \\lambda&amp;=\\frac{h}{\\sqrt{2Em}}\\\\ &amp;=\\frac{h}{\\sqrt{2hvm}}\\\\ m&amp;=\\frac{h}{2v\\lambda^2}\\\\ &amp;=\\frac{h}{2c\\lambda}\\\\ &amp;=\\frac{6.63\\times10^{-34}}{2\\times2.99792\\times10^8\\times1\\times10^{-10}}kg\\\\ &amp;=1.106\\times10^{-32}kg \\end{align} \\] Q2. æŸé‡‘å±äº§ç”Ÿå…‰ç”µæ•ˆåº”çš„çº¢é™é¢‘ç‡ä¸ºv0 ï¼Œå½“ç”¨é¢‘ç‡ä¸ºv(v &gt;v0 )çš„å•è‰²å…‰ç…§å°„è¯¥é‡‘å±æ—¶ï¼Œæ±‚ä»é‡‘å±ä¸­é€¸å‡ºçš„å…‰ç”µå­(è´¨é‡ä¸ºm)çš„å¾·å¸ƒç½—æ„æ³¢é•¿? è§£: æ ¹æ®çº¢é™é¢‘ç‡ä¸º\\(v_0\\) \\[ \\text{æŸç¼šèƒ½}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ A=hv_0\\tag{1} \\] ç”±å…‰ç”µæ•ˆåº”æ–¹ç¨‹ \\[ E_k=hv-A\\tag{2} \\] æ ¹æ® \\[ p^2=2mE_k\\tag{3} \\] å¾·å¸ƒç½—æ„æ³¢é•¿ \\[ \\lambda=\\frac{h}{p}\\tag{4} \\] ç”±(1)(2)(3)(4)å¼å¯å¾— \\[ \\lambda=\\sqrt{\\frac{h}{2m(v-v_0)}} \\] Q3. ä¸¤ä¸ªå…‰å­åœ¨ä¸€å®šæ¡ä»¶ä¸‹å¯ä»¥è½¬åŒ–æˆæ­£è´Ÿç”µå­å¯¹ï¼Œå¦‚æœä¸¤å…‰å­èƒ½é‡ç›¸ç­‰ï¼Œæ±‚è¦å®ç°è½¬åŒ–çš„å…‰å­æ³¢é•¿æœ€å¤§æ˜¯å¤šå°‘? è§£: æ ¹æ®èƒ½åŠ¨é‡å…³ç³»: \\[ E^2=(m_ec^2)^2+(p_ec)^2 \\] ä¸ºäº†ä½¿è½¬åŒ–çš„å…‰å­æ³¢é•¿æœ€å¤§ï¼Œåˆ™è¦æ±‚äº§ç”Ÿçš„ç”µå­å¯¹çš„åŠ¨é‡ä¸º0 ç”±è´¨èƒ½æ–¹ç¨‹ \\[ E=hv=m_ec^2\\tag{1} \\] å…‰å­çš„èƒ½åŠ¨é‡å…³ç³» \\[ E=pc=\\frac{hc}{\\lambda}\\tag{2} \\] ç»¼åˆ(1)(2)å¼å¯å¾— \\[ \\begin{align} \\lambda&amp;=\\frac{h}{m_ec}\\\\ &amp;=\\frac{6.63\\times10^{-34}J\\cdot s}{0.911\\times 10^{-30}Kg\\times 3\\times10^8m\\cdot s^{-1}}\\\\ &amp;=2.426\\times 10^{-12}m \\end{align} \\] Q4. æŒ‰ç»å°”ç†è®ºï¼Œå½“ç”µå­è½°å‡»åŸºæ€æ°¢åŸå­æ—¶ï¼Œå¦‚æœä»…äº§ç”Ÿä¸€æ¡å…‰è°±çº¿ï¼Œæ±‚è¯¥ç”µå­çš„èƒ½é‡èŒƒå›´? è§£: æ ¹æ®é¢˜æ„,ç”µå­çš„èƒ½é‡èƒ½å¤Ÿæ»¡è¶³ä¸€çº§åˆ°äºŒçº§è½¨é“çš„èƒ½é‡è€Œä¸æ»¡è¶³ä¸€çº§åˆ°ä¸‰çº§è½¨é“çš„èƒ½é‡ å› æ­¤ \\[ \\begin{align} E&amp;=T+V\\\\ &amp;=-\\frac{k^2me^4}{2n^2\\hbar^2}\\\\ &amp;=-\\frac{me^4}{2\\varepsilon^2h^2}\\cdot \\frac{1}{n^2}\\\\ &amp;=E_n\\ \\ \\ \\ \\ \\ \\ \\ \\ &amp;\\text{ç¬¬nè½¨é“ç”µå­æ€»èƒ½é‡} \\end{align} \\] ç”µå­èƒ½é‡èŒƒå›´ \\[ E_2-E_1&lt;E_e&lt;E_3-E_1 \\] å³ \\[ 8.2275\\times10^6J&lt;E_e&lt;9.59875\\times10^6J \\] Q4. å°„è‡³å…‰é˜´æä¸Šçš„å…‰ï¼Œå…¶æ³¢é•¿ä»4000Ã…å˜è‡³3000Ã…ï¼Œæ±‚å‘å°„å‡ºçš„å…‰ç”µå­çš„éåˆ¶ç”µå‹å˜åŒ–? è§£: \\[ \\begin{align} \\Delta Ue&amp;=\\frac{hc}{\\lambda_1}-\\frac{hc}{\\lambda_2}\\\\ \\Delta U&amp;=\\frac{hc}{e}(\\frac{1}{\\lambda_1}-\\frac{1}{\\lambda_2})\\\\ &amp;=\\frac{6.63\\times 10^{-34}\\times 3\\times 10^8}{1.6\\times10^{-19}}(\\frac{1}{3\\times10^{-7}}-\\frac{1}{4\\times 10^{-7}})\\\\ &amp;=1.04V \\end{align} \\]","categories":[{"name":"é‡å­åŠ›å­¦","slug":"é‡å­åŠ›å­¦","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"é‡å­åŠ›å­¦ä½œä¸š","slug":"é‡å­åŠ›å­¦ä½œä¸š","permalink":"http://example.com/tags/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%BD%9C%E4%B8%9A/"}]},{"title":"å¾·å¸ƒç½—æ„æ³¢","slug":"é‡å­åŠ›å­¦/W1/ç²’å­çš„æ³¢ç²’äºŒè±¡æ€§","date":"2022-09-10T15:19:38.504Z","updated":"2022-09-10T15:46:20.538Z","comments":true,"path":"2022/09/10/é‡å­åŠ›å­¦/W1/ç²’å­çš„æ³¢ç²’äºŒè±¡æ€§/","link":"","permalink":"http://example.com/2022/09/10/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E7%B2%92%E5%AD%90%E7%9A%84%E6%B3%A2%E7%B2%92%E4%BA%8C%E8%B1%A1%E6%80%A7/","excerpt":"","text":"å¾·å¸ƒç½—æ„å…³ç³» \\[ E=hv\\rightarrow v=E/h \\] \\[ P=h/\\lambda\\rightarrow \\lambda=h/p \\] å¾·å¸ƒç½—æ„æ³¢ ç‰©è´¨æ³¢ä¸æ˜¯é€šå¸¸çš„æ³¢ï¼Œå®ƒäº§ç”Ÿäºä»»ä½•è¿åŠ¨çš„ ç‰©è´¨ï¼Œå…·æœ‰å®¢è§‚å®åœ¨æ€§ã€‚å®ƒèƒ½åœ¨ç»å¯¹çœŸç©ºä¸­ ä¼ æ’­ï¼Œå› æ­¤ä¸æ˜¯æœºæ¢°æ³¢ï¼›å®ƒäº§ç”Ÿäºæ‰€æœ‰çš„ç‰© ä½“ï¼ŒåŒ…æ‹¬ä¸å¸¦ç”µçš„ç‰©è´¨ï¼Œå› æ­¤ä¸æ˜¯ç”µç£æ³¢ã€‚ æ³¢å‡½æ•°(é‡ç‚¹) æ²¿å•ä½çŸ¢é‡ n æ–¹å‘ä¼ æ’­é¢‘ç‡Ï‰å’Œæ³¢çŸ¢Rçš„å¹³é¢æ³¢å¯è¡¨ç¤ºä¸º: \\[ \\psi=A\\cos{(\\vec k\\cdot\\vec r-\\omega t)} =Ae^{i(\\vec k\\cdot\\vec r-\\omega t)} \\] \\[ \\vec k =\\frac{2\\pi}{\\lambda}\\vec n,\\ \\ \\omega=2\\pi v \\] ç”±äº \\[ \\vec k=\\frac{\\vec p}{\\hbar},\\ \\ \\ \\omega=\\frac{E}{\\hbar} \\] \\[ \\psi=Ae^{i(\\frac{\\vec P}{\\hbar}\\cdot\\vec r-\\frac{E}{\\hbar}t)}=Ae^{\\frac{i}{\\hbar}(\\vec P\\vec r-Et)} \\] å¾·å¸ƒç½—æ„æ³¢é•¿ éç›¸å¯¹è®ºæ¡ä»¶ä¸‹\\(E=\\frac{P^2}{2m}\\) \\[ \\begin{align} P&amp;=\\frac{h}{\\lambda}\\\\ \\lambda&amp;=\\frac{h}{p}=\\frac{h}{\\sqrt{2mE}} \\end{align} \\] é©»æ³¢æ¡ä»¶ å¾·å¸ƒç½—æ„æ³¢å®éªŒè¯æ˜ å¸¸ç”¨ç‰©ç†å¸¸æ•°","categories":[{"name":"é‡å­åŠ›å­¦","slug":"é‡å­åŠ›å­¦","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"å¾·å¸ƒç½—æ„æ³¢","slug":"å¾·å¸ƒç½—æ„æ³¢","permalink":"http://example.com/tags/%E5%BE%B7%E5%B8%83%E7%BD%97%E6%84%8F%E6%B3%A2/"}]},{"title":"ç»å°”ç†è®º","slug":"é‡å­åŠ›å­¦/W1/åŸå­ç»“æ„çš„ç»å°”ç†è®º","date":"2022-09-10T12:31:22.613Z","updated":"2022-09-10T15:19:17.323Z","comments":true,"path":"2022/09/10/é‡å­åŠ›å­¦/W1/åŸå­ç»“æ„çš„ç»å°”ç†è®º/","link":"","permalink":"http://example.com/2022/09/10/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E5%8E%9F%E5%AD%90%E7%BB%93%E6%9E%84%E7%9A%84%E7%8E%BB%E5%B0%94%E7%90%86%E8%AE%BA/","excerpt":"","text":"ç»å°”å‡å®š åŸå­å…·æœ‰èƒ½é‡ä¸è¿ç»­çš„å®šæ€çš„æ¦‚å¿µ é‡å­è·ƒè¿çš„æ¦‚å¿µ é‡å­åŒ–æ¡ä»¶ ç”µå­çš„è§’åŠ¨é‡\\(L\\)åªèƒ½å–\\(\\hbar\\)çš„æ•´æ•°å€ \\[ \\begin{align} L&amp;=n\\hbar\\\\ \\text{å…¶ä¸­},n&amp;=1,2,3,... \\end{align} \\] é¢‘ç‡æ¡ä»¶ \\[ V_{mn}=[E_n-E_m]/h \\] æ°¢åŸå­çº¿å…‰è°±çš„è§£é‡Š åº“ä»‘å®šå¾‹ \\[ F_c=\\frac{mv^2}{r}=\\frac{ke^2}{r^2}\\tag{1} \\] ç”±\\((1)\\)å¼åŒ–ç®€å¯å¾— \\[ v^2=\\frac{ke^2}{mr}\\tag{2} \\] è§’åŠ¨é‡ \\[ L=|L\\times r|=rmv=n\\hbar\\tag{3} \\] è”ç«‹\\((1)\\text{å¼}(2)\\)å¼æ¶ˆå»\\(v^2\\) \\[ r=\\frac{n^2\\hbar^2}{kme^2}\\tag{4} \\] å½“\\(n=1\\)æ—¶ï¼Œå¾—åˆ° \\[ r_0=\\frac{\\hbar^2}{kme^2}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\text{ç¬¬ä¸€ç»å°”è½¨é“åŠå¾„} \\] ç”µå­çš„èƒ½é‡ \\[ \\begin{align} T&amp;ä¸ºç”µå­åŠ¨èƒ½\\ \\ \\ \\ \\ \\ \\ \\ \\ Vä¸ºç”µå­åŠ¿èƒ½\\\\ E&amp;=T+V\\\\ &amp;=\\frac{1}{2}mv^2-\\frac{ke^2}{r}\\ \\ \\ \\ \\ &amp;\\text{ä»£å…¥(1)å¼}\\\\ &amp;=\\frac{1}{2}m\\frac{ke^2}{mr}-\\frac{ke^2}{r}\\\\ &amp;=-\\frac{ke^2}{2r}\\ \\ \\ \\ \\ &amp;\\text{ä»£å…¥(4)å¼}\\\\ &amp;=-\\frac{k^2me^4}{2n^2\\hbar^2}\\\\ &amp;=E_n\\ \\ \\ \\ \\ \\ \\ \\ \\ &amp;\\text{ç¬¬nè½¨é“ç”µå­æ€»èƒ½é‡} \\end{align} \\] æ ¹æ®é‡å­è·ƒè¿æ¦‚å¿µ \\[ \\begin{align} v=&amp;\\frac{[E_n-E_m]}{h}\\\\ &amp;=\\frac{k^2}{2\\pi \\hbar}[-\\frac{me^4}{2n^2\\hbar^2}+\\frac{k^2me^4}{2m^2\\hbar^2}]\\\\ &amp;=-\\frac{k^2me^4}{4\\pi\\hbar^3}[\\frac{1}{m^2}-\\frac{1}{n^2}]\\\\ &amp;=R_Hc[\\frac{1}{m^2}-\\frac{1}{n^2}]\\\\ \\end{align} \\] å¾—Rydberg å¸¸æ•° \\[ R_H=\\frac{k^2me^4}{4\\pi\\hbar^3c} \\] é‡å­åŒ–æ¡ä»¶çš„æ¨å¹¿ ç»å°”é‡å­è®ºçš„å±€é™æ€§","categories":[{"name":"é‡å­åŠ›å­¦","slug":"é‡å­åŠ›å­¦","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"æ³¢å°”ç†è®º","slug":"æ³¢å°”ç†è®º","permalink":"http://example.com/tags/%E6%B3%A2%E5%B0%94%E7%90%86%E8%AE%BA/"}]},{"title":"é‡å­åŠ›å­¦åŸºç¡€","slug":"é‡å­åŠ›å­¦/W1/é‡å­åŠ›å­¦åŸºç¡€","date":"2022-09-08T10:38:01.531Z","updated":"2022-09-10T13:51:22.873Z","comments":true,"path":"2022/09/08/é‡å­åŠ›å­¦/W1/é‡å­åŠ›å­¦åŸºç¡€/","link":"","permalink":"http://example.com/2022/09/08/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/W1/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"æ™®æœ—å…‹é»‘ä½“è¾å°„å®šå¾‹ ç ”ç©¶å†…å®¹ è¾å°„ä¸å‘¨å›´ç‰©è´¨å¤„äºå¹³è¡¡æ—¶èƒ½é‡åˆ†å¸ƒè§„å¾‹ã€‚ é»‘ä½“ï¼šèƒ½å¤Ÿå…¨éƒ¨å¸æ”¶è€Œä¸åå°„æŠ•å°„å…¶ä¸Šé¢çš„è¾å°„ç§°ä¸ºç»å¯¹é»‘ä½“ï¼Œç®€ç§°é»‘ä½“ã€‚ é»‘ä½“è¾å°„ï¼š ç”±è¿™æ ·çš„ç©ºè…”å°å­”å‘å‡ºçš„è¾å°„å°±ç§°ä¸ºé»‘ä½“è¾å°„ å¹³è¡¡è¾å°„çš„æ€§è´¨ å¹³è¡¡è¾å°„ï¼šå•ä½é¢ç§¯ä¸Šï¼Œå•ä½æ—¶é—´å†…è¾å°„ä¸å¸æ”¶çš„èƒ½é‡ç›¸ç­‰ã€‚ å¹³è¡¡è¾å°„æ—¶ï¼Œè¾å°„èƒ½é‡åªä¸é»‘ä½“çš„ç»å¯¹æ¸©åº¦æœ‰å…³ã€‚ ä¸¤ä¸ªå‡å®š ï¼ˆ1ï¼‰åŸå­çš„æ€§èƒ½å’Œè°æŒ¯å­ä¸€æ ·ï¼Œä»¥ç»™å®šçš„é¢‘ç‡ v æŒ¯è¡ï¼› ï¼ˆ2ï¼‰é»‘ä½“åªèƒ½ä»¥ E = hv ä¸ºèƒ½é‡å•ä½ä¸è¿ç»­çš„å‘å°„å’Œå¸æ”¶è¾å°„èƒ½é‡ ï¼Œè€Œä¸æ˜¯åƒç»å…¸ç†è®ºæ‰€è¦æ±‚çš„é‚£æ ·å¯ä»¥è¿ç»­çš„å‘å°„å’Œå¸æ”¶è¾å°„èƒ½é‡ \\[ \\rho =\\frac{8\\pi hv^3}{C^3}(\\frac {1}{e^{\\frac {hv}{KT}}-1}) \\] ä¸‰ç‚¹è®¨è®º å½“é¢‘ç‡å¾ˆå¤§æ—¶ï¼Œæ™®æœ—å…‹å®šå¾‹è½¬åŒ–ä¸ºç»´æ©ï¼ˆWienï¼‰å…¬å¼ã€‚ å½“é¢‘ç‡å¾ˆå°æ—¶ï¼Œæ™®æœ—å…‹å®šå¾‹è½¬åŒ–ä¸ºç‘åˆ©-é‡‘æ–¯å…¬å¼ å…‰é‡å­å’Œå…‰ç”µæ•ˆåº”ç†è®º å…‰å­æ¦‚å¿µ å…‰ä¸ä»…æ˜¯æ˜¯ç”µç£æ³¢ï¼Œè€Œä¸”è¿˜æ˜¯ç”±ä¸€ä¸ªä¸ªç²’å­ç»„æˆã€‚ ç”±ç›¸å¯¹è®ºå…‰çš„åŠ¨é‡ä¸èƒ½é‡å…³ç³»$ P=E/C=hv/C=h/Î»$æå‡ºäº†å…‰å­åŠ¨é‡Pä¸è¾å°„æ³¢é•¿çš„å…³ç³»ã€‚ å…‰ç”µæ•ˆåº”ç†è®º \\[ \\frac{1}{2}\\mu V^2=hv-A \\] ä¸¤ä¸ªå…¸å‹ç‰¹ç‚¹ ä¸´ç•Œé¢‘ç‡\\(v_0\\) å…‰ç”µå­åŠ¨èƒ½åªå†³å®šäºå…‰å­çš„é¢‘ç‡,å…‰çš„å¼ºåº¦åªå†³å®šå…‰å­çš„æ•°ç›®,ä»è€Œå†³å®šå…‰ç”µå­çš„æ•°ç›® å…‰å­åŠ¨é‡ \\(m_0\\)å’Œ\\(\\mu_0\\)éƒ½æ˜¯ç²’å­è´¨é‡ é€Ÿåº¦ä¸ºVè¿åŠ¨çš„ç²’å­çš„èƒ½é‡: \\[ E=\\frac{\\mu_0C^2}{\\sqrt{1-\\frac{V^2}{C^2}}} (1) \\] \\(\\mu_0\\)æ˜¯ç²’å­çš„é™æ­¢è´¨é‡ \\(m_e=\\frac{m_0}{\\sqrt{1-\\frac{V^2}{C^2}}}\\)ï¼Œé™æ­¢è´¨é‡å’Œè¿åŠ¨æ—¶çš„è´¨é‡çš„å…³ç³» ç›¸å¯¹è®ºä¸­èƒ½é‡åŠ¨é‡å…³ç³»å¼ï¼š \\[ E_e^2=m_0^2C^4+P_e^2C^2(2) \\] å¯¹äºå…‰å­ï¼Œé€Ÿåº¦ä¸ºå…‰é€Ÿï¼Œä¸ºäº†ä½¿ï¼ˆ1ï¼‰å¼æœ‰æ„ä¹‰ï¼Œå…‰å­çš„é™æ­¢è´¨é‡ä¸º0 å› æ­¤å…‰å­çš„èƒ½åŠ¨é‡å…³ç³»ï¼š \\[ E=pC \\] å…‰å­èƒ½é‡ã€åŠ¨é‡å…³ç³»å¼ï¼š \\[ \\left\\{ \\begin{array}{**lr**} E=hv=\\hbar\\omega\\\\ \\vec p=\\frac{E}{c}\\vec n=\\frac{hv}{c}\\vec n=\\frac{h}{\\lambda}\\vec n=\\frac{\\hbar}{\\bar\\lambda}\\vec n=\\hbar\\vec k \\end{array} \\right. \\] \\[ \\hbar=\\frac{h}{2\\pi} \\] \\[ \\bar \\lambda=\\frac{\\lambda}{2\\pi} \\] \\[ æ³¢çŸ¢\\vec k=\\frac{\\vec n}{\\bar \\lambda} \\] ç›¸å¯¹è®ºä¸­çš„åŠ¨èƒ½å…¬å¼å’Œç»å…¸åŠ›å­¦çš„å…¬å¼çš„ç»Ÿä¸€ åº·æ™®é¡¿æ•ˆåº” Xå°„çº¿è¢«è½»å…ƒç´ å¦‚ç™½èœ¡ã€çŸ³å¢¨ä¸­çš„ç”µå­æ•£å°„åå‡ºç°çš„æ•ˆåº”ã€‚è¯¥æ•ˆåº” æœ‰å¦‚ä¸‹ 2 ä¸ªç‰¹ç‚¹ï¼š æ•£å°„å…‰ä¸­ï¼Œé™¤äº†åŸæ¥Xå…‰çš„æ³¢é•¿Î»å¤–ï¼Œå¢åŠ äº†ä¸€ä¸ªæ–°çš„æ³¢é•¿ä¸º\\(Î»&#39;\\)çš„Xå…‰ï¼Œä¸”\\(Î»&#39; &gt;Î»\\)ï¼› æ³¢é•¿å¢é‡ $Î”Î»=Î»â€™ â€“Î» $éšæ•£å°„è§’å¢å¤§è€Œå¢å¤§ã€‚è¿™ä¸€ç°è±¡ç§°ä¸ºåº·æ™®é¡¿æ•ˆåº”ã€‚ æŠŠ Xå°„çº¿è¢«ç”µå­æ•£å°„çš„è¿‡ç¨‹çœ‹æˆæ˜¯å…‰å­ä¸ç”µå­çš„ç¢°æ’è¿‡ç¨‹ åº·æ™®é¡¿æ•ˆåº”è¯æ˜ è¯æ˜: img \\[ \\Delta \\lambda = \\lambda âˆ’ \\lambda_0 = 2\\lambda_ğ’„ \\sin^2 {\\frac{ğ‹}{2} } \\] \\[ \\lambda_0:å…‰å­å…¥å°„æ³¢é•¿ \\] \\[ \\lambda:å…‰å­æ•£å°„æ³¢é•¿ \\] \\[ \\lambda_c:ç”µå­çš„åº·æ™®é¡¿æ³¢é•¿ \\] \\[ Ï†:å…‰å­çš„æ•£å°„è§’ \\] æ ¹æ®èƒ½é‡å®ˆæ’å®šå¾‹: \\[ h(v_0-v)+m_0c^2=m_ec^2\\tag{1} \\] \\(m_0\\) : ç”µå­çš„ç»å¯¹é™æ­¢è´¨é‡ï¼›\\(m_e\\): ç”µå­å’Œå…‰å­ç¢°æ’åçš„ç”µå­è´¨é‡ï¼› \\(v_0\\)æ˜¯å…‰å­å…¥å°„é¢‘ç‡;\\(v\\)æ˜¯å…‰å­æ•£å°„é¢‘ç‡ æ ¹æ®åŠ¨é‡å®ˆæ’å®šå¾‹:(ä½™å¼¦å®šç†) \\[ \\vec P_e=\\vec P_0-\\vec P\\tag{2} \\] ç”µå­çš„èƒ½åŠ¨é‡å…³ç³»(ç”¨åˆ°äº†è´¨èƒ½æ–¹ç¨‹) \\[ (m_ec^2)^2=(m_0c^2)^2+(\\vec P_ec)^2 \\tag{3} \\] ç”±\\((2)\\)å¼å¯ä»¥æ¨å¾—: \\[ P_e^2=P_0^2+P^2-2P_0P\\cos \\varphi\\tag{4} \\] æ ¹æ®å…‰å­çš„èƒ½åŠ¨é‡å…³ç³» \\[ Pc=E=hv\\tag{5} \\] å°†\\((5)\\)å¼ä»£å…¥\\((4)\\)å¼ä¸­å¾—åˆ° \\[ P_e^2=(\\frac{hv_0}{c})^2+(\\frac{hv}{c})^2-2(\\frac{hv_0}{c})(\\frac{hv}{c})\\cos \\varphi\\tag{6} \\] å°†(6)å¼å’Œ(1)å¼ä»£å…¥(3)å¼å¾—åˆ° \\[ (h(v_0-v)+m_0c^2)^2=(m_0c^2)^2+\\\\((\\frac{hv_0}{c})^2+(\\frac{hv}{c})^2-2(\\frac{hv_0}{c})(\\frac{hv}{c})\\cos \\varphi)c^2 \\] å±•å¼€åŒ–ç®€å¯å¾— \\[ (\\frac{1}{v}-\\frac{1}{v_0})=\\frac{h}{m_0c^2}(1-\\cos \\varphi) \\] \\[ \\lambda-\\lambda_0=\\frac{2h}{m_0c}\\sin^2 {\\frac{\\varphi}{2}} \\] è¯æ¯• æ€»ç»“ \\[ \\Delta \\lambda = \\lambda âˆ’ \\lambda_0 = 2\\lambda_ğ’„ \\sin^2 {\\frac{ğ‹}{2} } \\] ç”µå­çš„åº·æ™®é¡¿æ³¢é•¿ \\[ \\lambda_c=\\frac{h}{m_0c}=\\frac{2\\pi\\hbar }{m_0c} \\] å…¶ä¸­ \\[ \\hbar=\\frac{h}{2\\pi} \\] \\[ \\bar \\lambda=\\frac{\\lambda}{2\\pi} \\]","categories":[{"name":"é‡å­åŠ›å­¦","slug":"é‡å­åŠ›å­¦","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"}],"tags":[{"name":"é»‘ä½“è¾å°„\\å…‰ç”µæ•ˆåº”\\åº·æ™®é¡¿æ•£å°„","slug":"é»‘ä½“è¾å°„-å…‰ç”µæ•ˆåº”-åº·æ™®é¡¿æ•£å°„","permalink":"http://example.com/tags/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84-%E5%85%89%E7%94%B5%E6%95%88%E5%BA%94-%E5%BA%B7%E6%99%AE%E9%A1%BF%E6%95%A3%E5%B0%84/"}]},{"title":"å¤å˜å‡½æ•°--è§£æå‡½æ•°","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/è§£æå‡½æ•°","date":"2022-09-07T14:26:45.888Z","updated":"2022-09-08T10:23:52.040Z","comments":true,"path":"2022/09/07/æ•°å­¦ç‰©ç†æ–¹æ³•/è§£æå‡½æ•°/","link":"","permalink":"http://example.com/2022/09/07/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E8%A7%A3%E6%9E%90%E5%87%BD%E6%95%B0/","excerpt":"","text":"è§£æå‡½æ•°çš„æ¦‚å¿µ å®šä¹‰ï¼šè‹¥å‡½æ•°\\(f(z)\\)åœ¨ç‚¹\\(z_0\\)çš„æŸé‚»åŸŸå†…å¤„å¤„å¯å¯¼ï¼Œåˆ™ç§°å‡½æ•°\\(f(z)\\)åœ¨ç‚¹\\(z_0\\)å¤„è§£æ;åˆè‹¥\\(f(z)\\)åœ¨åŒºåŸŸ\\(B\\)å†…çš„æ¯ä¸€ç‚¹è§£æï¼Œåˆ™ç§°\\(f(z)\\)åœ¨åŒºåŸŸ\\(B\\)å†…æ˜¯è§£æå‡½æ•°ã€‚ è§£æä¸å¯å¯¼ä¸ç­‰ä»· è§£æå’Œå¯å¯¼ä¸ç­‰ä»·:å‡½æ•°åœ¨æŸç‚¹è§£æï¼Œåˆ™å¿…åœ¨è¯¥ç‚¹å¯å¯¼ï¼›åä¹‹ä¸ç„¶ åœ¨åŒºåŸŸ\\(B\\)å†…çš„è§£æå‡½æ•°å¿…åœ¨\\(B\\)å†…å¯å¯¼ å‡½æ•°çš„å¥‡ç‚¹ è§£æçš„å……åˆ†å¿…è¦æ¡ä»¶ è®¾å‡½æ•°\\(f(z)=u(x,y)+iv(x,y)\\)åœ¨åŒºåŸŸ\\(B\\)å†…è§£æå½“ä¸”ä»…å½“ï¼š (1)å®éƒ¨å’Œè™šéƒ¨åœ¨\\(B\\)å†…å¯å¯¼ï¼ˆå¯å¾®ï¼‰ï¼› (2)å®éƒ¨å’Œè™šéƒ¨åœ¨\\(B\\)å†…æ¯ä¸€ç‚¹æ»¡è¶³æŸ¯è¥¿â€”é»æ›¼æ¡ä»¶ è§£æå‡½æ•°ä¸è°ƒå’Œå‡½æ•°çš„å…³ç³» æ¦‚å¿µ è°ƒå’Œå‡½æ•°:å¦‚æœäºŒå…ƒå‡½æ•°\\(f(x,y)\\)åœ¨åŒºåŸŸ\\(B\\)å†…æœ‰äºŒé˜¶è¿ç»­çš„åå¯¼æ•°,è€Œä¸”æ»¡è¶³æ‹‰æ™®æ‹‰æ–¯æ–¹ç¨‹: \\[ \\Delta f=\\frac{\\partial^2 f}{\\partial x^2}+\\frac{\\partial^2 f}{\\partial y^2} \\] åˆ™ç§°\\(f(x,y)\\)ä¸ºåŒºåŸŸ\\(B\\)å†…çš„è°ƒå’Œå‡½æ•°,å…¶ä¸­\\(\\Delta=\\frac{\\partial^2 }{\\partial x^2}+\\frac{\\partial^2 }{\\partial y^2}\\)ç§°ä¸ºæ‹‰æ™®æ‹‰æ–¯ç®—ç¬¦ã€‚ å…±è½­è°ƒå’Œå‡½æ•°ï¼šè‹¥ä¸¤å®å‡½æ•°\\(u(x,y)\\)ä»¥åŠ\\(v(x,y)\\)å‡ä¸ºåŒºåŸŸ\\(B\\)å†…çš„è°ƒå’Œå‡½æ•°ï¼Œä¸”æ»¡è¶³C-Ræ¡ä»¶ï¼Œå³ \\[ \\frac {\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y}ï¼Œ\\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x} \\] åˆ™ç§°\\(u(x,y)\\)ä¸º\\(v(x,y)\\)çš„å…±è½­è°ƒå’Œå‡½æ•° æ€§è´¨ä¸€ ä»»ä½•åœ¨åŒºåŸŸ\\(B\\)å†…çš„è§£æçš„å‡½æ•°\\(f(z)=u(x,y)+iv(x,y)\\)å…¶å®éƒ¨å’Œè™šéƒ¨éƒ½æ˜¯\\(B\\)å†…çš„è°ƒå’Œå‡½æ•°,ä¸”è™šéƒ¨æ˜¯å®éƒ¨çš„å…±è½­è°ƒå’Œå‡½æ•°. æ€§è´¨äºŒ è§£æå‡½æ•°çš„æ„é€ æ–¹æ³• ä¾‹é¢˜ è§£æå‡½æ•°çš„æ„é€ æ–¹æ³•(æåæ ‡) ä¾‹é¢˜ å·²çŸ¥è§£æå‡½æ•°\\(f(z)\\)çš„è™šéƒ¨\\(v(x,y)=\\sqrt{-x+\\sqrt{x^2+y^2}}\\)æ±‚å®éƒ¨\\(u(x,y)\\)å’Œè¿™ä¸ªè§£æå‡½æ•°\\(f(z)\\) è§£æå‡½æ•°çš„ä¿è§’æ€§ ä¿è§’æ€§è¯æ˜ è§£æå‡½æ•°çš„æ€§è´¨ å…±è½­æ€§ è°ƒå’Œæ€§ ä¿è§’æ€§","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"å¤å˜å‡½æ•°","slug":"å¤å˜å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"å¤å˜å‡½æ•°--å¯¼æ•°","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/å¤å˜å‡½æ•°çš„å¯¼æ•°","date":"2022-09-03T09:24:06.765Z","updated":"2022-09-03T10:36:25.585Z","comments":true,"path":"2022/09/03/æ•°å­¦ç‰©ç†æ–¹æ³•/å¤å˜å‡½æ•°çš„å¯¼æ•°/","link":"","permalink":"http://example.com/2022/09/03/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/","excerpt":"","text":"å‡½æ•°çš„è¿ç»­æ€§ ä¾‹é¢˜ æ±‚å¯¼å…¬å¼ æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹(å¤å˜å‡½æ•°å¯å¯¼çš„å¿…è¦æ¡ä»¶) å¯å¯¼çš„å……åˆ†å¿…è¦æ¡ä»¶","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"å¤å˜å‡½æ•°","slug":"å¤å˜å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"å¤å˜å‡½æ•°","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/å¤å˜å‡½æ•°","date":"2022-09-03T07:28:49.114Z","updated":"2022-09-07T14:30:19.779Z","comments":true,"path":"2022/09/03/æ•°å­¦ç‰©ç†æ–¹æ³•/å¤å˜å‡½æ•°/","link":"","permalink":"http://example.com/2022/09/03/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/","excerpt":"","text":"åŸºæœ¬æ¦‚å¿µ é‚»åŸŸ å†…ç‚¹å¤–ç‚¹è¾¹ç•Œç‚¹ åŒºåŸŸ åŒºåŸŸè¾¹ç•Œæ–¹å‘ å•è¿é€šåŒºåŸŸå’Œå¤è¿é€šåŒºåŸŸ è”é€šé˜¶æ•° èšç‚¹ å•å€¼å‡½æ•°å’Œå¤šå€¼å‡½æ•° å¸¸è§å¤å˜å‡½æ•° \\(\\sin z\\)å’Œ\\(\\cos z\\) \\[ e^z=e^{x+iy}=e^x(\\cos y+i\\sin y) \\] \\[ \\sin z=\\frac{1}{2i}(e^{iz}-e^{-iz}) \\] \\[ \\cos z=\\frac{1}{2}(e^{iz}+e^{-iz}) \\] sinzå’Œcoszçš„æ¨¡å¯ä»¥å¤§äº1,\\(2\\pi\\)ä¸ºå‘¨æœŸ \\[ \\begin{aligned} &amp;|\\sin z|=\\frac{1}{2} \\sqrt{\\left(e^{2 y}+e^{-2 y}\\right)+2\\left(\\sin ^2 x-\\cos ^2 x\\right)} \\end{aligned} \\] \\[ \\begin{aligned} &amp;|\\cos z|=\\frac{1}{2} \\sqrt{\\left(e^{2 y}+e^{-2 y}\\right)+2\\left(\\cos ^2 x-\\sin ^2 x\\right)} \\end{aligned} \\] \\(\\operatorname{sh}z\\)å’Œ\\(\\operatorname{ch}z\\) \\[ \\operatorname{sh}z=\\frac {1}{2}(e^z-e^{-z}) \\] \\[ \\operatorname{ch}x=\\frac {1}{2}(e^z+e^{-z}) \\] \\(\\operatorname{sh}x\\),\\(\\operatorname{ch}x\\),\\(e^z\\)å…·æœ‰çº¯è™šæ•°å‘¨æœŸ\\(2\\pi i\\) \\(\\ln z\\)å’Œ\\(e^z\\) \\[ \\ln z=\\ln \\left(|z| e^{i A r g z}\\right)=\\ln |z|+i \\operatorname{Arg} z\\\\ \\] \\[ z^s=e^{s \\ln z} ( s ä¸ºå¤æ•° ) \\] ä¾‹é¢˜ å¤å˜å‡½æ•°çš„æé™ ç±»ä¼¼äºŒå…ƒå‡½æ•°çš„æé™ æé™ä¾‹é¢˜","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"å¤å˜å‡½æ•°","slug":"å¤å˜å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"å¤å˜å‡½æ•°--åŸºæœ¬è¿ç®—","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•/å¤æ•°ä¸å¤å˜è¿ç®—","date":"2022-09-02T12:54:05.207Z","updated":"2022-09-03T07:29:24.422Z","comments":true,"path":"2022/09/02/æ•°å­¦ç‰©ç†æ–¹æ³•/å¤æ•°ä¸å¤å˜è¿ç®—/","link":"","permalink":"http://example.com/2022/09/02/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/%E5%A4%8D%E6%95%B0%E4%B8%8E%E5%A4%8D%E5%8F%98%E8%BF%90%E7%AE%97/","excerpt":"","text":"å¤æ•°åŸºæœ¬æ¦‚å¿µ \\[ z=x+iy \\] å®éƒ¨è®°ä½œ\\(Rez=x\\),è™šéƒ¨è®°ä½œ\\(Imz=y\\) å¤æ•°æ— æ³•æ¯”è¾ƒå¤§å°ï¼Œä½†å¤æ•°å¯ä»¥ç›¸ç­‰ å…±è½­å¤æ•°è¡¨ç¤ºä¸º \\[ z^*=x-iy \\] ä¸‰ç§è¡¨ç¤ºæ–¹æ³• ä»£æ•°å¼ \\[ z=x+iy \\] ä¸‰è§’å¼ \\[ z=x+iy=\\rho cos\\varphi+i\\rho sin\\varphi \\] \\[ \\lvert {z}\\rvert=\\rho=\\sqrt{x^2+y^2} \\] å¤æ•°çš„è¾è§’ \\(Argz=\\varphi+2k\\pi\\) z=0æ—¶,è¾è§’ä¸èƒ½ç¡®å®š è¾è§’ä¸»å€¼çš„å®šä¹‰:æŠŠæ»¡è¶³\\(0\\leq \\varphi\\textless 2\\pi\\)çš„\\(\\varphi\\)ç§°ä¸º\\(Arg z\\)çš„ä¸»å€¼ï¼Œ è®°ä½œ\\(\\varphi=argz\\) æŒ‡æ•°å¼ \\[ z=\\rho e^{i\\varphi} \\] å¤æ•°åŸºæœ¬è¿ç®— åŠ å‡æ³• ä¸‰è§’å½¢ä¸¤è¾¹ä¹‹å’Œå¤§äºç¬¬ä¸‰è¾¹ \\[ \\lvert {z_1+z_2}\\rvert \\leq\\lvert {z1}\\rvert+\\lvert {z_2}\\rvert \\] ä¹˜æ³• ä¸¤ä¸ªå¤æ•°ç›¸ä¹˜ç­‰äºå®ƒä»¬ çš„æ¨¡ç›¸ä¹˜ï¼Œå¹…è§’ç›¸åŠ  \\[ z_1z_2=\\rho_1\\rho_2[cos(\\varphi_1+\\varphi_2)+isin(\\varphi_1+\\varphi_2)]\\\\ =\\rho_1\\rho_2e^{[i(\\varphi_1+\\varphi_2)]} \\] ä¹˜æ–¹ å¯ç”±ä¹˜æ³•è§„åˆ™å¾—åˆ°ï¼Œç”¨ ä¸ª ç›¸ä¹˜ \\[ z^n=\\rho^ne^{in\\varphi} \\] æ££è«å¼—(De Moivre)å…¬å¼ \\[ (\\cos \\varphi+i\\sin \\varphi)^n=\\cos n\\varphi+i\\sin n\\varphi \\] é™¤æ³• \\[ \\frac{z_1}{z_2}=\\frac{\\rho_1}{\\rho_2} e^{i(\\varphi_1-\\varphi_2)} \\] næ¬¡æ ¹å¼ \\[ \\sqrt[n]{z}=\\sqrt[n]{\\rho}(\\cos\\frac{\\varphi}{n}+i\\sin\\frac{\\varphi}{n})=\\sqrt[n]{\\rho}e^{i\\frac{\\varphi}{n}} \\] å…±è½­å¤æ•°è®¡ç®— \\[ zz^*=\\lvert {z}\\rvert^2 \\] \\[ z^2=\\lvert {z}\\rvert^2=\\lvert {z^2}\\rvert \\] \\[ \\lvert {e^{ik\\varphi}}\\rvert=1 \\]","categories":[{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"å¤å˜å‡½æ•°","slug":"å¤å˜å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"}]},{"title":"python api -- script learning","slug":"Lumerical/python apiçš„è¯­æ³•","date":"2022-07-15T09:49:03.330Z","updated":"2022-07-21T13:18:02.784Z","comments":true,"path":"2022/07/15/Lumerical/python apiçš„è¯­æ³•/","link":"","permalink":"http://example.com/2022/07/15/Lumerical/python%20api%E7%9A%84%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Session management - Python API â€“ Ansys Optics æœ¬æ–‡å°†æ¼”ç¤ºLumericalå·¥å…·ä¸Pythoné›†æˆå¼€å‘ä»¥å®Œæˆå¤æ‚çš„è‡ªåŠ¨åŒ–å·¥ä½œæµç¨‹ï¼Œå¹¶ä¸”æ‰§è¡Œé«˜çº§æ•°æ®å¤„ç†ä»¥åŠç»˜ç”»ã€‚ ä½¿ç”¨Python APIå¯ä»¥å®ç°äº’è”ï¼ŒPython APIæ˜¯ä¸€ä¸ªç§°ä¸º\\(lumapi\\)çš„Pythonåº“ã€‚ å»ºè®®å°†Lumericalå’ŒPythonçš„æ–‡ä»¶æ”¾åœ¨ç»Ÿä¸€æ–‡ä»¶å¤¹ å¯ç”¨Lumerical-Python APIå…³é”®éœ€è¦è¿æ¥lumapi.pyæ–‡ä»¶çš„è¿æ¥ã€‚ ä½¿ç”¨è„šæœ¬å‘½ä»¤å’Œä¼ é€’æ•°æ®,å¯ä»¥å‚è€ƒScript commands as methods - Python API,å’ŒPassing Data - Python API. import module å¯¼å…¥lumapi lumericalçš„solverå·²ç»é™„å¸¦äº†Python3å‘è¡Œç‰ˆã€‚ 1import lumapi å¯¼å…¥å‰å…ˆå¯¼å…¥python ä½¿ç”¨\\(sys.path.append()\\)æ–¹æ³•å°†\\(lumapi\\)ç›®å½•ä¸´æ—¶æ·»åŠ åˆ°è·¯å¾„ä¸­ã€‚ 1234import sys, ossys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v222\\\\api\\\\python\\\\&quot;) #Default windows lumapi pathsys.path.append(&quot;/opt/lumerical/v222/api/python/lumapi.py&quot;) #Default linux lumapi pathsys.path.append(os.path.dirname(__file__)) #Current directory starting a session è°ƒç”¨æ„é€ å‡½æ•° 1fdtd = lumapi.FDTD() You can create multiple sessions of the same product and different products at once, as long as they all have unique names. 123mode1 = lumapi.MODE()mode2 = lumapi.MODE()device = lumapi.DEVICE() æ„é€ å‡½æ•°æ”¯æŒä»¥ä¸‹å¯é€‰å‚æ•°ï¼š hideï¼ˆé»˜è®¤ä¸ºFalseï¼‰ï¼šåœ¨å¯åŠ¨çš„æ—¶å€™æ˜¾ç¤ºæˆ–è€…éšè—lumeric GUI/CAD ç¯å¢ƒ filename(é»˜è®¤ä¸ºç©º)ï¼šå¦‚æœæ–°çš„åº”ç”¨ç¨‹åºæ—¶ç©ºçš„ï¼Œåˆ™å¯åŠ¨è¿™ä¸ªåº”ç”¨ç¨‹åºï¼Œå¦‚æœæä¾›lsfæ–‡ä»¶ï¼Œåˆ™è¿è¡Œè„šæœ¬ã€‚å¦‚æœæä¾›äº†é¡¹ç›®æ–‡ä»¶åï¼Œå°†å°è¯•åŠ è½½é¡¹ç›® 12# loads and runs script.lsf while hiding the application windowinc = lumapi.INTERCONNECT(filename=&quot;script.lsf&quot;, hide=True) Import Methods é™¤äº†åœ¨Pythonä¸­å®šä¹‰å‡½æ•°ï¼Œç”¨æˆ·è¿˜å¯ä»¥ä½¿ç”¨lumapiçš„è‡ªåŠ¨åŒæ­¥å‡½æ•°åŠŸèƒ½ï¼Œå¹¶ä¸”å¯¼å…¥Lumericalè„šæœ¬æ–‡ä»¶ä¸­é¢„å®šä¹‰çš„å‡½æ•°ã€‚ä½¿ç”¨â€œevalâ€å‘½ä»¤æ‰§è¡Œè„šæœ¬åï¼Œå¯ä»¥åœ¨ lumapi ä¸­å°†è¿™äº›æ–¹æ³•ç§°ä¸ºé¢„å®šä¹‰çš„æ–¹æ³•ã€‚ ä¸‹é¢æ˜¯ä»è„šæœ¬æ–‡ä»¶â€œtestScript.lsfâ€å’Œscript format stringå¯¼å…¥å‡½æ•°çš„ç¤ºä¾‹ã€‚ 123456789fdtd = lumapi.FDTD()# import function defined in script format stringfdtd .eval(&quot;function helloWorld() &#123; return \\&quot;hello world\\&quot;; &#125;\\nfunction returnFloat() &#123; return 1.; &#125;\\nfunction addTest(a, b)&#123; return a*b; &#125;&quot;)print(fdtd .helloWorld())# import function defined in the script file &quot;testScript.lsf&quot;code = open(&#x27;C:/XXX/testScript.lsf&#x27;, &#x27;r&#x27;).read()fdtd .eval(code) è¯¥è„šæœ¬è¿˜å¯ä»¥ä½œä¸ºæ„é€ å‡½æ•°ä¸­çš„å‚æ•°ä¼ é€’ï¼Œä»¥å®šä¹‰æ–¹æ³•ï¼š 12345678def testAddingMethodsFromConstructor(self):app = self.appConstructor(script=&quot;any_product_script_workspace_functions_available_in_python_test.lsf&quot;)expectedMethods = &#123;&#x27;helloWorld&#x27;&#125;expectedResults = [&#x27;hello world from script file&#x27;]results = []results.append(app.helloWorld())self.assertEqual(results, expectedResults)app.close() Advanced session management å½“å˜é‡è¶…è¿‡äº†ä½œç”¨åŸŸä¹‹åï¼Œä»–ä»¬å°†ä¼šè¢«è‡ªåŠ¨åˆ é™¤ï¼Œå½“æ‰€æœ‰æŒ‡å‘å®ƒçš„å˜é‡å¼•ç”¨è¢«åˆ é™¤æ—¶ï¼ŒLumerical ä¼šè¯å°†è‡ªåŠ¨å…³é—­ã€‚ Wrapping the session in a function åœ¨Pythonä¸­ï¼Œå¦‚æœéœ€è¦è¿è¡Œå¤§é‡ç±»ä¼¼çš„å®ä¾‹ï¼Œå¯ä»¥ä½¿ç”¨å‡½æ•°ï¼›æ¯”å¦‚ï¼Œåœ¨æ‰«æä¸€äº›å¯é€‰çš„å‚æ•°çš„æ—¶å€™ï¼Œæœ‰å…³å¦‚ä½•è¿”å›é‡è¦ç»“æœï¼Œè¯·å‚é˜…passing data - Python API 1234def myFunction(someOptionalParameter): fdtd = lumapi.FDTD() ... return importantResult Using the \"with\" context manager æˆ‘ä»¬å¯ä»¥é€šè¿‡Pythonä¸­çš„\"with\"è¯­å¥ï¼Œæ¥ç»™å‡ºä¸€ä¸ªè‰¯å¥½çš„entrance and exit behavior æ¥æ‰“å¼€Lumerical sessionã€‚åœ¨\"with\"è¯­å¥å—ä¸­,æœ‰ä»»ä½•çš„é”™è¯¯ï¼Œè¿™ä¼šè¯ä¾æ—§å¯ä»¥è¢«æˆåŠŸåœ°å…³é—­ã€‚ä»»ä½•å¹³å¸¸åœ¨Lumerical script environmentèƒ½çœ‹åˆ°çš„æŠ¥é”™ï¼Œä¼šå°†åœ¨Pythonçš„ç¯å¢ƒä¸­æ˜¾ç¤ºå‡ºæ¥ã€‚ 123456with lumapi.FDTD(hide=True) as fdtd: fdtd.addfdtd() fdtd.setnamed(&quot;bad name&quot;) ## you will see LumApiError: &quot;in setnamed, no items matching the name &#x27;bad name&#x27; can be found.&quot; ...## fdtd still successfully closes hide (default to False): Shows or hides the lumerical GUI/CAD environment on startup filename (default empty): Launches a new application if it is empty, and will run the script if an lsf file is provided. If a project filename is provided; it will try and load the project if it can be found in the path. See the section setting the python path before importing to add folder or use the full path to load files from other directories. æ­¤ç¤ºä¾‹æ¼”ç¤ºå¦‚ä½•ä»ä¼˜åŒ–ä¸­è®¿é—®æ•°æ®ã€‚ 1234567891011121314151617181920212223242526m=&quot;thickness_optimization&quot;;?getsweepdata(m);genVec = getsweepdata(m,&quot;genVec&quot;); # Generation vector (1D vector, Ng)memberVec = getsweepdata(m,&quot;memberVec&quot;); # Generation member vector (1D vector, Nm)fomTrend = getsweepdata(m,&quot;fomTrend&quot;); # Best of each generation, same as shown in Opt. GUI window (1D vector, Ng)paramsTrend = getsweepdata(m,&quot;paramsTrend&quot;); # Parameters corresponding to FOM trend (3D matrix, 1 x Np x Ng)bestFom = getsweepdata(m,&quot;bestFom&quot;); # Global best FOMbestParams = getsweepdata(m,&quot;bestParams&quot;); # Parameters corresponding to global best FOM (1D vector, Np)fomHistory = getsweepdata(m,&quot;fomHistory&quot;); # Every FOM calculated in optimization (2D maxtrix, Nm x Ng)paramHistory = getsweepdata(m,&quot;paramHistory&quot;); # Every parameter set used in optimization (3D maxtrix, Np x Nm x Ng)plot(genVec,fomTrend,&quot;generation number&quot;,&quot;fom Trend&quot;,&quot;best FOM of each generation&quot;); ?&quot;Best FOM: &quot;+num2str(bestFom);?&quot;Best Params: &quot;+num2str(bestParams);?&quot;Total number of simulations run: &quot;+num2str(length(genVec)*length(memberVec));image(memberVec,genVec,fomHistory,&quot;member&quot;,&quot;generation&quot;,&quot;All FOM&#x27;s obtained&quot;);&gt; genVec&gt; memberVec&gt; paramsTrend&gt; fomTrend&gt; paramHistory&gt; fomHistory&gt; bestParams&gt; bestFom&gt; Best FOM: 0.00187328&gt; Best Params: 5.96041e-008&gt; Total number of simulations run: 50 Simulation Objects æ·»åŠ å¯¹è±¡æ—¶ï¼Œå…¶æ„é€ å‡½æ•°å¯ç”¨äºåœ¨åˆ›å»ºæ—¶è®¾ç½®å±æ€§çš„å€¼ã€‚ 1fdtd.addfdtd(dimension=&quot;2D&quot;, x=0.0e-9, y=0.0e-9, x_span=3.0e-6, y_span=1.0e-6) åœ¨Pythonä¸­ï¼Œå­—å…¸æ’åºä¸èƒ½ä¿è¯ï¼Œå› æ­¤ï¼Œå¦‚æœå­˜åœ¨ä¾èµ–äºå…¶ä»–å±æ€§çš„å±æ€§ï¼Œåˆ™éœ€è¦æœ‰åºå­—å…¸ã€‚ä¾‹å¦‚ï¼Œåœ¨Pythonçš„ä»¥ä¸‹è¡Œä¸­ï¼Œâ€œè¦†ç›–å…¨å±€ç›‘è§†å™¨è®¾ç½®â€å¿…é¡»ä¸ºtrueï¼Œç„¶åæ‰èƒ½è®¾ç½®â€œfrequency pointsâ€ã€‚ 123props = OrderedDict([(&quot;name&quot;, &quot;power&quot;),(&quot;override global monitor settings&quot;, True),(&quot;x&quot;, 0.),(&quot;y&quot;, 0.4e-6), (&quot;monitor type&quot;, &quot;linear x&quot;),(&quot;frequency points&quot;, 10.0)])fdtd.addpower(properties=props) å¦‚æœæ‚¨æ²¡æœ‰å…·æœ‰ä¾èµ–é¡¹çš„å±æ€§ï¼Œåˆ™å¯ä»¥ä½¿ç”¨å¸¸è§„çš„Pythonå­—å…¸ã€‚ 12345props = &#123;&quot;name&quot;: &quot;power&quot;, &quot;x&quot; : &quot;0.0&quot;, &quot;y&quot; : 0.4e-6&quot;, &quot;monitor type&quot; : &quot;linear x&quot;&#125;fdtd.addpower(properties=props) simulation objection å°†æ–°å¯¹è±¡æ·»åŠ åˆ° Lumerical æ–‡ä»¶æ—¶ï¼Œå°†è¿”å›ä¸€ä¸ªrepresentative Python å¯¹è±¡ã€‚æ­¤å¯¹è±¡å¯ç”¨äºå¯¹ Lumerical äº§å“ä¸­çš„ç›¸åº”å¯¹è±¡è¿›è¡Œæ›´æ”¹ã€‚ 123rectangle = fdtd.addrect(x = 2e-6, y = 0.0, z = 0.0)rectangle.x = -1e-6rectangle.x_span = 10e-6 Parent and children access The tree of objectså¯ä»¥ä½¿ç”¨å¯¹è±¡çš„çˆ¶ç±»æˆ–å­é¡¹è¿›è¡Œéå† 1234567891011121314device.addstructuregroup(name=&quot;A&quot;)device.addrect(name=&quot;in A&quot;)device.addtogroup(&quot;A&quot;)device.addstructuregroup(name=&quot;B&quot;)device.addtogroup(&quot;A&quot;)bRect = device.addrect(name=&quot;in B&quot;)device.addtogroup(&quot;A::B&quot;)# Go up two parents from the rectangle in &quot;B&quot; groupaGroup = bRect.getParent().getParent()# Print the names of all members of &quot;A&quot; groupfor child in aGroup.getChildren(): print child[&quot;name&quot;]","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"script","slug":"script","permalink":"http://example.com/tags/script/"}]},{"title":"High-effciency grating-couplers:demonstration of a new design  strategy","slug":"æ–‡çŒ®é˜…è¯»è®°å½•/æ–‡çŒ®é˜…è¯»-ä¸‰-åå‘è®¾è®¡","date":"2022-07-14T12:38:42.038Z","updated":"2022-07-21T13:48:33.105Z","comments":true,"path":"2022/07/14/æ–‡çŒ®é˜…è¯»è®°å½•/æ–‡çŒ®é˜…è¯»-ä¸‰-åå‘è®¾è®¡/","link":"","permalink":"http://example.com/2022/07/14/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB-%E4%B8%89-%E5%8F%8D%E5%90%91%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"Abstract ä¸€ç§ç®€å•ä¸”å®ç”¨çš„è®¾è®¡å…‰æ …è€¦åˆå™¨çš„æ–¹æ³• åŸºäºä¸¤ä¸ªæ–¹é¢ä¼˜åŒ–ï¼Œå˜è¿¹å…‰æ …çš„å‚æ•°å’Œåˆ»èš€æ·±åº¦ å˜è¿¹å…‰æ …çš„å‚æ•°æœ‰ä¸¤ä¸ªï¼Œå…‰æ …å‘¨æœŸä¸å ç©ºæ¯” åœ¨260nmçš„SOIç¡…å¹³å°ä¸Šè¿›è¡Œä¼˜åŒ– ä»¿çœŸè€¦åˆæ•ˆç‡è¾¾åˆ°äº†0.8dbï¼ˆ83%ï¼‰ï¼Œå®é™…åˆ¶é€ åçš„ç»“æœä¸º0.9dbï¼ˆ81%ï¼‰ ä¸ä½¿ç”¨åå°„ç»“æ„ Body èƒŒæ™¯ å¦‚ä½•å°†å…‰çº¤ä¸­çš„å…‰è€¦åˆè¿›æ³¢å¯¼ä¸­â€”â€”è¾¹ç¼˜è€¦åˆï¼Œå…‰æ …è€¦åˆ è¾¹ç¼˜è€¦åˆçš„ä¼˜ç¼ºç‚¹ï¼š è€¦åˆæ•ˆç‡é«˜ï¼Œèƒ½å¤Ÿè¾¾åˆ°0.5dB å¯¹å·¥è‰ºè¦æ±‚é«˜ å…‰æ …è€¦åˆçš„ä¼˜ç¼ºç‚¹ï¼š å¯æ”¾ç½®äºèŠ¯ç‰‡çš„ä»»æ„ä½ç½®ï¼›å¯¹å‡†å®¹å·®è¾ƒé«˜ï¼›å¯é‡äº§ è€¦åˆæ•ˆç‡ä½ï¼ˆé€šå¸¸ä½äº61%ï¼›å…‰æ …æ–¹å‘æ€§ä½ï¼Œæ¨¡åœºå¤±é…ï¼‰ï¼Œå¸¦å®½çª„ï¼ˆä¸€èˆ¬ä¸º30-40nmï¼‰ å‡åŒ€å…‰æ …çš„å…‰å¼ºåˆ†å¸ƒä¸»è¦ä»¥æŒ‡æ•°è¡°å‡ï¼Œä¸èƒ½å¾ˆå¥½åœ°åŒ¹é…é«˜æ–¯åˆ†å¸ƒçš„å…¥å°„å…‰ å…‰æ …æ–¹å‘æ€§ä½ï¼š å¢åŠ DBRåå°„é•œæˆ–è€…é‡‘å±åå°„é•œï¼ˆå·¥è‰ºå›°éš¾ï¼‰ æ¨¡åœºå¤±é…ï¼š é‡‡ç”¨å˜è¿¹å…‰æ … å˜è¿¹å…‰æ …çš„è®¾è®¡ åœ¨æ ‡å‡†SOIä¸Šçš„GCï¼Œåˆ»èš€åŒºåŸŸçš„é•¿åº¦ä¸º\\(L_E\\)ï¼Œåˆ»èš€æ·±åº¦ä¸º\\(e\\)ï¼Œå‘¨æœŸä¸º\\(Î›\\)ï¼Œå ç©ºæ¯”ä¸º\\(F\\)ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°æœ‰æ•ˆæŠ˜å°„ç‡\\(n_{eff}\\)çš„å…¬å¼: \\[ n_{eff}=F\\cdot n_O+(1-F)\\cdot n_E \\] \\(n_O\\)å’Œ\\(n_E\\)åˆ†åˆ«æ˜¯åˆå§‹ç¡…è–„ç‰‡ä»¥åŠåˆ»èš€è¿‡çš„ç¡…è–„ç‰‡çš„æœ‰æ•ˆæŠ˜å°„ç‡ã€‚åˆ»èš€åŒºåŸŸå’Œæœªåˆ»èš€åŒºåŸŸçš„æœ‰æ•ˆæŠ˜å°„ç‡çš„å‘¨æœŸæ€§å˜åŒ–ï¼Œè¿™ä½¿å¾—å…‰å­¦modeåœ¨ç¡…æ³¢å¯¼è¢«è¡å°„åˆ°free spaceã€‚æ ¹æ®å¸ƒæ‹‰æ ¼æ¡ä»¶ï¼Œå…‰æ …å‘¨æœŸå¯ä»¥è¿™æ ·å­è®¡ç®—ï¼š \\[ Î›=\\frac{Î»_c}{n_{eff}-n_{bg}sin\\theta} \\] å…¶ä¸­ï¼Œ\\(\\lambda_c\\)æ˜¯ä¸­å¿ƒè€¦åˆæ³¢é•¿ï¼Œ\\(\\theta\\)æ˜¯å…¥å°„è§’åº¦ï¼Œ\\(n_{eff}\\) æ˜¯å…‰æ …å•å…ƒçš„æœ‰æ•ˆæŠ˜å°„ç‡ã€‚ä»ä¸€ä¸ªæ ‡å‡†çš„å…‰æ …è€¦åˆå™¨çš„åŸºæœ¬ç»“æ„ï¼Œæˆ‘ä»¬å†³å®šå¼•å…¥çº¿æ€§å˜è¿¹çš„ç»“æ„ã€‚é€šè¿‡çº¿æ€§åœ°æ”¹å˜å ç©ºæ¯”ï¼Œå¯ä»¥å®ç°ä¸¤ä¸ªç§¯æçš„æ•ˆæœï¼Œæé«˜æ³¢å¯¼ä¸å…‰æ …éƒ¨åˆ†çš„å…‰é˜»æŠ—åŒ¹é…ï¼ˆæœ‰ç‚¹ä¸å¤ªæ¸…æ¥šï¼‰ï¼Œé™ä½å…‰æ …ç¬¬ä¸€å…ƒä»¶çš„è¾å°„çš„å…‰åŠŸç‡é‡ã€‚ \\[ F(x)=F_0-R \\cdot x \\] Ræ˜¯åˆ‡è¶¾ç³»æ•°ï¼Œxæ˜¯æ¯ä¸ªå…‰æ …å•å…ƒåˆ°å…‰æ …èµ·å§‹ç‚¹çš„è·ç¦» å˜è¿¹å…‰æ …ä»¥å‰å¸¸å¸¸æ˜¯ä½¿ç”¨numerical techniques,æ¯”å¦‚é—ä¼ ç®—æ³• ç¬¬ä¸€ç®—åŠ›è¦æ±‚å¤§,è€—æ—¶é•¿ ç¬¬äºŒè¿™ç§æ–¹æ³•ä¸èƒ½ç»™å‡ºç‰©ç†å«ä¹‰ä¸Šçš„é‚£ç§æœ€é«˜è€¦åˆæ•ˆç‡(åªæ˜¯å•çº¯è®¡ç®—,å¹¶æ²¡æœ‰ä»åŸç†å»åˆ†æ) $$ $$ ä»¥å‰ä¼˜åŒ–æ–¹æ¡ˆæ˜¯å°†å‘¨æœŸå›ºå®šï¼Œå ç©ºæ¯”è°ƒæ•´ï¼Œç°åœ¨çš„ä¼˜åŒ–æ–¹æ¡ˆæ˜¯å‘¨æœŸå’Œå ç©ºæ¯”éƒ½ä¸å›ºå®šã€‚ å›ºå®šå‘¨æœŸä¼šé˜»æ­¢äº†æ‰€æœ‰çš„å…‰æ …å…ƒä»¶åŒæ—¶æ»¡è¶³å¸ƒæ‹‰æ ¼æ¡ä»¶","categories":[{"name":"å¤§åˆ›æ–‡çŒ®","slug":"å¤§åˆ›æ–‡çŒ®","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"}],"tags":[{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"}]},{"title":"inverse design of grating coupler -- process presentation","slug":"Lumerical/inverse design è¿‡ç¨‹å±•ç¤º","date":"2022-07-13T10:46:09.671Z","updated":"2022-10-02T16:39:42.871Z","comments":true,"path":"2022/07/13/Lumerical/inverse design è¿‡ç¨‹å±•ç¤º/","link":"","permalink":"http://example.com/2022/07/13/Lumerical/inverse%20design%20%E8%BF%87%E7%A8%8B%E5%B1%95%E7%A4%BA/","excerpt":"","text":"æ­¥éª¤1ï¼šå®šä¹‰åŸºæœ¬ä»¿çœŸå‚æ•° åœ¨modeä¸‹æ‰“å¼€æ¨¡æ‹Ÿæ–‡ä»¶ pid_grating_coupler_preliminary_design.lms ä¿®æ”¹æ‰€éœ€çš„åŸºæœ¬ä»¿çœŸå‚æ•°ï¼Œä¿å­˜æ–‡ä»¶ã€‚ æ‰“å¼€è„šæœ¬æ–‡ä»¶ pid_grating_coupler_preliminary_design.lsf ä¿®æ”¹å‚æ•°å¹¶è¿è¡Œè„šæœ¬ ç»“æœå±•ç¤º ç¬¬ä¸€ä¸ªæ˜¯æ‰€éœ€çš„ä¸­å¿ƒæ³¢é•¿ ç¬¬äºŒä¸ªæ˜¯\\(X_0\\)ï¼Œå…‰æ …çš„èµ·å§‹ç‚¹ ç¬¬ä¸‰ä¸ªæ˜¯åˆ‡è¶¾ç³»æ•°R ç¬¬å››ä¸ªæ˜¯ neff_thin - index_SiO2*sin(theta)(å…·ä½“å«ä»€ä¹ˆæˆ‘ä¹Ÿä¸å¤ªæ¸…æ¥š) ç¬¬äº”ä¸ªæ˜¯æœ‰æ•ˆæŠ˜å°„ç‡çš„å·®å€¼(neff_thick - neff_thin) è„šæœ¬pid_grating_coupler_preliminary_grating_design.lsf å°†ä¼šè®¡ç®—è¿™äº›åˆå§‹å‚æ•°ï¼Œå¹¶å°†ç»“æœä¿å­˜åœ¨pid_grating_coupler_initial_params.jsonæ–‡ä»¶ä¸­ï¼Œä»¥ä¾¿ä¸‹ä¸€æ­¥ä½¿ç”¨ã€‚ æ­¥éª¤äºŒï¼šä½¿ç”¨2D FDYDä¼˜åŒ–åˆ‡è¶¾å…‰æ … æˆ‘ä»¬é¦–å…ˆéœ€è¦æ‰¾åˆ°å…‰çº¤çš„æœ€ä½³ä½ç½®ã€‚ ç”¨FDTDçš„ç¼–è¯‘å™¨æ‰“å¼€pythonè„šæœ¬pid_grating_coupler_sweep_2D.py å¦‚æœéœ€è¦çš„è¯ï¼Œå¯ä»¥ä¿®æ”¹å‚æ•°ã€‚ è¿è¡Œè„šæœ¬ è¿™ä¸ªè„šæœ¬ä¼šè¿›è¡Œä¸€ä¸ªå…‰æºä½ç½®çš„æ‰«æ pid_grating_coupler_sweep_2D.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&quot;&quot;&quot; Copyright (c) 2020 Ansys Inc. &quot;&quot;&quot; ######## IMPORTS ######### General purpose importsimport os,syssys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v211\\\\api\\\\python\\\\&quot;)import scipy as spimport numpy as npimport jsonfrom lumjson import LumEncoder, LumDecoderimport lumapi######## OPTIMIZABLE GEOMETRY ########lambda_c = 1.55e-6 bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401data_file = &quot;pid_grating_coupler_initial_params.json&quot;base_file = &quot;pid_grating_coupler_2D_TE_base.fsp&quot;def grating_params_pos(params, n_grates): y0 = 0 y3 = y0+height y1 = y3-etch_depth x_start = params[0]*1e-6 #&lt; First parameter is the starting position R = params[1]*1e6 #&lt; second parameter (unit is 1/um) a = params[2] #&lt; Third parameter (dim-less) b = params[3] #&lt; Fourth parameter (dim-less) x0 = x_start verts = np.array( [[x_begin,y0],[x_begin,y3],[x0,y3],[x0,y1]] ) ## Iterate over all but the last tooth for i in range(n_grates-1): F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region x2 = x0 + Lambda #&lt; Rest of cell verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x2,y3],[x2,y1]])),axis=0) x0 = x2 ## Last tooth is special F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x_end,y3],[x_end,y0]])),axis=0) return vertsif __name__ == &quot;__main__&quot;: with open(data_file) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;][0] # Alternate starting point # initial_params = [ -2.5, 0.03, 2.4, 0.5369] vtx = grating_params_pos(initial_params, 25) if os.path.exists(base_file): with lumapi.FDTD(filename=base_file) as fdtd: fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.setglobalsource(&quot;center wavelength&quot;, lambda_c) fdtd.setglobalsource(&quot;wavelength span&quot;, 0) fdtd.save() fdtd.runsweep(&quot;sweep source position&quot;) sweep_pos = fdtd.getsweepdata(&quot;sweep source position&quot;, &quot;x&quot;) sweep_T = fdtd.getsweepdata(&quot;sweep source position&quot;, &quot;T&quot;) Tmax = np.amax(sweep_T) Tpos = sweep_pos[np.where(sweep_T == np.amax(sweep_T))[0][0]][0] print(&quot;Max transmission:&quot;, Tmax*100, &quot;%&quot;) print(&quot;Position&quot;, Tpos*1e6, &quot;um&quot;) fdtd.setnamed(&quot;source&quot;, &quot;x&quot;, Tpos) fdtd.select(&quot;polygon&quot;) fdtd.delete() fdtd.save() else: print(&quot;base file doesn&#x27;t exist...&quot;) è¿è¡Œæ‰«æ å¯¼å…¥çš„æ ‡å‡†åº“ import os,sys æ˜¯å¯¼å…¥æ ‡å‡†åº“oså’Œsys os --- æ“ä½œç³»ç»Ÿæ¥å£æ¨¡å— â€” Python 3.7.13 æ–‡æ¡£ 5. import sys â€” Python 3.10.5 æ–‡æ¡£ Pythonã€Numpy æ•™ç¨‹ | NumPy ä¸­æ–‡ sys.path.append Adding the Python Before Importing To temporarily add the lumapi directory to your path, you can use the sys.path.append() method. This is the case if you have not yet added lumapi to your search path, and it is also useful when adding directories of other helpful lsf, fsp, py files. The following code adds the lumapi folder and current file directory. 123456import sys, ossys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v222\\\\api\\\\python\\\\&quot;) #Default windows lumapi pathsys.path.append(&quot;/opt/lumerical/v222/api/python/lumapi.py&quot;) #Default linux lumapi pathsys.path.append(os.path.dirname(__file__)) #Current directoryimport sys sys.path.append(â€™éœ€è¦å¼•ç”¨æ¨¡å—çš„åœ°å€&#x27;)# sys.path.append(&quot;..&quot;) # è¿™ä»£è¡¨æ·»åŠ å½“å‰è·¯å¾„çš„ä¸Šä¸€çº§ç›®å½• np.concentrate æ‹¼æ¥åŠŸèƒ½ pythonä¸­numpy.concatenate()å‡½æ•°çš„ä½¿ç”¨ - shufeixue - åšå®¢å›­ (cnblogs.com) open with as è¿›è¡Œæ–‡ä»¶æ“ä½œ Python with asç”¨æ³•è¯¦è§£ (biancheng.net) __name__ å†…ç½®å˜é‡ ã€Pythonã€‘name æ˜¯ä»€ä¹ˆï¼Ÿ - çŸ¥ä¹ (zhihu.com) json.load json â€” JSON ç¼–ç å™¨å’Œè§£ç å™¨ â€” Python 3.10.5 æ–‡æ¡£ json.``load(fpï¼Œ ï¼Œ cls=Noneï¼Œ object_hook=Noneï¼Œ parse_float=Noneï¼Œ parse_int=Noneï¼Œ parse_constant=Noneï¼Œ object_pairs_hook=Noneï¼Œ kw*)Â¶ addpoly å°†å¤šè¾¹å½¢æ·»åŠ åˆ°æ¨¡æ‹Ÿæ–‡ä»¶ä¸­ã€‚å¤šè¾¹å½¢å¯¹è±¡ä½¿ç”¨ä¸€ç»„xï¼Œyåæ ‡ï¼ˆé¡¶ç‚¹ï¼‰åœ¨xyå¹³é¢ä¸­å®šä¹‰ä¸€ä¸ªå¤šè¾¹å½¢ï¼Œç„¶ååœ¨zæ–¹å‘ä¸Šæ‹‰ä¼¸è¯¥å¤šè¾¹å½¢ä»¥åˆ›å»º3Då‡ ä½•å›¾å½¢ã€‚ Syntax Description addpoly; Adds a polygon primitive to the simulation environment.This function does not return any data. æ ·ä¾‹ ä»¥ä¸‹çš„è„šæœ¬åˆ›å»ºä¸€ä¸ª2DçŸ©é˜µæ¥å­˜å‚¨å¤šè¾¹å½¢çš„é¡¶ç‚¹ï¼Œå¹¶ä¸”ä½¿ç”¨å®ƒæ¥åˆ›å»ºå¤šè¾¹å½¢åŸºå…ƒ 12345vtx = [1,0;2,2;4,2;4,1;3,1]*1e-6; # micronsaddpoly;set(&quot;name&quot;,&quot;random_polygon&quot;);set(&quot;vertices&quot;,vtx);set(&quot;z span&quot;,2e-6); setglobalsource è®¾ç½®å…¨å±€å…‰æºçš„å±æ€§ã€‚è¿™ä¸ªå‘½ä»¤å°†è¿”å›analysis modeçš„error Syntax Description ?setglobalsource; Returns a list of the global source properties setglobalsource(\"property\",value); Set the global source property named \"property\" to a value.This function does not return any data. æ ·ä¾‹ å°†å…¨å±€çš„èµ·å§‹æ³¢é•¿è®¾ç½®400nmï¼Œç„¶åç¡®å®šå€¼æ˜¯å¦æ­£ç¡® 1234setglobalsource(&quot;wavelength start&quot;,400e-9);?getglobalsource(&quot;wavelength start&quot;);result: 4e-007 save ä¿å­˜é¡¹ç›®æ–‡ä»¶ã€‚å¦‚æœæ¨¡æ‹Ÿå·²ç»è¿è¡Œï¼Œåˆ™è¯¥æ–‡ä»¶è¿˜å°†åŒ…å«æ¨¡æ‹Ÿç»“æœï¼Œä¾‹å¦‚æ‰«æå’Œä¼˜åŒ–æ•°æ®ã€‚ Syntax Description save; Open a file browser to save the file.This function does not return any data. save(filename); Save with the specified name to the current working directory. A path can be specified. ä¾‹å­ ä¿å­˜å½“å‰çš„æ–‡ä»¶ 12save(&quot;project_name&quot;); # saves the file in the current working directorysave(&quot;C:\\Downloads\\project_name.fsp&quot;) # saves the file in a path specified getsweepdata Gets raw data from a parameter sweep/optimization/Monte Carlo analysis. åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œä½¿ç”¨getsweeoresultè·å–å®Œæ•´çš„æ•°æ®é›†æ¯”getsweeodataè·å–å•ä¸ªæ•°æ®å…ƒç´ æ›´æ–¹ä¾¿ã€‚ Syntax Description ?getsweepdata; Returns names of all sweep, optimization, and Monte Carlo analysis objects. ?getsweepdata(\"sweep_name\"); Returns all the names of the available data which is stored in the sweep, optimization, or Monte Carlo analysis object. out = getsweepdata(\"sweep_name\", \"data\"); Returns parameter sweep, optimization, or Monte Carlo analysis data.The following data can be obtained from an optimization:fomTrend - Figure of merit as a function of generationfomHistory - Figure of merit history (for each generation there will be generation size number)bestFom - Best figure of merit obtained during sweepbestParameter - Parameter which corresponds to bestFomparamHistory - Parameter historyFor a parameter sweep and Monte Carlo analysis, this command returns both parameters and results. ä¾‹å­ 12345678m=&quot;thickness_sweep&quot;;?getsweepdata(m);th = getsweepdata(m,&quot;thickness&quot;); # get parameter from sweepR = getsweepdata(m,&quot;R&quot;);# get result from sweepplot(th*1e6,R,&quot;thickness (microns)&quot;,&quot;Reflection&quot;);&gt; R&gt; T&gt; thickness setnamed Syntax Description ?setnamed(\"name\"); Returns a list of the properties of the objects called name. setnamed(\"name\", \"property\", value); The same as set, but acts on objects with a specific name, instead of selected objects. setnamed(\"name\", struct); A struct can be accepted in place of \"property\"-value pair of arguments. setnamed(\"name\", \"property\", value,i); This form can be used to set the property of the ith named object when multiple objects have the same name.The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. setnamed(\"groupname::name\", \"property\", value); The same as set, but acts on objects within the group named \"groupname\" that are named \"name\", instead of selected objects. setnamed(\"groupname::name\", \"property\", value,i); This form can be used to set the property of the ith object with the name \"name\" in the group \"groupname\" when multiple objects have the same name.The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. Examples Set the radius of the object called \"circle\" to 10nm: 1setnamed(&quot;circle&quot;,&quot;radius&quot;,10e-9); ç”¨FDTDè„šæœ¬ç¼–è¾‘å™¨,æ‰“å¼€python è„šæœ¬ pid_grating_coupler_2D_apodized.py å¦‚æœéœ€è¦çš„è¯,æ›´æ–°å‚æ•°,å¹¶ä¸”è¿è¡Œè„šæœ¬ æ‰“å¼€è„šæœ¬pid_grating_coupler_2D_1etch.py è¿è¡Œè„šæœ¬ pid_grating_coupler_2D_apodized.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125##&quot;&quot;&quot; ## Copyright (c) 2020 Ansys Inc. &quot;&quot;&quot;######## IMPORTS ######### General purpose importsimport os,sysimport numpy as npimport scipy as spimport jsonsys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v211\\\\api\\\\python\\\\&quot;)from lumjson import LumEncoder, LumDecoder# Optimization specific importsfrom lumopt.utilities.load_lumerical_scripts import load_from_lsffrom lumopt.utilities.wavelengths import Wavelengthsfrom lumopt.geometries.parameterized_geometry import ParameterizedGeometryfrom lumopt.geometries.polygon import FunctionDefinedPolygonfrom lumopt.figures_of_merit.modematch import ModeMatchfrom lumopt.optimizers.generic_optimizers import ScipyOptimizersfrom lumopt.optimization import Optimizationfrom lumopt.utilities.materials import Materialimport lumapicur_path = os.path.dirname(os.path.realpath(__file__))# Optimization global parameterslambda_c = 1.55e-6 bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401params_file = &quot;pid_grating_coupler_initial_params.json&quot;base_sim_2d = &quot;pid_grating_coupler_2D_TE_base.fsp&quot;base_sim_apodized_2d = &quot;pid_grating_coupler_2D_TE_base_apodized.fsp&quot;base_script_2d = &#x27;pid_grating_coupler_2D_TE_base.lsf&#x27;params_file_apod = &quot;pid_optim_1.json&quot;def grating_params_pos(params): y3 = y0+height y1 = y3-etch_depth x_start = params[0]*1e-6 #&lt; First parameter is the starting position R = params[1]*1e6 #&lt; second parameter (unit is 1/um) a = params[2] #&lt; Third parameter (dim-less) b = params[3] #&lt; Fourth parameter (dim-less) x0 = x_start verts = np.array( [[x_begin,y0],[x_begin,y3],[x0,y3],[x0,y1]] ) ## Iterate over all but the last tooth for i in range(n_grates-1): F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region x2 = x0 + Lambda #&lt; Rest of cell verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x2,y3],[x2,y1]])),axis=0) x0 = x2 ## Last tooth is special F = F0-R*(x0-x_start) Lambda = lambda_c / (a+F*b) x1 = x0 + (1-F)*Lambda #&lt; Width of the etched region verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x_end,y3],[x_end,y0]])),axis=0) return verts def get_vertices_from_distances(self, x_start, distances): #x_start = params[0]*1e-6 #&lt; First parameter is the starting position #R = params[1]*1e6 #&lt; second parameter (unit is 1/um) #a = params[2] #&lt; Third parameter (dim-less) #b = params[3] #&lt; Fourth parameter (dim-less) x_begin = self.x_min-2e-6 x = np.cumsum(np.concatenate(([x_start],distances))) y0 = 0 y3 = y0+self.wg_height y1 = y3-self.etch_depth verts = np.array( [[x_begin,y0],[x_begin,y3],[x[0],y3]] ) ## Iterate over all but the last tooth for i in range(1,len(x),2): verts = np.concatenate((verts,np.array([[x[i-1],y1],[x[i],y1],[x[i],y3],[x[i+1],y3]])),axis=0) ## Close off the polygon verts = np.concatenate((verts,np.array([[x[-1],y0]])),axis=0) return vertsif __name__ == &quot;__main__&quot;: with open(os.path.join(cur_path, params_file)) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;][0] with lumapi.FDTD(filename = os.path.join(cur_path, base_sim_2d), hide = True) as fdtd: vtx = grating_params_pos(initial_params) fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.save(os.path.join(cur_path, base_sim_apodized_2d)) # extracting the distsnces from vertices vx=np.array(vtx) vertsx=vx[2:(len(vx)-2):2,0] vert_x = np.concatenate(([np.array(vx[2,0])],(vertsx[1:]-vertsx[0:len(vertsx)-1]))) vert_x = vert_x *1e6 with open(os.path.join(cur_path, params_file_apod), &quot;w&quot;) as fh: json.dump(&#123; &quot;initial_params&quot;: vert_x &#125;, fh, cls=LumEncoder, indent = 4) os.path.dirname è¯­æ³•ï¼šos.path.dirname(path) åŠŸèƒ½ï¼šå»æ‰æ–‡ä»¶åï¼Œè¿”å›ç›®å½• 123print(os.path.dirname(&quot;E:/Read_File/read_yaml.py&quot;))#ç»“æœï¼šE:/Read_File os.path.dirname(__file__) 123print(__file__)#ç»“æœE:/Read_File/read_yaml.py å¯ä»¥çœ‹å‡º__file__è¡¨ç¤ºäº†å½“å‰æ–‡ä»¶çš„path é‚£ä¹ˆå°±å¯ä»¥äº†è§£åˆ°os.path.dirname((__file__)å’Œos.path.dirname(â€œE:/Read_File/read_yaml.pyâ€)æ˜¯ä¸€ä¸ªæ„æ€ å†æ ¹æ®os.path.dirname(path)çš„ç”¨æ³•ï¼Œå¾—å‡ºos.path.dirname((__file__)å°±æ˜¯å¾—åˆ°å½“å‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ 123print(os.path.dirname(__file__))#ç»“æœï¼šE:/Read_File set è®¾ç½®å½“å‰é€‰ä¸­å¯¹è±¡çš„å±æ€§ å½“æ±‚è§£å™¨å¤„äºåˆ†ææ¨¡å¼æ—¶,æ— æ³•ä¿®æ”¹ Syntax Description ?set; Returns a list of the properties of the selected object(s). set(\"property\",value); This will set the properties of a currently selected object, including pull-downs and check boxes. It cannot be used to set the value of a selected object in a group.Value can be a number or string. This function does not return any data. set(struct); A struct can be accepted in place of \"property\"-value pair of arguments. set(\"property\",value,i); This form can be used to set the property of the ith selected object when multiple objects are selected. It cannot be used to set the value of a selected object in a group.The objects are ordered by their location in the object tree. The uppermost selected object is given the index 1, and the index numbers increase as you go down the tree. å¤šè¾¹å½¢çš„æ­å»º ä¸€ä¸ªå…¸å‹çš„å¤šè¾¹å½¢ç»“æ„å¯ä»¥ç”±å¦‚ä¸‹ä»£ç ç”Ÿæˆï¼š 123456789101112um=1e-6;nm=1e-9;vtx=[2,0;1,1;-1,1; -2,0;-1,-1;1,-1]*um; #å‘é‡ç»„addpoly;set(&quot;name&quot;,&quot;poly&quot;);#åç§°set(&quot;index&quot;,1.5);#æŠ˜å°„ç‡set(&quot;vertices&quot;,vtx);#æ§åˆ¶å‘é‡ç»„set(&quot;x&quot;,0.5*um);#ä¸­å¿ƒåæ ‡set(&quot;y&quot;,1*um);set(&quot;z&quot;,-0.5*um);set(&quot;z span&quot;,0.4*um);#zæ–¹å‘å®½åº¦ addpolyï¼šæ·»åŠ ä¸€ä¸ªå‚æ•°éšæœºçš„å¤šè¾¹å½¢ç»“æ„ã€‚ set(â€œindexâ€,1.5)ï¼šæŠ˜å°„ç‡ã€‚å¤šè¾¹å½¢ææ–™ä¸ºä»‹ç”µææ–™ï¼ŒæŠ˜å°„ç‡ä¸º1.5 set(â€œverticesâ€,vtx)ï¼šå‘é‡ç»„ã€‚è®¾ç½®å¤šè¾¹å½¢çš„xyé¢äºŒç»´å½¢çŠ¶ï¼Œç”±ä¼ å…¥çš„å‘é‡ç»„vtxä¸­çš„å‚æ•°æ§åˆ¶ å…³äºvtxä¸­çš„å‚æ•°è§£é‡Šï¼š vtxæ˜¯ä¸€ä¸ªn*2çš„çŸ©é˜µï¼Œæ¯ä¸€è¡Œéƒ½æ˜¯å¤šè¾¹å½¢ä¸Šä¸€ä¸ªé¡¶ç‚¹çš„ç›¸å¯¹åæ ‡ï¼Œä»¥è®¾ç½®çš„\"x\",â€œyâ€,\"z\"å‚æ•°ä½œä¸ºç›¸å¯¹åæ ‡åŸç‚¹ï¼ŒæŒ‰åœ¨çŸ©é˜µä¸­çš„é¡ºåºé¡ºæ¬¡è¿æ¥æˆå¤šè¾¹å½¢ã€‚ os.path.join os.path.join()å‡½æ•°ç”¨äºè·¯å¾„æ‹¼æ¥æ–‡ä»¶è·¯å¾„ï¼Œå¯ä»¥ä¼ å…¥å¤šä¸ªè·¯å¾„ å¦‚æœä¸å­˜åœ¨ä»¥â€˜â€™/â€™å¼€å§‹çš„å‚æ•°ï¼Œåˆ™å‡½æ•°ä¼šè‡ªåŠ¨åŠ ä¸Š 123&gt;&gt;&gt; import os&gt;&gt;&gt; print(os.path.join(&#x27;path&#x27;,&#x27;abc&#x27;,&#x27;yyy&#x27;))path\\abc\\yyy å­˜åœ¨ä»¥â€˜â€™/â€™â€™å¼€å§‹çš„å‚æ•°ï¼Œä»æœ€åä¸€ä¸ªä»¥â€/â€å¼€å¤´çš„å‚æ•°å¼€å§‹æ‹¼æ¥ï¼Œä¹‹å‰çš„å‚æ•°å…¨éƒ¨ä¸¢å¼ƒã€‚ 1234567891011121314&gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;aaa&#x27;,&#x27;/bbb&#x27;,&#x27;ccc.txt&#x27;))1 /bbb\\ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;/bbb&#x27;,&#x27;ccc.txt&#x27;))1 /bbb\\ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;/bbb&#x27;,&#x27;/ccc.txt&#x27;))1 /ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc.txt&#x27;))1 /aaa\\bbb\\ccc.txt &gt;&gt;&gt; print(&#x27;1&#x27;,os.path.join(&#x27;/aaa&#x27;,&#x27;bbb&#x27;,&#x27;/ccc.txt&#x27;))1 /ccc.txt (106æ¡æ¶ˆæ¯) os.path.join()å‡½æ•°ç”¨æ³•è¯¦è§£_swan777çš„åšå®¢-CSDNåšå®¢_os.path.joinå‡½æ•° os.path.realpath(__file__) è·å¾—å½“å‰è„šæœ¬çš„ç»å¯¹è·¯å¾„ np.array (106æ¡æ¶ˆæ¯) numpy.arrayå‡½æ•°è¯¦è§£_åŒæœ¨é’æ©™çš„åšå®¢-CSDNåšå®¢_numpy.array python æ•°ç»„æ“ä½œ (106æ¡æ¶ˆæ¯) numpy å¯¹äºŒç»´æ•°ç»„çš„å¸¸ç”¨æ“ä½œ_åœ°çƒè¢«æ”¯ç‚¹æ’¬èµ°å•¦çš„åšå®¢-CSDNåšå®¢_numpyäºŒç»´æ•°ç»„ pyçš„åˆ‡ç‰‡ç´¢å¼•æ˜¯start : end : step pythonæ•°ç»„åˆ‡ç‰‡ [(106æ¡æ¶ˆæ¯) pythonä¸­ x:,0]å’Œx[:,1] ç†è§£å’Œå®ä¾‹è§£æ_jobschuçš„åšå®¢-CSDNåšå®¢_x[:,0] x[m,n]æ˜¯é€šè¿‡numpyåº“å¼•ç”¨æ•°ç»„æˆ–çŸ©é˜µä¸­çš„æŸä¸€æ®µæ•°æ®é›†çš„ä¸€ç§å†™æ³• json.dump jsonPythonæ¨¡å—ä¸­çš„æ¨¡å—æä¾›äº†ä¸€ç§ç§°ä¸ºdump()å®ƒå°†Pythonå¯¹è±¡è½¬æ¢ä¸ºé€‚å½“çš„jsonå¯¹è±¡ã€‚å®ƒæ˜¯dumps()æ–¹æ³•ã€‚ dump()åŠå…¶å‚æ•° 1ç”¨æ³•ï¼š json.dump(d, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None) Python json.dump()ç”¨æ³•åŠä»£ç ç¤ºä¾‹ - çº¯å‡€å¤©ç©º (vimsky.com) np.cumsum Numpy.cumsumï¼ˆï¼‰ ç”¨æ³• ( np.cumsum) - ç®€ä¹¦ (jianshu.com) ç´¯åŠ  pid_grating_coupler_2D_1etch.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#&quot;&quot;&quot;#Copyright (c) 2020 Ansys Inc. &quot;&quot;&quot;######## IMPORTS ######### General purpose importsimport os,sysimport numpy as npimport scipy as spimport jsonsys.path.append(&quot;C:\\\\Program Files\\\\Lumerical\\\\v211\\\\api\\\\python\\\\&quot;)from lumjson import LumEncoder, LumDecoder# Optimization specific importsfrom lumopt.utilities.load_lumerical_scripts import load_from_lsffrom lumopt.utilities.wavelengths import Wavelengthsfrom lumopt.geometries.parameterized_geometry import ParameterizedGeometryfrom lumopt.geometries.polygon import FunctionDefinedPolygonfrom lumopt.figures_of_merit.modematch import ModeMatchfrom lumopt.optimizers.generic_optimizers import ScipyOptimizersfrom lumopt.optimization import Optimizationfrom lumopt.utilities.materials import Materialimport lumapicur_path = os.path.dirname(os.path.realpath(__file__))# Optimization global parameterslambda_c = 1.55e-6bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401params_file_apod = &quot;pid_optim_1.json&quot;params_final = &quot;pid_optim_final.json&quot;base_sim_2d = &quot;pid_grating_coupler_2D_TE_base.fsp&quot;base_sim_apodized_2d = &quot;pid_grating_coupler_2D_TE_base_apodized.fsp&quot;base_script_2d = &#x27;pid_grating_coupler_2D_TE_base.lsf&#x27;sim_2d_final = &quot;pid_grating_coupler_2D_final.fsp&quot;# Minimal feature size in um. Set to 0.1 to enforce 100nm min features size!min_feature_size = 0.1def etched_grating(params, fdtd, update_only = False): verts = grating_params_pos(params) if not update_only: fdtd.addpoly() fdtd.set(&quot;name&quot;, &quot;grating_poly&quot;) fdtd.setnamed(&quot;grating_poly&quot;, &quot;vertices&quot;, verts) fdtd.setnamed(&quot;grating_poly&quot;, &quot;x&quot;, 0) fdtd.setnamed(&quot;grating_poly&quot;, &quot;y&quot;, y0) fdtd.setnamed(&quot;grating_poly&quot;, &quot;index&quot;, indexSi)def grating_params_pos(params, output_waveguide_length = 0.5e-6): y3 = y0+height y1 = y3-etch_depth x0 = params[0]*1e-6 #&lt; First parameter is the starting position verts = np.array( [ [x_begin,y0],[x_begin,y3],[x0,y3],[x0,y1] ] ) ## Iterate over all but the last for i in range(n_grates-1): x1 = x0 + params[i*2+1]*1e-6 #&lt; Width of the etch x2 = x1 + params[i*2+2]*1e-6 #&lt; Width up verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x2,y3],[x2,y1]])),axis=0) x0 = x2 x1 = x0 + params[(n_grates-1)*2+1]*1e-6 #&lt; Width of the etch # x_end = x1+output_waveguide_length verts = np.concatenate((verts,np.array([[x1,y1],[x1,y3],[x_end,y3],[x_end,y0]])),axis=0) return vertsdef runGratingOptimization(bandwidth_in_nm, etch_depth, n_grates, initial_params, min_feature_size, working_dir):### Yet another parametrization which allows to enforce minimum feature size when the optimizer only supports box constraints### params = [x0, a1, b1, ..., aN] if initial_params is None: params = np.zeros(2*n_grates) for i in range(n_grates): params[i*2] = 0.2 #&lt; Width up params[i*2+1] = 0.4*((i+1)/(n_grates+1)) #&lt; Width of the deep etch params[0] = 0 #&lt; Overwrite the first since it has a special meaning: Start of the grating at x=0 else: params = initial_params bounds = [(min_feature_size, 1)]*(2*n_grates) bounds[0] = (-3,3) #&lt; Bounds for the stating position# geometry = ParameterizedGeometry(func = etched_grating,# initial_params = params,# bounds = bounds,# dx = 1e-5) geometry = FunctionDefinedPolygon(func = grating_params_pos, initial_params = params, bounds = bounds, z = 0.0, depth = height, eps_out = indexSiO2 ** 2, eps_in = indexSi ** 2, edge_precision = 5, dx = 1e-5)######## DEFINE FIGURE OF MERIT ######## fom = ModeMatch(monitor_name = &#x27;fom&#x27;, mode_number = 1, direction = &#x27;Backward&#x27;, target_T_fwd = lambda wl: np.ones(wl.size), norm_p = 1) ######## DEFINE OPTIMIZATION ALGORITHM ######## optimizer = ScipyOptimizers(max_iter = 250, method = &#x27;L-BFGS-B&#x27;, scaling_factor = 1, pgtol = 1e-6) ######## DEFINE BASE SIMULATION ######## base_script = load_from_lsf(os.path.join(os.path.dirname(__file__), base_script_2d))######## PUT EVERYTHING TOGETHER ######## lambda_start = lambda_c*1e9 - bandwidth_in_nm/2 lambda_end = lambda_c*1e9 + bandwidth_in_nm/2 lambda_pts = int(bandwidth_in_nm/10)+1 wavelengths = Wavelengths(start = lambda_start*1e-9, stop = lambda_end*1e-9, points = lambda_pts) opt = Optimization(base_script = base_script, wavelengths = wavelengths, fom = fom, geometry = geometry, optimizer = optimizer, use_var_fdtd = False, hide_fdtd_cad = False, use_deps = True, plot_history = True, store_all_simulations = True, save_global_index = False, label = None)######## RUN THE OPTIMIZER ######## result = opt.run(working_dir=working_dir) return resultif __name__ == &quot;__main__&quot;: params_file = params_file_apod result_file = params_final sim_file = sim_2d_finalwith open(os.path.join(cur_path, params_file)) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;]cur_path = os.path.dirname(os.path.realpath(__file__))working_dir = os.path.join(cur_path,&#x27;FreeGrating_1etch&#x27;)opt_result_2D = runGratingOptimization(bandwidth_in_nm=bandwidth_in_nm,etch_depth=etch_depth,n_grates = n_grates,initial_params=initial_params,min_feature_size=min_feature_size,working_dir=working_dir)opt_params_2D = opt_result_2D[1]with open(os.path.join(cur_path, result_file), &quot;w&quot;) as fh: json.dump(&#123; &quot;initial_params&quot;: opt_params_2D &#125;, fh, cls=LumEncoder, indent = 4)np.savetxt(os.path.join(cur_path, &quot;apod_2D_params.txt&quot;), opt_params_2D)######## 2-D SIMULATION WITH OPTIMIZED STRUCTURE ########with lumapi.FDTD(filename = os.path.join(cur_path, base_sim_2d), hide = True) as fdtd: vtx = grating_params_pos(opt_params_2D) fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.save(os.path.join(cur_path, sim_file)) np.zero ç”¨æ³•ï¼šzeros(shape, dtype=float, order='C') è¿”å›ï¼šè¿”å›æ¥ä¸€ä¸ªç»™å®šå½¢çŠ¶å’Œç±»å‹çš„ç”¨0å¡«å……çš„æ•°ç»„ï¼› å‚æ•°ï¼šshape:å½¢çŠ¶ â€‹ dtype:æ•°æ®ç±»å‹ï¼Œå¯é€‰å‚æ•°ï¼Œé»˜è®¤numpy.float64 â€‹ dtypeç±»å‹ï¼št ,ä½åŸŸ,å¦‚t4ä»£è¡¨4ä½ â€‹ b,å¸ƒå°”å€¼ï¼Œtrue or false â€‹ i,æ•´æ•°,å¦‚i8(64ä½ï¼‰ â€‹ u,æ— ç¬¦å·æ•´æ•°ï¼Œu8(64ä½ï¼‰ â€‹ f,æµ®ç‚¹æ•°ï¼Œf8ï¼ˆ64ä½ï¼‰ â€‹ c,æµ®ç‚¹è´Ÿæ•°ï¼Œ â€‹ o,å¯¹è±¡ï¼Œ â€‹ s,aï¼Œå­—ç¬¦ä¸²ï¼Œs24 â€‹ u,unicode,u24 â€‹ order:å¯é€‰å‚æ•°ï¼Œcä»£è¡¨ä¸cè¯­è¨€ç±»ä¼¼ï¼Œè¡Œä¼˜å…ˆï¼›Fä»£è¡¨åˆ—ä¼˜å…ˆ ä¾‹å­ np.zeros(5) array([ 0., 0., 0., 0., 0.]) geometry parameterizedGeometry åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å‡½æ•° FunctionDefinedPolygon å°†å…‰æ …è€¦åˆå™¨å‡ ä½•å›¾å½¢è®¾ç½®ä¸ºå¤šè¾¹å½¢ã€‚æˆ–è€…ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹ç”¨å‡½æ•°ParametrizedGeometryï¼Œä»è€Œåœ¨å‡ ä½•å½¢çŠ¶çš„è®¾ç½®æ–¹å¼ä¸Šæä¾›æ›´å¤§çš„çµæ´»æ€§ã€‚ 12bounds = [(min_feature_size, 1)]*(2*n_grates)bounds[0] = (-3,3) #&lt; Bounds for the stating position 1234# geometry = ParameterizedGeometry(func = etched_grating,# initial_params = params,# bounds = bounds,# dx = 1e-5) FunctionDefinedPolygon 123456789geometry = FunctionDefinedPolygon(func = grating_params_pos,initial_params = params,bounds = bounds,z = 0.0,depth = height,eps_out = indexSiO2 ** 2,eps_in = indexSi ** 2,edge_precision = 5,dx = 1e-5) dx æ˜¯æœ€å°ç½‘æ ¼ boundsæ˜¯æ¯ä¸ªå‚æ•°çš„å–å€¼èŒƒå›´ã€‚ eps_out = indexSiO2 ** 2, eps_in = indexSi ** 2, # æœ‰æ•ˆæŠ˜å°„ç‡çš„å¹³æ–¹ : eps_in: float å¤šè¾¹å½¢ææ–™çš„ä»‹ç”µå¸¸æ•°ã€‚ : eps_out: float å¤šè¾¹å½¢å‘¨å›´ææ–™çš„ä»‹ç”µå¸¸æ•°ã€‚ dx: float &gt; 0.0 ä½¿ç”¨ä»‹ç”µå¸¸æ•°æ‰°åŠ¨è®¡ç®— FOM æ¢¯åº¦çš„æ­¥é•¿ã€‚ Default = 1e-5 ** å¹‚ - è¿”å›xçš„yæ¬¡å¹‚ : edge_precision: int Number of quadrature(æ­£äº¤) points along each edge for computing the FOM gradient using the shape derivative approximation method. ä¸å¤ªçŸ¥é“ä¸ºä»€ä¹ˆæ˜¯5 æ²¿æ¯æ¡è¾¹çš„æ­£äº¤ç‚¹æ•°ï¼Œç”¨äºä½¿ç”¨å½¢çŠ¶å¯¼æ•°è¿‘ä¼¼æ–¹æ³•è®¡ç®— FOM æ¢¯åº¦ã€‚ fomè®¾ç½® Lumerical Python APIå­¦ä¹ ï¼ˆä¸ƒï¼‰â€”â€”å¯è§†åŒ–å‡ ä½• - it610.com 12345678from lumopt.figures_of_merit.modematch import ModeMatchclass ModeMatch(monitor_name, mode_number, direction, target_T_fwd, norm_p, target_fom) 12345fom = ModeMatch(monitor_name = &#x27;fom&#x27;,mode_number = 1,direction = &#x27;Backward&#x27;,target_T_fwd = lambda wl: np.ones(wl.size),norm_p = 1) mode_number = 1 æ„å‘³ç€TE mode direction = backward æ–¹å‘ monitor_name: str æ–‡ä»¶ä¸­ FOM ç›‘è§†å™¨çš„åç§°ã€‚ mode_number : str or int ç”¨äºæŒ‡å®šæ¨¡å¼ã€‚ å¦‚æœä½¿ç”¨ varFDTD æ±‚è§£å™¨ï¼š â€¢ â€˜fundamental modeâ€™ â€¢ int - ç”¨æˆ·é€‰æ‹©æ¨¡å¼å· If the FDTD solver is used: â€¢ â€˜fundamental modeâ€™ â€¢ â€˜fundamental TE modeâ€™ â€¢ â€˜fundamental TM modeâ€™ â€¢ int - user select mode number : direction : str æ–¹å‘ç”±FDTDåæ ‡ç¡®å®šï¼› å¯¹äºåœ¨æ­£æ–¹å‘ä¼ æ’­çš„æ¨¡å¼ï¼Œæ–¹å‘æ˜¯å‘å‰ï¼ˆforwardï¼‰çš„ã€‚ â€¢ â€˜Backwardâ€™ â€¢ â€˜Forwardâ€™ : multi_freq_source: booleanï¼ˆå¸ƒå°”å€¼ï¼‰, optional åªèƒ½ç”±é«˜çº§ç”¨æˆ·å¯ç”¨. See frequency Frequency dependent mode profile for more info. Default = False : target_T_fwd: float or function ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå°†è·å–æ³¢é•¿ç‚¹çš„æ•°é‡å¹¶è¿”å›å€¼ [0,1]ã€‚ é€šå¸¸ä½œä¸º lambda å‡½æ•°ï¼ˆlambda functionï¼‰æˆ–å•æ³¢é•¿ FOM çš„å•ä¸ªæµ®ç‚¹å€¼ä¼ é€’ã€‚ è¦æŒ‡å®šæ›´é«˜çº§çš„é¢‘è°±ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œä½¿ç”¨ numpy windowsä½œä¸ºæ¨¡æ¿å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ã€‚ : norm_p: float æ˜¯ FOM è®¡ç®—ä¸­ä½¿ç”¨çš„å¹¿ä¹‰ p èŒƒæ•°ï¼ˆgeneralized p-normï¼‰ã€‚ p èŒƒæ•°ï¼ˆpâ‰¥1ï¼‰å…è®¸ç”¨æˆ·å¢åŠ è¯¯å·®çš„æƒé‡ã€‚ ç”±äº p=1 æä¾›äº†æ­¤å‡½æ•°çš„ä¸‹é™ï¼Œå› æ­¤æ›´é«˜çš„ p æ•°å°†å¢åŠ è¯¯å·®é¡¹çš„æƒé‡ã€‚ é»˜è®¤ p =1.0 : target_fom: float å“è´¨å› æ•°çš„ç›®æ ‡å€¼ã€‚ è¿™åªä¼šæ”¹å˜æ‰“å°å’Œç»˜å›¾çš„è¡Œä¸ºã€‚ å¦‚æœå¯ç”¨æ­¤åŠŸèƒ½ï¼Œåˆ™é€šè¿‡è®¾ç½® 0.0 ä»¥å¤–çš„å€¼ï¼Œå°†ç»™å‡ºå½“å‰ FOM çš„è·ç¦»ã€‚ é»˜è®¤ = 0.0 target_T_fwd: float or function A function which will take the number of Wavelengths points and return values [0,1]. Usually passed as a lambda function or a single float value for single wavelength FOM. To specify a more advanced spectrum one can define a function, it may be helpful to use, numpy windows as a template. : norm_p: float Is the generalized p-norm used in the FOM calculation. The p-norm, with pâ‰¥1pâ‰¥1 allows the user to increase the weight of the error. Since p=1p=1 provides a lower bound on this function, a higher p-number will increase the weight of the error term. Default p =1.0 numpy.onesï¼ˆï¼‰ å‡½æ•°å‚æ•° (numpy.ones() function arguments) numpy.onesï¼ˆï¼‰å‡½æ•°çš„è¯­æ³•ä¸ºï¼š 1ones(shape, dtype=None, order=&#x27;C&#x27;) 1.shapeï¼šä¸€ä¸ªæ•´æ•°ç±»å‹æˆ–è€…ä¸€ä¸ªæ•´æ•°å…ƒç»„ï¼Œç”¨äºå®šä¹‰æ•°ç»„çš„å¤§å°ã€‚å¦‚æœä»…æŒ‡å®šä¸€ä¸ªæ•´æ•°ç±»å‹å˜é‡ï¼Œåˆ™è¿”å›ä¸€ç»´æ•°ç»„ã€‚å¦‚æœæŒ‡å®šçš„æ˜¯æ•´æ•°å…ƒç»„ï¼Œåˆ™è¿”å›ç»™å®šå½¢çŠ¶çš„æ•°ç»„ã€‚ 2.dtypeï¼šå¯é€‰å‚æ•°ï¼Œé»˜è®¤å€¼ä¸ºfloatã€‚ç”¨äºæŒ‡å®šæ•°ç»„çš„æ•°æ®ç±»å‹ã€‚ 3.orderï¼šæŒ‡å®šå†…å­˜é‡ä»¥è¡Œä¼˜å…ˆ(â€˜Câ€™)è¿˜æ˜¯åˆ—ä¼˜å…ˆ(â€˜Fâ€™)é¡ºåºå­˜å‚¨å¤šç»´æ•°ç»„ã€‚ lambda å‡½æ•° ç»†è¯´Pythonçš„lambdaå‡½æ•°ç”¨æ³•ï¼Œå»ºè®®æ”¶è— - çŸ¥ä¹ (zhihu.com) 1lambda argument_list:expersion optimizer 1234optimizer = ScipyOptimizers(max_iter = 250,method = &#x27;L-BFGS-B&#x27;,scaling_factor = 1,pgtol = 1e-6) : method: str Chosen minimization algorithm; experimenting with this option should only be done by advanced users. Default = â€˜L-BFGS-B' : scaling_factor: none, float, np.array None, scalar or a vector the same length as the optimization parameters. This is used to scale the optimization parameters. As of 2021R1.1, the default behavior in shape optimization is to automatically map the parameters the range [0,1] within the optimization routines; which was always the case in topology. The bounds, defined in the geometry class, or eps_min/eps_max are used for this. Default = None : pgtol: float The iteration will stop when max(|proj gi| i = 1, ..., n)&lt;=pgtol|max(|proj gi| i = 1, ..., n)&lt;=pgtol| where gigi is the i-th component of the projected gradient. Default = 1.0e-5 ä»¿çœŸè®¾ç½® 1base_script = load_from_lsf(os.path.join(os.path.dirname(__file__), base_script_2d)) åˆå¹¶ 1234567891011121314151617######## PUT EVERYTHING TOGETHER ######## lambda_start = lambda_c*1e9 - bandwidth_in_nm/2 lambda_end = lambda_c*1e9 + bandwidth_in_nm/2 lambda_pts = int(bandwidth_in_nm/10)+1 wavelengths = Wavelengths(start = lambda_start*1e-9, stop = lambda_end*1e-9, points = lambda_pts) opt = Optimization(base_script = base_script, wavelengths = wavelengths, fom = fom, geometry = geometry, optimizer = optimizer, use_var_fdtd = False, hide_fdtd_cad = False, use_deps = True, plot_history = True, store_all_simulations = True, save_global_index = False, label = None) è¿è¡Œ 1234######## RUN THE OPTIMIZER ######## result = opt.run(working_dir=working_dir) return result ä¸»å‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637if __name__ == &quot;__main__&quot;: params_file = params_file_apod result_file = params_final sim_file = sim_2d_finalwith open(os.path.join(cur_path, params_file)) as fh: initial_params = json.load(fh, cls=LumDecoder)[&quot;initial_params&quot;]cur_path = os.path.dirname(os.path.realpath(__file__))working_dir = os.path.join(cur_path,&#x27;FreeGrating_1etch&#x27;)opt_result_2D = runGratingOptimization(bandwidth_in_nm=bandwidth_in_nm,etch_depth=etch_depth,n_grates = n_grates,initial_params=initial_params,min_feature_size=min_feature_size,working_dir=working_dir)opt_params_2D = opt_result_2D[1]with open(os.path.join(cur_path, result_file), &quot;w&quot;) as fh: json.dump(&#123; &quot;initial_params&quot;: opt_params_2D &#125;, fh, cls=LumEncoder, indent = 4)np.savetxt(os.path.join(cur_path, &quot;apod_2D_params.txt&quot;), opt_params_2D)######## 2-D SIMULATION WITH OPTIMIZED STRUCTURE ########with lumapi.FDTD(filename = os.path.join(cur_path, base_sim_2d), hide = True) as fdtd: vtx = grating_params_pos(opt_params_2D) fdtd.addpoly() fdtd.set(&quot;vertices&quot;, vtx) fdtd.set(&quot;x&quot;, 0) fdtd.set(&quot;y&quot;, 0) fdtd.set(&quot;index&quot;, indexSi) fdtd.save(os.path.join(cur_path, sim_file)) np.savetxt np.savetxt()â€”â€”å°†arrayä¿å­˜åˆ°txtæ–‡ä»¶ï¼Œå¹¶ä¿æŒåŸæ ¼å¼ - æ·±åº¦å­¦ä¹ 1 - åšå®¢å›­ (cnblogs.com)","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"inverse design","slug":"inverse-design","permalink":"http://example.com/tags/inverse-design/"}]},{"title":"inverse design of grating coupler -- script learning","slug":"Lumerical/mode è„šæœ¬","date":"2022-07-13T08:44:10.741Z","updated":"2022-07-22T01:28:33.116Z","comments":true,"path":"2022/07/13/Lumerical/mode è„šæœ¬/","link":"","permalink":"http://example.com/2022/07/13/Lumerical/mode%20%E8%84%9A%E6%9C%AC/","excerpt":"","text":"mode è„šæœ¬å­¦ä¹  pid_grating_coupler_preliminar_design.lsf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748## Calculate the optimal grating pitch from the effective## indices of the slab modes using the FDE solver in MODE.clear;load(&quot;pid_grating_coupler_preliminary_design&quot;);# ------------------# Design Parameters:# ------------------mode_num = 1; # TMtheta_deg = 5.0;theta = theta_deg*pi/180;setanalysis(&#x27;wavelength&#x27;,1.55e-6);?lambda = getanalysis(&quot;wavelength&quot;);index_SiO2 = 1.44401;waveguide_thickness = 220e-9;etch = 80e-9;# -----------# Slab Modes:# -----------# slab mode on thinest part of the gratingswitchtolayout;setnamed(&quot;::model&quot;, &quot;thickness&quot;, waveguide_thickness);setnamed(&quot;::model&quot;, &quot;etch_depth&quot;, etch);findmodes;neff_thin = real(getresult(&quot;FDE::data::mode&quot;+num2str(mode_num),&quot;neff&quot;));# slab mode on thickest part of the gratingswitchtolayout;setnamed(&quot;::model&quot;, &quot;thickness&quot;, waveguide_thickness);setnamed(&quot;::model&quot;, &quot;etch_depth&quot;, 0);findmodes; # first mode should be TEz slab mode confined to the gratingneff_thick = real(getresult(&quot;FDE::data::mode&quot;+num2str(mode_num),&quot;neff&quot;));# ---------------------------------# Grating Pitch Initial Parameters:# ---------------------------------F0 = 0.95;?x0 = -2.5;?R = 0.03;?a = neff_thin - index_SiO2*sin(theta);?b = neff_thick - neff_thin;initial_params = [ x0, R, a, b ];jsonsave(&quot;pid_grating_coupler_initial_params.json&quot;, initial_params); setanalysis Sets calculation parameters in MODE' FDE and FEEM analysis window. Syntax Description ?setanalysis; Lists all the parameters in the analysis window. setanalysis(\"property\", value); Sets\"property\" to value. getanalysis Syntax Description ?getanalysis; Lists all the parameters in the analysis window. getanalysis(\"property\"); Returns the current value for the particular property on the analysis window findmodes - Script command MODE Calculates the modes supported by the structure using the current calculation settings. This function is the script equivalent to the \"Calculate Modes\" button. Each mode will be saved as a D-CARD named \"modeX\", where X is the xth mode found. The D-CARD saves data such as effective index and mode profile. Syntax Description n=findmodes; n will be equal to the number of modes found. Example To perform a frequency sweep on the first mode and plot the dispersion: 1234switchtolayout;findmodes;selectmode(1);setanalysis(&quot;track selected mode&quot;,1);setanalysis(&quot;detailed dispersion calculation&quot;,1);frequencysweep;D=getdata(&quot;frequencysweep&quot;,&quot;D&quot;);f=getdata(&quot;frequencysweep&quot;,&quot;f_D&quot;);plot(c/f*1e6,D*1e6,&quot;Wavelength (um)&quot;, &quot;Dispersion (ps/nm/km)&quot;); ? ?: Display output on screen. getresult Get results from simulation objects. Results will be returned as datasets. Syntax Description ?getresult(\"monitor_name\"); Returns the names of all the results for the monitor. All the dataset and scalar matrix results will be returned in this case. R = getresult(\"monitor_name\",\"T\"); Returns the result T from the monitor. T is a dataset. Examples This example shows how to get the electric field dataset from a monitor. We then apply a number of operations to the dataset, such as finding the maximum |E|^2 value, viewing the dataset with the visualizer, and creating a plot of Ex at the first frequency point. Note that E is a dataset, rather than a simple matrix based variable. Data within the dataset can be accessed with the '.' operator, as shown below. 123456789101112131415161718192021# get Electric field datasetE=getresult(&quot;monitor&quot;,&quot;E&quot;);# output dataset value to prompt?E;# check size of position vectors and data matrices?size(E.f);?size(E.Ex);# find maximum |E|^2 value ?max(E.E2);# view dataset with visualizervisualize(E);# select first frequency point of Ex data, then create plotEx = pinch(E.Ex,4,1); image(E.x*1e6,E.y*1e6,Ex,&quot;x (um)&quot;,&quot;y (um)&quot;,&quot;Ex&quot;); E vs x, y, z, lambda/f result: 5 1 result: 343 255 1 5 result: 3.223651 num2str Converts an integer, floating point number, or matrix into a string. Matrices can only be 1D or 2D. Users can use the format script command to change the precision of the output or since the 2019b r6 releases, users can specify the format by providing a second argument to the command. Syntax Description out = num2str(x); Converts the number x into a string. x can also be a 1D or 2D matrix. The tab character (rather than space) will be used as delimiter(åˆ†éš”ç¬¦) between columns. out = num2str(x, format); Converts the number x into a string. x can also be a 1D or 2D matrix. The format type options include: integers : %u: unsigned integer, takes the absolute value of the input %d: decimal signed integer, rounds the input %i: decimal signed integer, rounds the input floating point : %f: double %g: double %G: double, capital 'E' used for the exponential notation exponential : %e: double %E: double, capital 'E' used for the exponential notationWith the above format type options, both width and precision can be defined for the conversion. Boost formatting can also be used. These flags appear directly after the \"%\" in the format argument: flags : +: shows sign for all numbers 0: pad to full width with leading zero","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"script","slug":"script","permalink":"http://example.com/tags/script/"}]},{"title":"Inverse Design of Grating Coupler","slug":"Lumerical/å…‰æ …è€¦åˆå™¨çš„é€†è®¾è®¡","date":"2022-07-08T09:21:04.277Z","updated":"2022-10-22T12:36:01.053Z","comments":true,"path":"2022/07/08/Lumerical/å…‰æ …è€¦åˆå™¨çš„é€†è®¾è®¡/","link":"","permalink":"http://example.com/2022/07/08/Lumerical/%E5%85%89%E6%A0%85%E8%80%A6%E5%90%88%E5%99%A8%E7%9A%84%E9%80%86%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"Inverse Design of Grating Coupler (2D) â€“ Ansys Optics åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šä½¿ç”¨é€†å‘è®¾è®¡å·¥å…·ç®±ï¼ˆlumoptï¼‰æ¥è®¾è®¡ä¸€ä¸ªSOIå…‰æ …è€¦åˆå™¨ã€‚ç›¸æ¯”äºç²’å­ç¾¤ç®—æ³•ï¼ˆparticle swarm optimizationï¼ŒPSOï¼‰ï¼Œè¿™ç§ä¼˜åŒ–ç®—æ³•èƒ½å¤Ÿåœ¨å‡ æ¬¡è¿­ä»£åå°±èƒ½è·å¾—æœ€ä½³ç»“æœã€‚æœ€ä½³è®¾è®¡å°†è¢«å¯¼å‡ºåˆ°GDSæ–‡ä»¶ä¸­ï¼Œä»¥è¿›è¡Œè¿›ä¸€æ­¥çš„æ¨¡æ‹Ÿæˆ–åˆ¶é€ ã€‚ OVERVIEW Lumericalçš„é€†è®¾è®¡åŠŸèƒ½é€šè¿‡å°†åŸºäºæ¢¯åº¦çš„ä¼˜åŒ–ä¾‹ç¨‹çš„å¼ºå¤§åŠŸèƒ½ä¸éº¦å…‹æ–¯éŸ¦æ–¹ç¨‹ç»„åŸºæœ¬å±æ€§ä¸­çš„æ•ˆç‡ç›¸ç»“åˆï¼Œæä¾›äº†æ— ä¸ä¼¦æ¯”çš„ä¼˜åŒ–æ€§èƒ½ã€‚æ­¤ç¤ºä¾‹å°†æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨é€†å‘è®¾è®¡æ–¹æ³•ç”Ÿæˆå…·æœ‰æœ€å¤§è€¦åˆæ•ˆç‡çš„TEç»ç¼˜ä½“ç¡…ï¼ˆSOIï¼‰å…‰æ …è€¦åˆå™¨è®¾è®¡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å°†æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨å‚æ•°ä¿®æ”¹ç¤ºä¾‹ï¼Œä»¥ä¾¿æ‚¨å¯ä»¥å°†æ­¤æ–¹æ³•é‡ç”¨äºè‡ªå·±çš„è®¾è®¡ã€‚ æ­¤ç¤ºä¾‹å¹¿æ³›å€Ÿé‰´äº† LumOpt æ¡†æ¶ï¼š Photonic Inverse Design Overview - Python API Getting Started with lumopt - python API Optimizable Geometry - Python APIhttps://support.lumerical.com/hc/en-us/articles/360052044913) æ­¥éª¤ä¸€ï¼šåœ¨ MODE ä¸­å®šä¹‰åˆå§‹ä»¿çœŸ è¿™ä¸€åˆå§‹æ­¥éª¤çš„ç›®æ ‡æ˜¯ä¸ºä¼˜åŒ–æ‰¾åˆ°ä¸€ä¸ªè‰¯å¥½çš„èµ·ç‚¹ã€‚ä½¿ç”¨MODE FDEæ±‚è§£å™¨ï¼Œæˆ‘ä»¬æ ¹æ®ä¼˜åŒ–å‚æ•°ï¼ˆä¸­å¿ƒæ³¢é•¿ï¼Œèš€åˆ»æ·±åº¦ï¼Œå…‰çº¤è§’åº¦ï¼‰ç¡®å®šåˆå§‹çº¿æ€§è¶¾å½¢å…‰æ …ã€‚ æ­¥éª¤äºŒï¼šä½¿ç”¨2D FDTD çº¿æ€§ä¼˜åŒ–åˆ‡è¶¾å…‰æ … ç¬¬äºŒæ­¥æ˜¯ä½¿ç”¨ä¸€ç»„æœ‰é™çš„å‚æ•°æ¥ä¼˜åŒ–å…‰æ …ã€‚æˆ‘ä»¬ä½¿ç”¨æ­¥éª¤ 1 ä¸­å®šä¹‰çš„åˆ‡è¶¾å…‰æ …ä½œä¸ºèµ·ç‚¹ã€‚å…‰æ …çš„æ•°é‡å›ºå®šåœ¨25ä¸ªï¼Œèš€åˆ»æ·±åº¦å›ºå®šåœ¨80nmã€‚ä»æ­¥éª¤1è·å¾—çš„ä¸€ç»„4ä¸ªå‚æ•°ï¼Œä½œä¸ºå…‰æ …åˆ‡è¶¾çš„å‡½æ•°ï¼Œç”¨äºæå–åˆå§‹å‚æ•°é›†ä»¥æœ€å¤§åŒ–ä¼ è¾“/è€¦åˆã€‚ ä»ä¸Šä¸€æ­¥ä¸­æ‰¾åˆ°çš„åˆå§‹æ¡ä»¶å¼€å§‹ï¼Œæˆ‘ä»¬ç°åœ¨ä½¿ç”¨å…‰æ …å£çš„xåæ ‡ä½œä¸ºè‡ªç”±å‚æ•°ï¼ˆ2x 25ä¸ªå‚æ•°ï¼‰æ¥è¿è¡Œä¼˜åŒ–ã€‚ åŒ…æ‹¬åˆ¶é€ çº¦æŸ æˆ‘ä»¬è¿è¡Œ2Dä¼˜åŒ–ï¼Œè®¾ç½®æœ€å°ç‰¹å¾å°ºå¯¸çº¦æŸï¼ˆè®¾ç½®ä¸º100nmï¼‰ï¼Œä»¥ç¡®ä¿è®¾å¤‡å¯åˆ¶é€ ã€‚ æ­¥éª¤3ï¼šæå–3Dè®¾è®¡å’ŒGDSæ–‡ä»¶ï¼ˆè¿˜ä¸å¤ªæ‡‚ï¼‰ å¸¦æœ‰å¼¯æ›²å…‰æ …çš„ä¼˜åŒ–å…‰æ …è€¦åˆå™¨ç»„ä»¶å½¢çŠ¶å°†å¯¼å‡ºä¸ºGDS IIæ ¼å¼ï¼Œå¹¶å¯¼å‡ºä¸º3Dæ¨¡æ‹Ÿæ–‡ä»¶ï¼Œå¯ç”¨äºè¿›ä¸€æ­¥çš„æ¨¡æ‹Ÿå’Œ/æˆ–åˆ¶é€ ï¼ˆæ©æ¨¡è®¾è®¡ï¼‰ã€‚æˆ‘ä»¬ä½¿ç”¨è¦†ç›–æºåŒºåŸŸçš„åœ†å½¢å…‰æ …æ¥ç¡®ä¿æ”¶é›†æ‰€æœ‰å…‰çº¤å…‰ã€‚æˆ‘ä»¬è¿˜ä½¿ç”¨çŸ­çº¿æ€§é”¥åº¦è¿æ¥åˆ°450nmå®½æ³¢å¯¼ã€‚å…‰æ …å’Œé”¥åº¦çš„å‡ ä½•å½¢çŠ¶å¯ä»¥ç”±è®¾è®¡äººå‘˜è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚ Photonic Inverse Design: Grating Coupler (3D) è¿è¡Œå’Œç»“æœ(è¿è¡Œæ¨¡å‹çš„è¯´æ˜å’Œå…³é”®ç»“æœçš„è®¨è®º) æ­¥éª¤1ï¼šå®šä¹‰åŸºæœ¬ä»¿çœŸå‚æ•° å¦‚æœè¦æŒ‰æ¡ˆä¾‹è¿è¡Œï¼Œåˆ™ä¸éœ€è¦æ‰§è¡Œæ­¤æ­¥éª¤ï¼Œä½†æ˜¯ï¼Œæ ¹æ®éœ€è¦ä¿®æ”¹åˆå§‹æ¨¡æ‹Ÿæ–‡ä»¶éœ€è¦æ‰§è¡Œæ­¤æ­¥éª¤ã€‚ 12341.åœ¨æ¨¡å¼ä¸‹æ‰“å¼€æ¨¡æ‹Ÿæ–‡ä»¶ pid_grating_coupler_preliminary_design.lms2.ä¿®æ”¹æ‰€éœ€çš„åŸºæœ¬ä»¿çœŸå‚æ•°ï¼Œä¿å­˜æ–‡ä»¶ã€‚3.æ‰“å¼€è„šæœ¬æ–‡ä»¶ pid_grating_coupler_preliminary_design.lsf4.ä¿®æ”¹å‚æ•°å¹¶è¿è¡Œè„šæœ¬ å¯¹äºç»™å®šçš„ä¸­å¿ƒæ³¢é•¿\\(\\lambda_{c}\\)å’Œç»™å®šçš„åˆ»èš€æ·±åº¦\\(e\\)ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§å‚è€ƒæ–‡çŒ®[1]ï¼Œæ ¹æ®ç‰©ç†å‚æ•°è®¾è®¡ä¸€ä¸ªåˆ‡è¶¾å…‰æ …ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è¿›è¡Œç®€å•åœ°æ¨å¯¼ï¼Œæ›´å¤šå…³äºå˜é‡çš„è¯¦ç»†ä¿¡æ¯å’Œç²¾ç¡®å®šä¹‰ï¼Œè§å‚é˜…å‚è€ƒã€‚ ä¸»è¦æ€æƒ³æ˜¯ä½¿ç”¨åˆ‡è¶¾å…‰æ …çš„å±€éƒ¨æœ‰æ•ˆæŠ˜å°„ç‡ã€‚å¯¹äºæ¯ä¸€ä¸ªå•å…ƒï¼Œä½¿ç”¨æ’å€¼æ³•ï¼Œæœ‰æ•ˆæŠ˜å°„ç‡å¯ç”¨ä¸‹å¼è¿‘ä¼¼è®¡ç®—ï¼š \\[ n_{eff}=F\\cdot{n_0}+(1-F)n_E \\] Fæ˜¯å¡«å……åˆ†æ•°(å ç©ºæ¯”),\\(n_0\\)æ˜¯æœªåˆ»èš€åŒºåŸŸçš„æœ‰æ•ˆæŠ˜å°„ç‡ç‡ï¼Œ\\(n_E\\)æ˜¯éƒ¨åˆ†åˆ»èš€åŒºåŸŸçš„æœ‰æ•ˆæŠ˜å°„ç‡ ä¸ºäº†ç¡®å®šè¿™äº›æœ‰æ•ˆæŒ‡æ•°ï¼Œæˆ‘ä»¬ä½¿ç”¨ MODE FDE æ±‚è§£å™¨ã€‚å¯¹220nmé«˜åº¦çš„ç¡…æ³¢å¯¼è¿›è¡Œä»¿çœŸï¼Œä½¿ç”¨æŠ˜å°„ç‡ä¸º3.476683.47668çš„ç¡…ï¼Œä»¥åŠæŠ˜å°„ç‡ä¸º1.444011.44401çš„èƒŒæ™¯ææ–™ï¼ˆSiO2ï¼‰ã€‚ æˆ‘ä»¬å¯ä»¥å†™å‡ºå¸ƒæ‹‰æ ¼æ¡ä»¶çš„å…¬å¼ï¼Œç”¨äºè®¡ç®—å…‰æ …å‘¨æœŸ \\[ Î›=\\frac{Î»_c}{n_{eff}-n_{bg}sin\\theta} \\] \\(\\theta\\)æ˜¯å…¥å°„å…‰çš„å…¥å°„è§’åº¦,\\(\\lambda{c}\\)æ˜¯ä¸­å¿ƒæ³¢é•¿,\\(n_{bg}\\)æ˜¯èƒŒæ™¯æŠ˜å°„ç‡ å¯¹äºä¸€ä¸ªçº¿æ€§åˆ‡è¶¾å…‰æ …ï¼Œå¡«å……å› å­éšç€æ³¢å¯¼çš„ä½ç½®è€Œæ”¹å˜ \\[ F(x)=F_0-R \\cdot x \\] Ræ˜¯åˆ‡è¶¾ç³»æ•°ï¼Œ\\({F_0}\\)æ˜¯åˆå§‹çš„å¡«å……å› å­ã€‚åœ¨ç†æƒ³æƒ…å†µä¸‹ï¼Œ\\(F_0\\)åº”è¯¥æ˜¯1,å› ä¸ºæˆ‘ä»¬ä»¥ä¸€ä¸ªæ— åˆ»èš€çš„æ³¢å¯¼å¼€å§‹,ä½†æ˜¯æˆ‘ä»¬è®¾ç½®\\(F_0=0.95\\),ç›®çš„æ˜¯ä¸ºäº†é¿å…ä¸€äº›å¾ˆå°çš„é—´éš”(trenches)ã€‚ åœ¨æ’å€¼æœ‰æ•ˆæŒ‡æ•°ä¸­ä½¿ç”¨çº¿æ€§åˆ‡è¶¾(Using the linear apodization in the interpolated effective index:)ï¼š \\[ n_{eff}(x)=F(x)n_0+(1-F(x))n_E=n_E+F(x)\\Delta n \\] æˆ‘ä»¬å°±èƒ½å¾—åˆ°éšç€ç©ºé—´å˜åŒ–çš„å…‰æ …å‘¨æœŸçš„å‡½æ•°ï¼š \\[ Î›(x)=\\frac{Î»_c}{(n_{E}-n_{bg}sin\\theta)+F(x)\\Delta n} \\] ä¸ºäº†æ‰¾åˆ°è‰¯å¥½çš„åˆå§‹æ¡ä»¶,æˆ‘ä»¬å¯¹æ¯ä¸ªå‘¨æœŸç¦»æ•£åŒ–å¤„ç†ï¼Œå¯ä»¥å¾—åˆ°æ¯ä¸ªå‘¨æœŸçš„å¡«å……å› å­\\(F_i\\)ä»¥åŠå‘¨æœŸ\\(Î›_i\\) è‡³ä»Šï¼Œæˆ‘ä»¬è¿˜å‰©å”¯ä¸€ä¸€ä¸ªä¸çŸ¥é“çš„å‚æ•°--\\(R\\)ã€‚ä¸ºäº†ä¸€ä¸ªæ›´åŠ é«˜æ•ˆçš„ä¼˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥å¼•å…¥å››ä¸ªå¾…ä¼˜åŒ–çš„å‚æ•°ï¼š \\[ p=[x_0,R,a,b] \\] ç›¸å…³è®¡ç®—å…¬å¼å¦‚ä¸‹: \\[ F_i=F_0-R(x_{i-1}-x_0) \\] \\[ Î›_i=\\frac{\\lambda_c}{a+F_ib} \\] \\[ a=n_E-n_{bg}sin\\theta \\] \\[ b=\\Delta n \\] bæ˜¯æœ‰æ•ˆæŠ˜å°„ç‡çš„å·®å€¼ã€‚b = neff_thick - neff_thin å…‰æ …è€¦åˆå™¨ç»“æ„ å³å›¾çš„ä¸‹æ–¹çš„ç»“æ„æ˜¯ä¼ ç»Ÿçš„çº¿æ€§å˜è¿¹å…‰æ …ï¼Œå‘¨æœŸæ˜¯å›ºå®šçš„ã€‚ å³å›¾çš„ä¸Šæ–¹çš„ç»“æ„æ˜¯å‘¨æœŸä¸å›ºå®šçš„çº¿æ€§å˜è¿¹ æ³¨æ„\\(x_0\\)å’ŒRå°†å•ç‹¬å®šä¹‰ã€‚æˆ‘ä»¬å°†\\(x_0\\)è®¾ç½®ä¸º\\(-2.5Î¼m\\)ï¼Œå°†\\(R\\)è®¾ç½®ä¸º\\(0.03Î¼m^{-1}\\)(è§å‚è€ƒ[1])ã€‚å¦‚æœä½ æ›´æ”¹ææ–™ï¼Œå‡ ä½•å½¢çŠ¶ï¼Œæˆ–è€…åæŒ¯ï¼ˆpolarizationï¼‰ï¼Œä½ åº”è¯¥è¿›è¡Œè¿™äº›å‚æ•°çš„æ‰«æï¼Œæ¥æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„åˆå§‹æ¡ä»¶ã€‚ è„šæœ¬pid_grating_coupler_preliminary_grating_design.lsf å°†ä¼šè®¡ç®—è¿™äº›åˆå§‹å‚æ•°ï¼Œå¹¶å°†ç»“æœä¿å­˜åœ¨pid_grating_coupler_initial_params.jsonæ–‡ä»¶ä¸­ï¼Œä»¥ä¾¿ä¸‹ä¸€æ­¥ä½¿ç”¨ã€‚ æ­¥éª¤äºŒï¼šä½¿ç”¨2D FDYDä¼˜åŒ–åˆ‡è¶¾å…‰æ … æˆ‘ä»¬é¦–å…ˆéœ€è¦æ‰¾åˆ°å…‰çº¤çš„æœ€ä½³ä½ç½®ã€‚ ç”¨FDTDçš„ç¼–è¯‘å™¨æ‰“å¼€pythonè„šæœ¬pid_grating_coupler_sweep_2D.py å¦‚æœéœ€è¦çš„è¯ï¼Œå¯ä»¥ä¿®æ”¹å‚æ•°ã€‚ è¿è¡Œè„šæœ¬ è¿™ä¸ªè„šæœ¬ä¼šåŠ è½½æ­¥éª¤ä¸€ä¸­çš„åˆå§‹è®¾è®¡ï¼Œå¹¶ä¸”è¿è¡Œå…‰çº¤æœ€ä½³ä½ç½®çš„æ‰«æï¼Œæ¥æ‰¾åˆ°æœ€ä½³çš„ä½ç½®ã€‚ image-20220712155120278 æ‰¾åˆ°çš„æœ€ä½³ä½ç½®ä¸º\\(4.2Î¼m\\)ï¼Œè¶…è¿‡ç™¾åˆ†ä¹‹60çš„ä¼ è¾“ç‡ The optimum position is found at 4.2Î¼m, with a transmission over 60%. ç”¨FDTDè„šæœ¬ç¼–è¾‘å™¨,æ‰“å¼€python è„šæœ¬ pid_grating_coupler_2D_apodized.py å¦‚æœéœ€è¦çš„è¯,æ›´æ–°å‚æ•°,å¹¶ä¸”è¿è¡Œè„šæœ¬ æ‰“å¼€è„šæœ¬pid_grating_coupler_2D_1etch.py è¿è¡Œè„šæœ¬ åœ¨è¿™ä¸€æ­¥,æˆ‘ä»¬ä¼šä½¿ç”¨ä»1åˆ°3çš„è·å¾—çš„å‚æ•°,ç„¶åæå–æ¯ä¸ªæ¯ä¸ªå£çš„xåæ ‡ä½œä¸ºè‡ªç”±å‚æ•°ã€‚æ›´åŠ å…·ä½“åœ°è¯´ï¼Œå‚æ•°å°†ä¼šæ˜¯å…‰æ …çš„èµ·å§‹ä½ç½®ï¼Œèš€åˆ»çš„å®½åº¦ï¼Œä»¥åŠæ¯ä¸ªå…‰æ …çš„é½¿çš„å®½åº¦ã€‚ è„šæœ¬pid_grating_coupler_2D_apodized.pyå°†è¿™äº›å‚æ•°ä¿å­˜åˆ°pid_optim_1.jsonæ–‡ä»¶ä¸­ï¼Œè¿™äº›å‚æ•°å¯ä»¥ç”¨ä½œèµ·ç‚¹ã€‚ æˆ‘ä»¬åœ¨è¿™ä¸€æ­¥ä¸­ä½¿ç”¨ä½¿ç”¨æœ€å°ç‰¹å¾å°ºå¯¸çº¦æŸï¼Œå°†min_feature_size=0.1ï¼Œè¿™å°†ç¡®ä¿ï¼Œä¸¤ä¸ªå…‰æ …çš„é—´éš”å°†ä¼šå¤§äº\\(100nm\\)ã€‚ resuls_with_min_features_new optimization æœ€ç»ˆçš„ä¼ è¾“ç‡çº¦ä¸º60%ï¼Œç°åœ¨çš„å…‰æ …è€¦åˆå™¨æ˜“äºåˆ¶é€ ã€‚ä¼˜åŒ–çš„å…‰æ …å‚æ•°ä¿å­˜åœ¨pid_optim_final.jsonã€‚ æ­¥éª¤ä¸‰: æå– 3D è®¾è®¡å’Œ GDS æ‰“å¼€è„šæœ¬pid_grating_coupler_3D.py å¦‚æœéœ€è¦ï¼Œè¯·ä¿®æ”¹è®¾ç½® è¿è¡Œè„šæœ¬ è¯¥è„šæœ¬å°†åŠ è½½ä¼˜åŒ–ç»“æœï¼Œè®¾ç½®ç›¸åº”çš„3Dæ¨¡æ‹Ÿï¼Œå¹¶ä»ç»“æ„ä¸­æå–GDSã€‚ ä¸€äº›é‡è¦çš„æ¨¡å‹è®¾ç½® ä¼˜åŒ–çš„ä¸»è¦å‚æ•°åœ¨è„šæœ¬çš„åˆå§‹è®¾ç½®ï¼Œå¹¶ä¸”ä¿å­˜åœ¨åˆå§‹æ¨¡æ‹Ÿæ–‡ä»¶pid_grating_coupler_2D_TE_base.fspã€‚ 12345678910111213# Optimization global parameterslambda_c = 1.55e-6 bandwidth_in_nm = 0 #&lt; Only optimize for center frequency of 1550nmF0 = 0.95height = 220e-9etch_depth = 80e-9y0 = 0x_begin = -5.1e-6x_end = 22e-6n_grates = 25indexSi = 3.47668indexSiO2 = 1.44401 åæŒ¯ï¼šæ‰€é€‰çš„æŠ˜å°„ç‡å€¼ä»£è¡¨SOIèŠ¯ç‰‡åˆ¶é€ å·¥è‰ºã€‚ç”±äºç¡…å’Œæ°§åŒ–ç¡…ä¹‹é—´çš„æŠ˜å°„ç‡å¯¹æ¯”åº¦å¾ˆé«˜ï¼Œå› æ­¤é›†æˆæ³¢å¯¼çš„ä¸¤ç§åŸºæœ¬æ¨¡å¼ï¼ˆTEå’ŒTMï¼‰çš„æœ‰æ•ˆæŠ˜å°„ç‡ä¹‹é—´å­˜åœ¨å¾ˆå¤§å·®å¼‚ã€‚å› æ­¤ï¼ŒSOIå…‰æ …è€¦åˆå™¨å…·æœ‰å¾ˆå¼ºçš„åæŒ¯é€‰æ‹©æ€§ã€‚ç›®å‰çš„è®¾è®¡ä¸»è¦æ˜¯TE modeï¼Œå› ä¸ºè¿™æ˜¯æœ€å¸¸è§çš„é€‰æ‹©ï¼Œä¸è¿‡ä¹Ÿå¯ä»¥é’ˆå¯¹TMæ¨¡å¼è®¾ç½®ä¼˜åŒ–ã€‚è¦å°†æåŒ–æ›´æ”¹ä¸º TM æˆ–è€…higher order modeï¼Œéœ€è¦æ›´æ”¹ pid_grating_coupler_preliminary_design.lsf å’Œ pid_grating_coupler python æ–‡ä»¶çš„ ModeMatch ç±»ä¸­çš„æ¨¡å¼ç¼–å·ã€‚æ­¤å¤–ï¼Œè¿˜åº”æ›´æ”¹base fsp æ–‡ä»¶ä¸­çš„åæŒ¯è§’ã€‚å¯¹äº TM ä¼˜åŒ–ï¼Œåœ¨è¿™ä¸ªé…ç½®ä¸­ï¼Œæ¨¡å¼ç¼–å·ä¸º 2ï¼ŒåæŒ¯è§’ä¸º 0 åº¦ã€‚ å€¾æ–œè§’åº¦ ï¼šè€¦åˆæ•ˆç‡å¾ˆå¤§ç¨‹åº¦ä¸Šå–å†³äºå…‰çº¤å¦‚ä½•ä¸é¡¶éƒ¨æ°§åŒ–ç¡…åŒ…å±‚ç›¸é‡ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨é«˜æ–¯å…‰æŸä½œä¸ºå…‰çº¤å…‰æŸè¾“å‡ºçš„è¿‘ä¼¼å€¼ã€‚å‡è®¾å…‰çº¤çš„æœ«ç«¯ä»¥å¾ˆå°çš„è§’åº¦æŠ›å…‰ï¼Œä»¥ä¾¿å…‰çº¤åœ¨å®‰è£…åœ¨é¡¶éƒ¨åŒ…å±‚ä¸Šæ—¶å€¾æ–œã€‚è¿™ç§å€¾æ–œå¯é˜²æ­¢å…‰åå°„åˆ°å…‰çº¤ä¸­ã€‚ èš€åˆ»æ·±åº¦ï¼šè€¦åˆæ•ˆç‡å¯¹å…‰æ …çš„å‘¨æœŸã€å ç©ºæ¯”å’Œèš€åˆ»æ·±åº¦é«˜åº¦æ•æ„Ÿã€‚ä¸ºç®€å•èµ·è§ï¼Œè¿™é‡Œé‡‡ç”¨å›ºå®šçš„èš€åˆ»æ·±åº¦ï¼Œä½†æ˜¯ï¼Œå¦‚æœå¯ç”¨çš„åˆ¶é€ å·¥è‰ºæä¾›äº†è¿™ç§è‡ªç”±åº¦ï¼Œå®ƒä¹Ÿå¯ä»¥æ”¹å˜ã€‚ è¡¬åº•ï¼šå¦‚æœåˆ¶é€ çš„å™¨ä»¶ä¸­å­˜åœ¨ç¡…è¡¬åº•ï¼Œåˆ™åº”å°†å…¶åŒ…å«åœ¨æ¨¡æ‹Ÿä¸­ã€‚è¡¬åº•å°†å¯¹å…‰çš„è€¦åˆæ–¹å¼äº§ç”Ÿæ˜æ˜¾å½±å“ï¼Œä¸èƒ½åƒå…¶ä»–å™¨ä»¶è®¾è®¡ä¸­ç»å¸¸åšçš„é‚£æ ·çœç•¥ã€‚ å“è´¨å› æ•°ï¼ˆFOMï¼‰ï¼šè¯¥è®¾è®¡çš„ç›®çš„æ˜¯åœ¨æ‰€éœ€æ³¢é•¿ä¸‹å®ç°æœ€ä½³è€¦åˆï¼Œé€‰æ‹©ä¼˜åŒ–å“è´¨å› æ•°ä½œä¸ºé€šè¿‡1550nmå¤„çš„å…‰æ …è€¦åˆå™¨ä¼ è¾“ï¼Œä¼˜åŒ–ç®—æ³•å°†å°è¯•æœ€å¤§åŒ–è¯¥å€¼ã€‚Lumoptä½¿ç”¨mode power couplingï¼Œå½“æ‰«æå…‰çº¤ä½ç½®æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨åŠŸç‡ä¼ è¾“ç‡ã€‚ å¯ä¼˜åŒ–å‡ ä½•å½¢çŠ¶çš„å®šä¹‰ï¼šå›ºå®šyåæ ‡çš„å¤šè¾¹å½¢ï¼Œå¹¶ä¸”å¯ä¿®æ”¹çš„å£çš„xåæ ‡ä»¥è·å¾—æœ€ä½³å‡ ä½•å½¢çŠ¶ã€‚ åœºç›‘æ§å™¨ï¼šåœºç›‘æ§å™¨DFT monitor (opt_field) è¢«ç”¨äºå…‰æ …ä¸­çš„æ”¶é›†å…‰åœºçš„æ•°æ®ï¼Œç”¨æ¥è®¡ç®—å…‰åœºçš„æ¢¯åº¦ï¼Œæ¢¯åº¦è¢«ç”¨äºä¼˜åŒ–ç®—æ³•ä¸­ã€‚å› æ­¤ï¼Œåœºç›‘æ§å™¨çš„ä½ç½®ç‰¹åˆ«é‡è¦ï¼Œå› æ­¤åœºç›‘æ§å™¨åº”è¯¥è¦†ç›–å…¨éƒ¨çš„ä¼˜åŒ–åŒºåŸŸã€‚ å“è´¨å› æ•°åœºç›‘æ§å™¨ï¼šå› ä¸ºè¿™ä¸ªåœºç›‘è§†å™¨è¢«ç”¨äºè®¡ç®—ä¼˜åŒ–æ‰€éœ€çš„å“è´¨å› æ•°ï¼Œï¼ˆæ¨¡å¼ä¸è¾“å‡ºæ³¢å¯¼çš„åŸºæœ¬TEæ¨¡å¼é‡å ï¼‰ï¼Œå› æ­¤åº”è¯¥ä½äºé€‚å½“å°ºå¯¸çš„å…‰æ …è€¦åˆå™¨çš„è¾“å‡ºåšå¯¼ä¸­ã€‚ å…‰æ …çš„é«˜åº¦å’Œæ·±åº¦ï¼šå‡ ä½•å¯¹è±¡çš„é«˜åº¦ï¼ˆæ·±åº¦ï¼‰æ˜¯æ ¹æ®åˆ¶é€ è¿‡ç¨‹é€‰æ‹©çš„ã€‚è¿™å¯¹äºç¡®ä¿æ­£ç¡®é›†åˆè®¾ç½®çš„3Dä»¿çœŸå°¤ä¸ºé‡è¦ã€‚è¿™æ˜¯é€šè¿‡è°ƒæ•´è„šæœ¬ä¸­çš„heightå’Œetch_depthæ¥å®Œæˆçš„ã€‚å°†ç»“æ„å¯¼å‡ºåˆ°GDSæ–‡ä»¶çš„è„šæœ¬ä¸­éœ€è¦ç”¨åˆ°è¿™äº›å€¼ã€‚ å‚æ•°è¾¹ç•Œå’Œåˆå§‹å€¼ï¼šä¼˜åŒ–ç®—æ³•æ”¹å˜å‚æ•°çš„èŒƒå›´ä»¥åŠè¿™äº›å‚æ•°çš„åˆå§‹å€¼ç”±initial_paramså®šä¹‰ï¼Œåœ¨è°ƒç”¨å‡½æ•°æ—¶å°†bounds arrayså®šä¹‰ä¸ºå‡½æ•° FunctionDefinedPolygonI çš„è¾“å…¥å‚æ•°ã€‚ å…‰è°±èŒƒå›´:ä¼˜åŒ–çš„å…‰è°±èŒƒå›´å¯ä»¥æŒ‡å®šä¸ºæ•°ç»„â€œæ³¢é•¿â€ä»¥åŠä¼˜åŒ–ä¸­è€ƒè™‘çš„é¢‘ç‡ç‚¹æ•°ã€‚è¯·æ³¨æ„ï¼Œé€‰æ‹©å¤§é‡é¢‘ç‡ç‚¹å°†ä½¿ä¼˜åŒ–é€Ÿåº¦æ…¢å¾—å¤šï¼Œå¹¶ä¸”åœ¨FDTDå’ŒPythonç¯å¢ƒä¹‹é—´ä¼ è¾“å¤§é‡æ•°æ®æ—¶å¯èƒ½ä¼šå¯¼è‡´é—®é¢˜ã€‚å»ºè®®å°†æ­¤æ•°å­—ä¿æŒåœ¨å°½å¯èƒ½ä½çš„æ°´å¹³ï¼Œç‰¹åˆ«æ˜¯å¯¹äº 3D æ¨¡æ‹Ÿã€‚å¯¹äºå•é¢‘ç‡ä¼˜åŒ–ï¼Œåªéœ€é€‰æ‹©ç›¸åŒçš„å¼€å§‹å’Œåœæ­¢å€¼ï¼Œå¹¶å°†ç‚¹æ•°è®¾ç½®ä¸º 1ã€‚ æœ€å¤§è¿­ä»£æ¬¡æ•° ï¼šè™½ç„¶ç®—æ³•èƒ½å¤Ÿåœ¨å“è´¨å› æ•°çš„æ¢¯åº¦ä½äºæŸä¸ªé˜ˆå€¼æ—¶åœæ­¢ä¼˜åŒ–ï¼Œä½†ç”¨äºå®šä¹‰ä¼˜åŒ–ç®—æ³•çš„â€œmax_iterâ€å˜é‡å¯ç”¨äºé™åˆ¶ç®—æ³•èƒ½å¤Ÿæ‰§è¡Œçš„è¿­ä»£æ¬¡æ•°ã€‚ ç›®æ ‡ FOM ï¼šåœ¨å®šä¹‰ FOM æ—¶ï¼Œå¯ä»¥ä½¿ç”¨â€œtarget_T_fwdâ€è¾“å…¥å‚æ•°æŒ‡å®šä¸åŒæ³¢é•¿ä¸‹ FOM çš„ç›®æ ‡å€¼ã€‚è¿™åº”è¯¥æ˜¯ä¸€ä¸ªä¸æ³¢é•¿æ•°æ®é•¿åº¦ç›¸åŒçš„æ•°ç»„ï¼Œå¹¶åŒ…å«æ¯ä¸ªæ³¢é•¿çš„ç›®æ ‡FOMå€¼ï¼ˆæ­£å‘ä¼ è¾“ï¼‰ï¼Œè¯¥å€¼å¯ä»¥å°äº1ã€‚å¯¹äºæ‰€æœ‰æ³¢é•¿ï¼Œé»˜è®¤å€¼ä¸º 1ã€‚è¿™ä½¿ç”¨æˆ·èƒ½å¤Ÿé€‰æ‹©åœ¨è®¾è®¡å…‰è°±èŒƒå›´ç»™å‡ºç›®æ ‡çš„Transmissionã€‚ ä½¿ç”¨è‡ªå·±çš„å‚æ•°æ›´æ–°æ¨¡å‹ å‡ ä½•ï¼š å¦‚æœæ‚¨éœ€è¦ä¸ºå…‰æ …è€¦åˆå™¨å®šä¹‰è‡ªå·±çš„å‡ ä½•å›¾å½¢ï¼ŒåŒ…æ‹¬SOIåšåº¦ï¼ˆå…‰æ …é«˜åº¦ï¼‰å’Œèš€åˆ»æ·±åº¦ï¼Œåˆ™åº”åœ¨åŸºæœ¬ä»¿çœŸæ–‡ä»¶å’Œä¼˜åŒ–è®¾ç½®Pythonè„šæœ¬ä¸­è¿›è¡Œç›¸åº”çš„æ›´æ”¹ã€‚è¿™å¯èƒ½éœ€è¦æ›´æ”¹åŸºæœ¬è„šæœ¬ä¸­çš„å¯¹è±¡èŒƒå›´å’Œä½ç½®ï¼Œå³pythonè„šæœ¬ä¸­å¤šè¾¹å½¢çš„â€œetch_depthâ€å‚æ•°ï¼Œå…¶å€¼ä¹Ÿä¼šä¼ é€’åˆ°è„šæœ¬çš„GDSå¯¼å‡ºéƒ¨åˆ†ã€‚æºã€ä»¿çœŸåŒºåŸŸã€ç½‘æ ¼è¦†ç›–ä»¥åŠåœºæ¢¯åº¦å’Œ FOM ç›‘è§†å™¨çš„å°ºå¯¸ä¹Ÿåº”ç›¸åº”åœ°è¿›è¡Œè°ƒæ•´ï¼Œä»¥ç¡®ä¿å®ƒä»¬æ­£ç¡®è¦†ç›–æ•´ä¸ªç»“æ„ã€‚ åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å‡½æ•° FunctionDefinedPolygon å°†å…‰æ …è€¦åˆå™¨å‡ ä½•å›¾å½¢è®¾ç½®ä¸ºå¤šè¾¹å½¢ã€‚æˆ–è€…ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹ç”¨å‡½æ•°ParametrizedGeometryï¼Œä»è€Œåœ¨å‡ ä½•å½¢çŠ¶çš„è®¾ç½®æ–¹å¼ä¸Šæä¾›æ›´å¤§çš„çµæ´»æ€§ã€‚å¯ä»¥é€šè¿‡æ³¨é‡Š/å–æ¶ˆæ³¨é‡Šæ¥å®ŒæˆFunctionDefinedPolygonåˆ°ParametrizedGeometryçš„è½¬æ¢ã€‚ 123456789101112131415161718192021def runGratingOptimization(bandwidth_in_nm, etch_depth, n_grates, params, working_dir):bounds = [(-4,3), #&lt; Starting position (in um) (0,0.05), #&lt; Scaling parameter R (1.5,3), #&lt; Parameter a (0,2)] #&lt; Parameter b # geometry = ParameterizedGeometry(func = etched_grating, # initial_params = params, # bounds = bounds, # dx = 1e-5) geometry = FunctionDefinedPolygon(func = grating_params_pos, initial_params = params, bounds = bounds, z = 0.0, depth = 110e-9, eps_out = indexSiO2 ** 2, eps_in = indexSi ** 2, edge_precision = 5, dx = 1e-5) ææ–™ ï¼šåœ¨å®šä¹‰å‡ ä½•ä½“æ—¶ï¼Œé€šè¿‡è°ƒç”¨å‡½æ•°DefinedPolygonï¼ˆæ­¤å¤„å®ƒä»¬è¡¨ç¤ºä¸ºæŠ˜å°„ç‡çš„å¹³æ–¹ï¼‰ï¼‰ï¼Œæ¨¡æ‹Ÿæ–‡ä»¶ä¸­ä¸­åŒ…å«çš„ææ–™ï¼ˆä½¿å‡ ä½•ä½“çš„ææ–™ï¼ˆcoreï¼‰å’Œå›´ç»•å…¶å‘¨å›´çš„ææ–™ï¼ˆcladdingï¼‰ï¼‰çš„ä»‹ç”µå¸¸æ•°åº”ä¼ é€’ç»™ä¼˜åŒ–å™¨ã€‚æ³¢å¯¼çš„æŠ˜å°„ç‡ï¼ˆéä»‹ç”µå¸¸æ•°ï¼‰ï¼ˆä¸å¯ä¼˜åŒ–çš„å‡ ä½•ä½“ç›¸åŒï¼‰ä¹Ÿåº”åœ¨baseä»¿çœŸè„šæœ¬ä¸­å®šä¹‰ã€‚ å…‰æ …å‡ ä½•å½¢çŠ¶ ï¼šæˆ‘ä»¬ä½¿ç”¨åœ†å½¢å…‰æ …è¿›è¡Œ3Dæ¨¡æ‹Ÿå’ŒGDSå¯¼å‡ºã€‚å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„å…‰æ …å½¢çŠ¶ï¼Œç±»ä¼¼äºèšç„¦å…‰æ …è€¦åˆå™¨ã€‚ è¿›ä¸€æ­¥æ¨åŠ¨æ¨¡å‹ é’ˆå¯¹æƒ³è¦è¿›ä¸€æ­¥è‡ªå®šä¹‰æ¨¡å‹çš„ç”¨æˆ·çš„ä¿¡æ¯å’Œæç¤º é”¥åº¦ä¼˜åŒ– ï¼š3-Dè€¦åˆå™¨æ¨¡å‹ä½¿ç”¨çº¿æ€§é”¥åº¦éƒ¨åˆ†è¿æ¥åˆ°å…‰æ …å¼€å§‹æ—¶çš„é›†æˆæ³¢å¯¼ã€‚é€šè¿‡ä¼˜åŒ–é”¥åº¦å½¢çŠ¶ï¼Œè¿˜å¯ä»¥æé«˜è€¦åˆæ•ˆç‡ï¼ˆå‚è§ SOI é”¥åº¦è®¾è®¡ï¼‰ã€‚ é«˜æ•ˆå…‰æ …è€¦åˆå™¨ ï¼šä½¿ç”¨æ›´å¤æ‚çš„å…‰æ …å’Œæ··åˆçš„2-D/3-Dä¼˜åŒ–ç­–ç•¥ï¼Œä½¿ç”¨FDTDè®¾è®¡äº†åœ¨å¤§å¸¦å®½ä¸Šæ•ˆç‡é«˜äº90%çš„è€¦åˆå™¨ï¼ˆå‚è§å‚è€ƒæ–‡çŒ®ï¼‰ æ›´å¤šèµ„æº Additional documentation, examples, and training material Related publications R. Marchetti, C. Lacava, A. Khokhar, X. Chen, I. Cristiani, D. J. Richardson, G. T. Reed, P. Petropoulos and P. Minzioni, â€œHigh-efficiency grating-couplers: demonstration of a new design strategy,â€ Scientific Reports 7, Article number: 16670, 2017. (https://www.nature.com/articles/s41598-017-16505-z); Neil V. Sapra et.al, â€œInverse design and demonstration of broadband grating couplersâ€ IEEE Journal of Selected Topics in Quantum Electronics ( Volume: 25, Issue: 3, May-June 2019 ) D. Taillaert, F. Van Laere, M. Ayre, W. Bogaerts, D. Van Thourhout, P. Bienstman and R. Baets, â€œGrating Couplers for Coupling between Optical Fibers and Nanophotonic Waveguides,â€ Japanese Journal of Applied Physics, vol. 45, no. 8a, pp. 6071-6077, 2006. T. Watanabe, M. Ayata, U. Koch, Y. Fedoryshyn and J. Leuthold, â€œPerpendicular Grating Coupler Based on a Blazed Antiback-Reflection Structure,â€ Journal of Lightwave Technology, vol. 35, no. 21, pp. 4663- 4669, 2017. https://support.lumerical.com/hc/en-us/articles/360036618513)","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"Grating Coupler","slug":"Grating-Coupler","permalink":"http://example.com/tags/Grating-Coupler/"}]},{"title":"æœŸæœ«å¤ä¹ ","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°ç”µæœŸæœ«","date":"2022-06-13T08:45:55.278Z","updated":"2022-07-21T12:08:32.776Z","comments":true,"path":"2022/06/13/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°ç”µæœŸæœ«/","link":"","permalink":"http://example.com/2022/06/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E7%94%B5%E6%9C%9F%E6%9C%AB/","excerpt":"","text":"å¡«ç©ºé¢˜ é€‰æ‹©é¢˜ åˆ¤æ–­é¢˜ æ¦‚å¿µ è®¾è®¡é¢˜åˆ†æ ç»™å®šåŠŸèƒ½ ç¬¬ä¸€ç«  å¶æ•°ä¸ªå¼‚æˆ–è¾“å‡ºä¸º0 æ•°å­—é‡ ä¿¡å·é‡ é‡‡æ ·å®šç† äºŒè¿›ç¼–ç ; æ•°çš„åŸº; æ•°; æºç åç è¡¥ç ; æœ‰ç¬¦å·æ•°çš„è¡¥ç ; ç»™ä¸€ä¸ªæœ‰ç¬¦å·æ•°;æ­£æ•°çš„è¡¥ç å’Œè´Ÿæ•°çš„è¡¥ç æ˜¯ä»€ä¹ˆ; æ•´æ•°å’Œå°æ•°(å°æ•°çš„è§„åˆ™);0.5è½¬æ¢ä¸ºå°æ•°(äºŒè¿›); é€»è¾‘é—¨çš„è¾“å…¥å’Œè¾“å‡ºä»£è¡¨çš„ä¸æ˜¯ç»å¯¹å€¼;cmoså’Œttlçš„åŒºé—´;è¡¨è¾¾ä¸€ä¸ªæ³¢å½¢è®¾è®¡å‚æ•°,æœ‰å‘¨æœŸ,éå‘¨æœŸ,æŒ¯å¹…,å ç©ºæ¯”,ä¸Šå‡æ—¶é—´(å®šä¹‰:ç™¾åˆ†ä¹‹10åˆ°ç™¾åˆ†ä¹‹90);ä¸‹é™æ—¶é—´(å®šä¹‰);ä¸¤ä¸ªä¸­ä½ç‚¹ä½œä¸ºå®½åº¦ æ–¹æ³¢ä¸æ„å‘³ç€å‘¨æœŸ å ç©ºæ¯”çš„å®šä¹‰ æ—¶é’ŸåŒæ­¥çš„å®šä¹‰:å…¶ä»–ä¿¡å·ä»¥æ—¶é’Ÿä¿¡å·ä¸ºåŸºå‡† è¡¨è¾¾é€»è¾‘å…³ç³»: æ³¢å½¢å›¾ é€»è¾‘å‡½æ•°(é€»è¾‘æ–¹ç¨‹) é€»è¾‘å›¾ çœŸå€¼è¡¨ åŸºæœ¬é€»è¾‘æ“ä½œ:ä¸æˆ–é; é€šç”¨é—¨(ä¸éå’Œæˆ–é); å¼‚æˆ–åŒæˆ–(æ€§è´¨) å›ºå®šåŠŸèƒ½èŠ¯ç‰‡: åŠ æ³•å™¨;ç¼–ç å™¨;è¯‘ç å™¨;æ•°æ®é€‰æ‹©å™¨;æ•°æ®åˆ†é…å™¨;ç”Ÿæˆæ ¡éªŒç (å¥‡å¶æ ¡éªŒç ) æ•°æ®é€‰æ‹©å™¨å’Œè¯‘ç å™¨(?)å®ç°sop å¥‡å¶æ ¡éªŒçš„å®šä¹‰;é‡Œé¢ç”¨åˆ°çš„è¿ç®—;åŸç†;å¯èƒ½æ¯”è¾ƒæ–¹ä¾¿åœ°å®ç°ä¸€äº›åŠŸèƒ½; 11ç«  å¯ç¼–ç¨‹é€»è¾‘:å¦‚ä½•åˆ†ç±»(å¤æ‚çš„ç®€å•çš„);ç»“æ„;ä¸æˆ–è€…é adå˜æ¢éœ€è¦ä»€ä¹ˆ coms:2-2.3V, 0-0.8Væ­£é€»è¾‘è´Ÿé€»è¾‘ ä¸€èˆ¬ttlå’Œcomsä¸æ··èµ·æ¥,æœ‰ä¸€ä¸ªç‰¹æ®Šçš„comså¯ä»¥æ··èµ·æ¥ å…¨åŠ å™¨åŠåŠ å™¨çš„æ¦‚å¿µ åˆ†é…å™¨æ˜¯é‡ç”¨è¯‘ç å™¨(æŒæ¡) ç§»ä½å¯„å­˜å™¨,ç”¨é€”ä¸€,ç”¨é€”äºŒ ç¯å½¢èƒ½é…åˆè¯‘ç å™¨ è®¡æ•°å™¨çš„æ¨¡ è®¡æ•°å™¨æœ‰ä¸‰ä¸ªå¼‚æ­¥åŒæ­¥ èŠ¯ç‰‡è‡³å°‘æœ‰ä¸¤ä¸ªå¼•è„šæ¥åœ°å’Œç”µæº; SSI,MSI,VLSI,ULSI TTL,CMOS,BIMOS(TTL+CMOS) æ•°åŸº ä»»ä½•ä¸€ä¸ªåè¿›å°æ•°,èƒ½å¦è¡¨è¾¾ä¸ºä¸€ä¸ªç²¾ç¡®çš„äºŒè¿›åˆ¶å°æ•°,ä¸å¯èƒ½ BCDå¸¸ç”¨8421ç  äºŒè¿›æ•°è½¬æ¢åè¿›æ•°(é˜²æ­¢å‡ºé”™) æ ¼é›·ç äºŒè¿›ç è½¬æ¢ å¾·æ‘©æ ¹å¾‹ COMSé€»è¾‘ç±»å‹é‚£ä¸ªè¡¨","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"resource","slug":"ç¨‹è®¾/èµ„æº","date":"2022-06-10T11:26:45.673Z","updated":"2022-06-10T11:28:37.091Z","comments":true,"path":"2022/06/10/ç¨‹è®¾/èµ„æº/","link":"","permalink":"http://example.com/2022/06/10/%E7%A8%8B%E8%AE%BE/%E8%B5%84%E6%BA%90/","excerpt":"","text":"Description æ³¨æ„ï¼šä»¥ä¸‹ä¸–ç•Œè§‚å†…å®¹ä»¿åˆ¶ã€Šè¾å°„4ã€‹èƒŒæ™¯æ•…äº‹ï¼Œçº¯å±è™šæ„ï¼Œåˆ‡å‹¿å½“çœŸï¼ After the nuclear firestorm in year 2077, human civilization is on the verge of destruction, but new civilizations still exist on the old and glorious wreckage. Survivors started building underground Safehouse to avoid ground fallout and explore new living place. A Safehouse can not only provide rooms for surviving, but also store many necessary types of living Resource. åœ¨2077å¹´çš„æœ«ä¸–æµ©åŠ«â€œæ ¸ç«é£æš´â€ä¹‹åï¼Œäººç±»æ–‡æ˜æ¯ç­äº†ï¼Œä½†æ²¡æœ‰å®Œå…¨æ¯ç­ï¼Œæ–°çš„æ–‡æ˜ä¾ç„¶å­˜åœ¨äºæ—§æ—¥è¾‰ç…Œçš„æ®‹éª¸ä¹‹ä¸Šã€‚å¹¸å­˜è€…ä¸ºäº†èº²é¿åœ°é¢çš„è¾å°„ï¼Œæ‰¾åˆ°æ–°çš„ç”Ÿå­˜ç©ºé—´ï¼Œå¼€å§‹ä¿®å»ºèµ·åœ°ä¸‹é¿éš¾æ‰€ï¼ˆSafehouseï¼‰ã€‚åœ°ä¸‹é¿éš¾æ‰€ä¸ä»…ä»…èƒ½æä¾›äººä»¬å±…ä½çš„ç¯å¢ƒï¼Œè€Œä¸”è¿˜èƒ½å­˜å‚¨å„ç§å„æ ·çš„èµ„æºï¼ˆResourceï¼‰ã€‚ Guiding Assume that any kinds of Resource has its name and count in management. å‡è®¾åœ¨èµ„æºç®¡ç†çš„æ¦‚å¿µä¸­ï¼Œæ¯ä¸€ç§èµ„æºï¼ˆResourceï¼‰éƒ½æœ‰å¯¹åº”çš„åç§°ï¼ˆnameï¼‰ å’Œæ•°é‡ï¼ˆcountï¼‰ã€‚ 1234567struct Resource &#123; string name; int count; Resource(): name(&quot;&quot;), count(0) &#123;&#125; Resource(const string&amp; str, const int&amp; c): name(str), count(c) &#123;&#125;&#125;; And a Safehouse can be regarded as a place for storing these kinds of Resource. è€Œä¸€ä¸ªé¿éš¾æ‰€ï¼ˆSafehouseï¼‰å¯ä»¥è¢«è§†ä¸ºå­˜å‚¨è¿™äº›èµ„æºçš„åœ°æ–¹ã€‚ 12345678class Safehouse &#123;private: Resource* _owns; // A place for storing many types of resources. int _count_own_types; // How many types of resources has this Savehouse stored.public: // Some functions.&#125;; There are up to 16 kinds of Resource in the world, and a Safehouse may contain several kinds of them, each of which is of corresponding amount (or count). To manage the Resource in Safehouse, the regulator decided to use overloaded operator to express Resource changes, for instance, so here is the task for you: implement the operator overloading of class Safehouse, since you are the cleverest among all residents. è¿™ä¸ªä¸–ç•Œä¸Šæœ€å¤šä¸€å…±æœ‰16ç§èµ„æºï¼Œæ¯ä¸ªé¿éš¾æ‰€å¯èƒ½å­˜å‚¨å…¶ä¸­çš„å‡ ç§ï¼Œæ¯ä¸€ç§èµ„æºéƒ½æœ‰å…¶å¯¹åº”çš„æ•°é‡ã€‚ä¸ºäº†æ–¹ä¾¿ç®¡ç†é¿éš¾æ‰€çš„èµ„æºå­˜å‚¨ï¼Œé¿éš¾æ‰€ç›‘ç®¡è€…å†³å®šé‡‡ç”¨é‡è½½çš„è¿ç®—ç¬¦ï¼ˆoverloaded operatorï¼‰å½¢å¼æ¥è¡¨ç¤ºé¿éš¾æ‰€çš„èµ„æºå­˜å‚¨å˜åŒ–æ¦‚å†µã€‚ç°åœ¨è¯·ä½ â€”â€”é¿éš¾æ‰€é‡Œæœ€èªæ˜çš„å±…æ°‘ï¼Œæ¥å¸®åŠ©ä»–å®ç°é¿éš¾æ‰€çš„èµ„æºæ•°é‡è¿ç®—ã€‚ Details The Implementation of Resource struct is not needed, because it has been placed together with the announcement of class Safehouse in file \"Safehouse.h\". All you need to do is to realize some operator overloading functions of class Safehouse. ä½ ä¸éœ€è¦å®ç°ç”¨äºè¡¨ç¤ºèµ„æºçš„ç»“æ„ä½“ï¼Œå› ä¸ºå®ƒçš„å®šä¹‰å’Œé¿éš¾æ‰€ç±»çš„å£°æ˜éƒ½æ”¾åœ¨\"Safehouse.h\"å¤´æ–‡ä»¶ä¸­ã€‚ä½ åªéœ€è¦ä¸ºé¿éš¾æ‰€ç±»å®ç°å¦‚ä¸‹è¿™äº›è¿ç®—ç¬¦é‡è½½å³å¯ã€‚ 123456789101112131415161718192021222324252627282930// &quot;Copy&quot; all Resource from another Safehouse to current Safehouse.Safehouse&amp; operator = (const Safehouse&amp; another);// Add a kind of Resource to target Safehouse.// If the Resource type ALREADY exists in target Safehouse, just add on its existing count.// If the Resource type NOT exists in target Safehouse, add the new type totarget Safehouse with corresponding count.Safehouse operator + (const Resource&amp; new_resource); // Add all Resource existing in another Safehouse to target Safehouse.// You can call the overloaded version of &#x27;+ Resource&#x27; above for convenience.Safehouse operator + (const Safehouse&amp; another);// Similar to the overloading of &#x27;+ Resource&#x27;.Safehouse&amp; operator += (const Resource&amp; new_resource);// Similar to the overloading of &#x27;+ Safehouse&#x27;.Safehouse&amp; operator += (const Safehouse&amp; another);// Get the Resource object at designated index. You can assume that all input indexs are VALID!const Resource&amp; operator [] (const int&amp; index) const;// Compare current Safehouse with another Safehouse.// &quot;Safehouse1 &gt;= Safehouse2&quot; is satisfied, if and only if each of all Resource types existing in Safehouse2 also exists in Safehouse1.// Besides, as for a type of Resource, the corresponding amount in Safehouse1 must be NOT LESS THAN the corresponding amount in Safehouse2.// Otherwise, &quot;Safehouse1 &gt;= Safehouse2&quot; is NOT satisfied.bool operator &gt;= (const Safehouse&amp; another);// Print all existing Resource in target Safehouse.// The form of output is shown in Sample Output.friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Safehouse&amp; house); Hint Some useful functions of class Safehouse have been implemented. You can use them for simplifying your own codes, or just ignore them. åœ¨Safehouseç±»ä¸­å®ç°äº†ä¸€äº›å¯ä»¥ç›´æ¥è°ƒç”¨çš„å‡½æ•°ã€‚ä½ å¯ä»¥è°ƒç”¨å®ƒä»¬ä»¥ç®€åŒ–è‡ªå·±ä»£ç ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©æ— è§†å®ƒä»¬ã€‚ Sample Input 12345678910111213141516Oil 2Coal 4Gunpowder 3Leather 6Plastic 5Rubber 10Lewel 7Steel 14Iron 11Copper 22Zinc 13Wood 26Glass 17Fibre 34Grass 19Eletronic 38 Sample Output (Notice how to put a Safehouse object in ostream) 123456789101112131415161718192021222324252627282930After adding 2 Oil to house1 &gt;&gt;&gt;Oil: 2After adding 4 Coal to house1 &gt;&gt;&gt;Oil: 2Coal: 4After adding 3 Gunpowder to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3After adding 6 Leather to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3Leather: 6After adding 5 Plastic to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3Leather: 6Plastic: 5After adding 10 Rubber to house1 &gt;&gt;&gt;Oil: 2Coal: 4Gunpowder: 3Leather: 6 main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &quot;Safehouse.h&quot;/*Available resource types:- Oil- Coal- Gunpowder- Leather- Plastic- Rubber- Lewel- Steel- Iron- Copper- Zinc - Wood- Glass- Fibre- Grass- Electronic*/istream&amp; operator &gt;&gt; (istream&amp; is, Resource&amp; r) &#123; is &gt;&gt; r.name &gt;&gt; r.count; return is;&#125;int main() &#123; Safehouse house1; for(int i=0; i&lt;MAX_RESOURCE_TYPES; ++i) &#123; Resource new_resource; cin &gt;&gt; new_resource; house1 += new_resource; cout &lt;&lt; &quot;After adding &quot; &lt;&lt; new_resource.count &lt;&lt; &quot; &quot; &lt;&lt; new_resource.name &lt;&lt; &quot; to house1 &gt;&gt;&gt;&quot; &lt;&lt; endl; cout &lt;&lt; house1 &lt;&lt; endl; &#125; Safehouse house2; for(int i=0; i&lt;house1.GetCountOwnTypes()/2; ++i) &#123; house2 = house2 + house1[i*2]; cout &lt;&lt; &quot;After adding &quot; &lt;&lt; house1.GetOwnsCount(i*2) &lt;&lt; &quot; &quot; &lt;&lt; house1.GetOwnsName(i*2) &lt;&lt; &quot; to house2 &gt;&gt;&gt;&quot; &lt;&lt; endl; cout &lt;&lt; house2 &lt;&lt; endl; &#125; cout &lt;&lt; &quot;house2 &gt;= house1? : &quot; &lt;&lt; boolalpha &lt;&lt; (house2 &gt;= house1) &lt;&lt; endl; Safehouse house3; house3 = house1 + house3; house3 += house2; cout &lt;&lt; &quot;After adding house1 and house2 to house3 &gt;&gt;&gt;&quot; &lt;&lt; endl; cout &lt;&lt; house3 &lt;&lt; endl; cout &lt;&lt; &quot;house3 &gt;= house1? : &quot; &lt;&lt; boolalpha &lt;&lt; (house3 &gt;= house1) &lt;&lt; endl; Safehouse house4 = house3; house4 = house4; cout &lt;&lt; &quot;After initializing house4 with house3 &gt;&gt;&gt; &quot; &lt;&lt; endl; cout &lt;&lt; house4 &lt;&lt; endl; return 0;&#125; safehouse.h(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#ifndef __SAFEHOUSE__#define __SAFEHOUSE__#define MAX_RESOURCE_TYPES 16#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Resource &#123; string name; int count; Resource(): name(&quot;&quot;), count(0) &#123;&#125; Resource(const string&amp; str, const int&amp; c): name(str), count(c) &#123;&#125;&#125;;class Safehouse &#123; private: Resource* _owns; int _count_own_types; public: Safehouse(): _owns(new Resource[MAX_RESOURCE_TYPES]), _count_own_types(0) &#123;&#125; ~Safehouse() &#123;if(_owns) delete[] _owns;&#125; // Below are some supporting functions. // Copy constuctor for class Safehouse. Safehouse(const Safehouse&amp; another): _owns(new Resource[MAX_RESOURCE_TYPES]), _count_own_types(another._count_own_types) &#123; for(int i=0; i&lt;_count_own_types; ++i) &#123; _owns[i].name = another._owns[i].name; _owns[i].count = another._owns[i].count; &#125; &#125; // Return how many different types of Resource does this Safehouse contain. int GetCountOwnTypes() const &#123; return _count_own_types; &#125; // Get the Resource name on designated index. string GetOwnsName(const int&amp; index) const &#123; if(index &gt;= _count_own_types || index &lt; 0) &#123; return &quot;None&quot;; &#125; else &#123; return _owns[index].name; &#125; &#125; // Get the Resource count on designated index. int GetOwnsCount(const int&amp; index) const &#123; if(index &gt;= _count_own_types || index &lt; 0) &#123; return 0; &#125; else &#123; return _owns[index].count; &#125; &#125; // Find the first index of designated Resource type, return -1 if the designated Resource does not exist in Safehouse yet. int IndexOfResource(const string&amp; resource_name) const &#123; for(int i=0; i&lt;_count_own_types; ++i) &#123; if(_owns[i].name == resource_name) &#123; return i; &#125; &#125; return -1; &#125; // Find the count of designated Resource type, return 0 if the designated Resource does not exist in Safehouse yet. int CountOfResource(const string&amp; resource_name) const &#123; for(int i=0; i&lt;_count_own_types; ++i) &#123; if(_owns[i].name == resource_name) &#123; return _owns[i].count; &#125; &#125; return 0; &#125; // Your Implementation. Safehouse&amp; operator = (const Safehouse&amp; another); Safehouse operator + (const Resource&amp; new_resource); Safehouse operator + (const Safehouse&amp; another); Safehouse&amp; operator += (const Resource&amp; new_resource); Safehouse&amp; operator += (const Safehouse&amp; another); const Resource&amp; operator [] (const int&amp; index) const; bool operator &gt;= (const Safehouse&amp; target); friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Safehouse&amp; house); &#125;;#endif safehouse.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;Safehouse.h&gt;Safehouse&amp; Safehouse::operator = (const Safehouse&amp; another)&#123; if(&amp;another == this) return *this; _count_own_types=another._count_own_types; for(int i=0;i&lt;_count_own_types;i++)&#123; _owns[i]=another._owns[i]; &#125; return *this;&#125;// Add a kind of Resource to target Safehouse.// If the Resource type ALREADY exists in target Safehouse, just add on its existing count.// If the Resource type NOT exists in target Safehouse, add the new type totarget Safehouse with corresponding count.Safehouse Safehouse::operator + (const Resource&amp; n)&#123; Safehouse temp = (*this); if( temp.IndexOfResource(n.name) != -1)&#123; temp._owns[ IndexOfResource(n.name) ].count+=n.count; //æ•°é‡é—®é¢˜ &#125;else&#123; if(_count_own_types==16) return temp; temp._owns[_count_own_types]=n; temp._count_own_types++; &#125; return temp;&#125;// Add all Resource existing in another Safehouse to target Safehouse.// You can call the overloaded version of &#x27;+ Resource&#x27; above for convenience.Safehouse Safehouse::operator + (const Safehouse&amp; a)&#123; Safehouse temp=(*this); for(int i=0; i&lt;a._count_own_types;i++)&#123; temp = temp + a._owns[i]; &#125; return temp;&#125;// Similar to the overloading of &#x27;+ Resource&#x27;.Safehouse&amp; Safehouse::operator += (const Resource&amp; n)&#123; if( IndexOfResource(n.name) != -1)&#123; _owns[ IndexOfResource(n.name) ].count+=n.count; //æ•°é‡é—®é¢˜ &#125;else&#123; _owns[_count_own_types]=n; _count_own_types++; &#125; return *this;&#125;// Similar to the overloading of &#x27;+ Safehouse&#x27;.Safehouse&amp; Safehouse::operator += (const Safehouse&amp; a)&#123; (*this) = (*this) + a; return *this;&#125;// Get the Resource object at designated index. You can assume that all input indexs are VALID!const Resource&amp; Safehouse::operator [] (const int&amp; index) const&#123; return _owns[index];&#125;// Compare current Safehouse with another Safehouse.// &quot;Safehouse1 &gt;= Safehouse2&quot; is satisfied, if and only if each of all Resource types existing in Safehouse2 also exists in Safehouse1.// Besides, as for a type of Resource, the corresponding amount in Safehouse1 must be NOT LESS THAN the corresponding amount in Safehouse2.// Otherwise, &quot;Safehouse1 &gt;= Safehouse2&quot; is NOT satisfied.bool Safehouse::operator &gt;= (const Safehouse&amp; a)&#123; int i=0; for(;i&lt;a._count_own_types;i++)&#123; if( IndexOfResource( a._owns[i].name ) == -1 ) return false; if( CountOfResource( a._owns[i].name ) &lt; a.CountOfResource( a._owns[i].name ) ) return false; &#125; return true;&#125;// Print all existing Resource in target Safehouse.// The form of output is shown in Sample Output.ostream&amp; operator &lt;&lt; (ostream&amp; os, const Safehouse&amp; house)&#123; for(int i=0;i&lt;house._count_own_types;i++)&#123; os&lt;&lt;house._owns[i].name&lt;&lt;&quot;: &quot;&lt;&lt;house._owns[i].count&lt;&lt;endl; &#125; return os;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"æ•°å­—ç”µè·¯-Shift Registers","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°ç”µç¬¬ä¹ç« ","date":"2022-05-31T13:56:12.239Z","updated":"2022-05-31T15:04:51.298Z","comments":true,"path":"2022/05/31/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°ç”µç¬¬ä¹ç« /","link":"","permalink":"http://example.com/2022/05/31/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B9%9D%E7%AB%A0/","excerpt":"","text":"basic function and operations Shift Register Generator(SRG) ä¸²è¿›ä¸²å‡º(serial in serial out) ä¸²è¿›å¹¶å‡º(serial in parallel out) å¹¶è¿›ä¸²å‡º(parallel in parallel out) å¹¶è¿›å¹¶å‡º(parallel in parallel out) åŒå‘ç§»ä½å¯„å­˜å™¨ ç§»ä½å¯„å­˜è®¡æ•°å™¨(shift register counter) çº½ç¯è®¡æ•°å™¨(é‡ç‚¹) åˆå§‹çŠ¶æ€ä¸€å®šè¦ä¸º0000 ç¯å½¢è®¡æ•°å™¨(é‡ç‚¹) 10ä½ç¯å½¢è®¡æ•°å™¨çš„ç”µè·¯é€»è¾‘å›¾ï¼Œæ¨¡å¼=ä½æ•° â€¢æ¨¡æ•°æ˜¯ç›¸åŒä½æ•°çš„æ‰­ç¯è®¡æ•°å™¨çš„ä¸€åŠ â€¢å¦‚æœ\\(Q_0-Q_9\\)åªæœ‰ä¸€ä¸ªä¸º1ï¼Œå…¶ä½™ä¸º0ï¼ŒçŠ¶æ€ç”±1æ‰€åœ¨çš„ä½ç½® å†³å®šï¼Œæ— éœ€è¯‘ç  â€¢åˆå§‹çŠ¶æ€å¯ä»¥æ ¹æ®è¦æ±‚æ¥è®¾ç½® ç§»ä½å¯„å­˜å™¨åº”ç”¨ ç§»ä½å¯„å­˜å™¨åº”ç”¨ç¤ºä¾‹ï¼šå»¶æ—¶ç”µè·¯ åŸç†ï¼šè„‰å†²è¾“å…¥å¯„å­˜å™¨ï¼Œæ¯æ‹ç§»åŠ¨ä¸€ä½ï¼Œç»è¿‡næ‹åè¾“å‡ºï¼Œnä½ å¯„å­˜å™¨å»¶è¿Ÿnæ‹ å»¶æ—¶ç”µè·¯ç¤ºä¾‹ï¼š8ä½å…±å»¶è¿Ÿ8æ‹ï¼Œæ¯æ‹1/500k=2usï¼Œå»¶ æ—¶2*8=16us ç§»ä½å¯„å­˜å™¨åº”ç”¨ç¤ºä¾‹ï¼šä»¥74HC195æ„æˆç¯å½¢è®¡æ•°å™¨ æ–¹æ³•ï¼š\\(Q_3\\)ä½œä¸ºè¾“å…¥ï¼Œ\\(Q_0~Q_3\\)åˆå§‹çŠ¶æ€ä¸ºï¼š1000 ç§»ä½å¯„å­˜å™¨åº”ç”¨ç¤ºä¾‹ï¼šæ•°æ®çš„ä¸²è¡Œ-å¹¶è¡Œè½¬æ¢ç”µè·¯ æ•°æ®çš„ä¸²è¡Œè¾“å…¥æ ¼å¼ï¼š0å¼€å§‹ï¼Œ8ä½æ•°æ®ï¼Œ1ç»“æŸ é€šç”¨å¼‚æ­¥æ”¶å‘å™¨ï¼ˆUARTï¼‰ï¼šæ•°æ®çš„ä¸²-å¹¶ã€å¹¶-ä¸²è½¬æ¢ é€»è¾‘ç¬¦å· 8ä½ç§»ä½å¯„å­˜å™¨74HC164çš„å…³è”æ ‡æ³¨é€»è¾‘ç¬¦å· â€¢å…±ç”¨æ§åˆ¶å—ï¼šä¸Šæ–¹å¸¦å‡¹æ§½çš„æ–¹æ¡† â€¢ç‹¬ç«‹å…ƒä»¶ï¼šä¸‹æ–¹çš„8ä¸ªæ–¹æ¡† â€¢é™åˆ¶ç¬¦å·ï¼šSRG 8ï¼Œè¡¨è¾¾8ä½ç§»ä½å¯„å­˜å™¨ â€¢å…³è”ç¬¦å·ï¼šCï¼šæ§åˆ¶ï¼ŒRï¼šæ¸…é›¶ï¼ˆResetï¼‰ï¼Œç®­å·ï¼šç§»ä½ 4ä½åŒå‘ç§»ä½å¯„å­˜å™¨74HC194çš„å…³è”æ ‡æ³¨é€»è¾‘ç¬¦å· â€¢å…±ç”¨æ§åˆ¶å—ï¼šä¸Šæ–¹å¸¦å‡¹æ§½çš„æ–¹æ¡† â€¢ç‹¬ç«‹å…ƒä»¶ï¼šä¸‹æ–¹çš„4ä¸ªæ–¹æ¡† â€¢é™åˆ¶ç¬¦å·ï¼šSRG 4ï¼Œè¡¨è¾¾4ä½ç§»ä½å¯„å­˜å™¨ â€¢å…³è”ç¬¦å·ï¼šCï¼šæ§åˆ¶ï¼ŒMï¼šæ¨¡å¼ï¼ŒRï¼šæ¸…é›¶ï¼ˆResetï¼‰ï¼Œç®­å·ï¼šç§»ä½ éœ€æŒæ¡çš„é‡ç‚¹","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"é€‰æ•°(dfs)","slug":"ç¨‹è®¾/é€‰æ•°(dfs)","date":"2022-05-31T12:15:03.170Z","updated":"2022-05-31T12:16:59.372Z","comments":true,"path":"2022/05/31/ç¨‹è®¾/é€‰æ•°(dfs)/","link":"","permalink":"http://example.com/2022/05/31/%E7%A8%8B%E8%AE%BE/%E9%80%89%E6%95%B0(dfs)/","excerpt":"","text":"[NOIP2002 æ™®åŠç»„] é€‰æ•° é¢˜ç›®æè¿° å·²çŸ¥ \\(n\\) ä¸ªæ•´æ•° \\(x_1,x_2,\\cdots,x_n\\)ï¼Œä»¥åŠ \\(1\\) ä¸ªæ•´æ•° \\(k\\)ï¼ˆ\\(k&lt;n\\)ï¼‰ã€‚ä» \\(n\\) ä¸ªæ•´æ•°ä¸­ä»»é€‰ \\(k\\) ä¸ªæ•´æ•°ç›¸åŠ ï¼Œå¯åˆ†åˆ«å¾—åˆ°ä¸€ç³»åˆ—çš„å’Œã€‚ä¾‹å¦‚å½“ \\(n=4\\)ï¼Œ\\(k=3\\)ï¼Œ\\(4\\) ä¸ªæ•´æ•°åˆ†åˆ«ä¸º \\(3,7,12,19\\) æ—¶ï¼Œå¯å¾—å…¨éƒ¨çš„ç»„åˆä¸å®ƒä»¬çš„å’Œä¸ºï¼š \\(3+7+12=22\\) \\(3+7+19=29\\) \\(7+12+19=38\\) \\(3+12+19=34\\) ç°åœ¨ï¼Œè¦æ±‚ä½ è®¡ç®—å‡ºå’Œä¸ºç´ æ•°å…±æœ‰å¤šå°‘ç§ã€‚ ä¾‹å¦‚ä¸Šä¾‹ï¼Œåªæœ‰ä¸€ç§çš„å’Œä¸ºç´ æ•°ï¼š\\(3+7+19=29\\)ã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œä¸¤ä¸ªç©ºæ ¼éš”å¼€çš„æ•´æ•° \\(n,k\\)ï¼ˆ\\(1 \\le n \\le 20\\)ï¼Œ\\(k&lt;n\\)ï¼‰ã€‚ ç¬¬äºŒè¡Œ \\(n\\) ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«ä¸º \\(x_1,x_2,\\cdots,x_n\\)ï¼ˆ\\(1 \\le x_i \\le 5\\times 10^6\\)ï¼‰ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç§ç±»æ•°ã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 124 33 7 12 19 æ ·ä¾‹è¾“å‡º #1 11 æç¤º ã€é¢˜ç›®æ¥æºã€‘ NOIP 2002 æ™®åŠç»„ç¬¬äºŒé¢˜ æäº¤ä»£ç  123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; using namespace std; int n, k, x[21]=&#123;0&#125;;int sum=0, ans=0;bool judge(int t)&#123; if(t==2) return true; for(int i=2;i&lt;t/2;i++)&#123; if(t%i==0) return false; &#125; return true; &#125; void dfs(int count, int pos)&#123; if(count &gt; k)&#123; if(judge(sum))&#123; ans++; &#125; return; &#125; else&#123; for(int i=pos+1;i&lt;=n;i++)&#123; sum += x[i]; dfs(count+1, i); sum -= x[i]; &#125; &#125; &#125; int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i=1;i&lt;=n;i++) cin &gt;&gt; x[i]; dfs(1,0); cout &lt;&lt; ans; return 0; &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"æ¡¶æ’åº","slug":"ç¨‹è®¾/æ¡¶æ’åº","date":"2022-05-31T11:56:00.612Z","updated":"2022-05-31T11:59:17.077Z","comments":true,"path":"2022/05/31/ç¨‹è®¾/æ¡¶æ’åº/","link":"","permalink":"http://example.com/2022/05/31/%E7%A8%8B%E8%AE%BE/%E6%A1%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"ã€æ·±åŸº9.ä¾‹1ã€‘é€‰ä¸¾å­¦ç”Ÿä¼š é¢˜ç›®æè¿° å­¦æ ¡æ­£åœ¨é€‰ä¸¾å­¦ç”Ÿä¼šæˆå‘˜ï¼Œæœ‰ \\(n(n\\le 999)\\) åå€™é€‰äººï¼Œæ¯åå€™é€‰äººç¼–å·åˆ†åˆ«ä» 1 åˆ° \\(n\\)ï¼Œç°åœ¨æ”¶é›†åˆ°äº† \\(m(m&lt;=2000000)\\) å¼ é€‰ç¥¨ï¼Œæ¯å¼ é€‰ç¥¨éƒ½å†™äº†ä¸€ä¸ªå€™é€‰äººç¼–å·ã€‚ç°åœ¨æƒ³æŠŠè¿™äº›å †ç§¯å¦‚å±±çš„é€‰ç¥¨æŒ‰ç…§æŠ•ç¥¨æ•°å­—ä»å°åˆ°å¤§æ’åºã€‚ è¾“å…¥æ ¼å¼ è¾“å…¥ \\(n\\) å’Œ \\(m\\) ä»¥åŠ \\(m\\) ä¸ªé€‰ç¥¨ä¸Šçš„æ•°å­—ã€‚ è¾“å‡ºæ ¼å¼ æ±‚å‡ºæ’åºåçš„é€‰ç¥¨ç¼–å·ã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 125 102 5 2 2 5 2 2 2 1 2 æ ·ä¾‹è¾“å‡º #1 11 2 2 2 2 2 2 2 5 5 å‡½æ•°æ˜ å°„å…³ç³» 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int a,n,m,b[1000];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)cin&gt;&gt;a,++b[a]; //è®°å½•ç¥¨å‡ºç°çš„æ¬¡æ•° for(int i=0;i&lt;1000;i++)while(b[i]--)cout&lt;&lt;i&lt;&lt;&quot; &quot;; //æ ¹æ®ç¥¨å‡ºç°çš„æ¬¡æ•°è¾“å‡º return 0;&#125; å‚è€ƒã€ç®—æ³•ã€‘æ’åºç®—æ³•ä¹‹æ¡¶æ’åº - çŸ¥ä¹ (zhihu.com) å‡è®¾æ•°æ®åˆ†å¸ƒåœ¨[0ï¼Œ100)ä¹‹é—´ï¼Œæ¯ä¸ªæ¡¶å†…éƒ¨ç”¨é“¾è¡¨è¡¨ç¤ºï¼Œåœ¨æ•°æ®å…¥æ¡¶çš„åŒæ—¶æ’å…¥æ’åºã€‚ç„¶åæŠŠå„ä¸ªæ¡¶ä¸­çš„æ•°æ®åˆå¹¶ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iterator&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int BUCKET_NUM = 10;struct ListNode&#123; explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125; ListNode* mNext; int mData;&#125;;ListNode* insert(ListNode* head,int val)&#123; ListNode dummyNode; ListNode *newNode = new ListNode(val); ListNode *pre,*curr; dummyNode.mNext = head; pre = &amp;dummyNode; curr = head; while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123; pre = curr; curr = curr-&gt;mNext; &#125; newNode-&gt;mNext = curr; pre-&gt;mNext = newNode; return dummyNode.mNext;&#125;ListNode* Merge(ListNode *head1,ListNode *head2)&#123; ListNode dummyNode; ListNode *dummy = &amp;dummyNode; while(NULL!=head1 &amp;&amp; NULL!=head2)&#123; if(head1-&gt;mData &lt;= head2-&gt;mData)&#123; dummy-&gt;mNext = head1; head1 = head1-&gt;mNext; &#125;else&#123; dummy-&gt;mNext = head2; head2 = head2-&gt;mNext; &#125; dummy = dummy-&gt;mNext; &#125; if(NULL!=head1) dummy-&gt;mNext = head1; if(NULL!=head2) dummy-&gt;mNext = head2; return dummyNode.mNext;&#125;void BucketSort(int n,int arr[])&#123; vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0)); for(int i=0;i&lt;n;++i)&#123; int index = arr[i]/BUCKET_NUM; ListNode *head = buckets.at(index); buckets.at(index) = insert(head,arr[i]); &#125; ListNode *head = buckets.at(0); for(int i=1;i&lt;BUCKET_NUM;++i)&#123; head = Merge(head,buckets.at(i)); &#125; for(int i=0;i&lt;n;++i)&#123; arr[i] = head-&gt;mData; head = head-&gt;mNext; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"dfs","slug":"ç¨‹è®¾/dfs","date":"2022-05-31T07:21:41.520Z","updated":"2022-05-31T07:22:30.257Z","comments":true,"path":"2022/05/31/ç¨‹è®¾/dfs/","link":"","permalink":"http://example.com/2022/05/31/%E7%A8%8B%E8%AE%BE/dfs/","excerpt":"","text":"[NOIP2002 æ™®åŠç»„] é€‰æ•° é¢˜ç›®æè¿° å·²çŸ¥ \\(n\\) ä¸ªæ•´æ•° \\(x_1,x_2,\\cdots,x_n\\)ï¼Œä»¥åŠ \\(1\\) ä¸ªæ•´æ•° \\(k\\)ï¼ˆ\\(k&lt;n\\)ï¼‰ã€‚ä» \\(n\\) ä¸ªæ•´æ•°ä¸­ä»»é€‰ \\(k\\) ä¸ªæ•´æ•°ç›¸åŠ ï¼Œå¯åˆ†åˆ«å¾—åˆ°ä¸€ç³»åˆ—çš„å’Œã€‚ä¾‹å¦‚å½“ \\(n=4\\)ï¼Œ\\(k=3\\)ï¼Œ\\(4\\) ä¸ªæ•´æ•°åˆ†åˆ«ä¸º \\(3,7,12,19\\) æ—¶ï¼Œå¯å¾—å…¨éƒ¨çš„ç»„åˆä¸å®ƒä»¬çš„å’Œä¸ºï¼š \\(3+7+12=22\\) \\(3+7+19=29\\) \\(7+12+19=38\\) \\(3+12+19=34\\) ç°åœ¨ï¼Œè¦æ±‚ä½ è®¡ç®—å‡ºå’Œä¸ºç´ æ•°å…±æœ‰å¤šå°‘ç§ã€‚ ä¾‹å¦‚ä¸Šä¾‹ï¼Œåªæœ‰ä¸€ç§çš„å’Œä¸ºç´ æ•°ï¼š\\(3+7+19=29\\)ã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œä¸¤ä¸ªç©ºæ ¼éš”å¼€çš„æ•´æ•° \\(n,k\\)ï¼ˆ\\(1 \\le n \\le 20\\)ï¼Œ\\(k&lt;n\\)ï¼‰ã€‚ ç¬¬äºŒè¡Œ \\(n\\) ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«ä¸º \\(x_1,x_2,\\cdots,x_n\\)ï¼ˆ\\(1 \\le x_i \\le 5\\times 10^6\\)ï¼‰ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç§ç±»æ•°ã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 124 33 7 12 19 æ ·ä¾‹è¾“å‡º #1 11 æç¤º ã€é¢˜ç›®æ¥æºã€‘ NOIP 2002 æ™®åŠç»„ç¬¬äºŒé¢˜ 1234567891011121314151617181920212223242526272829303132333435361 #include &lt;iostream&gt; 2 using namespace std; 3 4 int n, k, x[21]=&#123;0&#125;; 5 int sum=0, ans=0; 6 7 bool judge(int t)&#123; #åˆ¤æ–­æ˜¯å¦æ˜¯ç´ æ•° 8 if(t==2) return true; 9 for(int i=2;i&lt;t/2;i++)&#123;10 if(t%i==0) return false;11 &#125;12 return true;13 &#125;14 15 void dfs(int count, int pos)&#123; #countæ˜¯å½“å‰æœ‰å‡ ä¸ªæ•°è¢«è®¡ç®—äº†ï¼Œposæ˜¯ä»–ä»¬çš„ä½ç½®16 if(count &gt; k)&#123;17 if(judge(sum))&#123;18 ans++;19 &#125;20 return; #å›æº¯21 &#125;22 else&#123;23 for(int i=pos+1;i&lt;=n;i++)&#123;24 sum += x[i];25 dfs(count+1, i);26 sum -= x[i];27 &#125;28 &#125;29 &#125;30 31 int main()&#123;32 cin &gt;&gt; n &gt;&gt; k;33 for(int i=1;i&lt;=n;i++) cin &gt;&gt; x[i];34 dfs(1,0);35 cout &lt;&lt; ans;36 return 0;37 &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"æ¨¡æ‹Ÿ","slug":"ç¨‹è®¾/ç«æ˜Ÿäºº","date":"2022-05-29T13:28:42.432Z","updated":"2022-05-29T13:35:28.543Z","comments":true,"path":"2022/05/29/ç¨‹è®¾/ç«æ˜Ÿäºº/","link":"","permalink":"http://example.com/2022/05/29/%E7%A8%8B%E8%AE%BE/%E7%81%AB%E6%98%9F%E4%BA%BA/","excerpt":"","text":"ç«æ˜Ÿäºº é¢˜ç›®æè¿° äººç±»ç»ˆäºç™»ä¸Šäº†ç«æ˜Ÿçš„åœŸåœ°å¹¶ä¸”è§åˆ°äº†ç¥ç§˜çš„ç«æ˜Ÿäººã€‚äººç±»å’Œç«æ˜Ÿäººéƒ½æ— æ³•ç†è§£å¯¹æ–¹çš„è¯­è¨€ï¼Œä½†æ˜¯æˆ‘ä»¬çš„ç§‘å­¦å®¶å‘æ˜äº†ä¸€ç§ç”¨æ•°å­—äº¤æµçš„æ–¹æ³•ã€‚è¿™ç§äº¤æµæ–¹æ³•æ˜¯è¿™æ ·çš„ï¼Œé¦–å…ˆï¼Œç«æ˜ŸäººæŠŠä¸€ä¸ªéå¸¸å¤§çš„æ•°å­—å‘Šè¯‰äººç±»ç§‘å­¦å®¶ï¼Œç§‘å­¦å®¶ç ´è§£è¿™ä¸ªæ•°å­—çš„å«ä¹‰åï¼Œå†æŠŠä¸€ä¸ªå¾ˆå°çš„æ•°å­—åŠ åˆ°è¿™ä¸ªå¤§æ•°ä¸Šé¢ï¼ŒæŠŠç»“æœå‘Šè¯‰ç«æ˜Ÿäººï¼Œä½œä¸ºäººç±»çš„å›ç­”ã€‚ ç«æ˜Ÿäººç”¨ä¸€ç§éå¸¸ç®€å•çš„æ–¹å¼æ¥è¡¨ç¤ºæ•°å­—â€•â€•æ°æ‰‹æŒ‡ã€‚ç«æ˜Ÿäººåªæœ‰ä¸€åªæ‰‹ï¼Œä½†è¿™åªæ‰‹ä¸Šæœ‰æˆåƒä¸Šä¸‡çš„æ‰‹æŒ‡ï¼Œè¿™äº›æ‰‹æŒ‡æ’æˆä¸€åˆ—ï¼Œåˆ†åˆ«ç¼–å·ä¸º \\(1,2,3,\\cdots\\)ã€‚ç«æ˜Ÿäººçš„ä»»æ„ä¸¤æ ¹æ‰‹æŒ‡éƒ½èƒ½éšæ„äº¤æ¢ä½ç½®ï¼Œä»–ä»¬å°±æ˜¯é€šè¿‡è¿™æ–¹æ³•è®¡æ•°çš„ã€‚ ä¸€ä¸ªç«æ˜Ÿäººç”¨ä¸€ä¸ªäººç±»çš„æ‰‹æ¼”ç¤ºäº†å¦‚ä½•ç”¨æ‰‹æŒ‡è®¡æ•°ã€‚å¦‚æœæŠŠäº”æ ¹æ‰‹æŒ‡â€•â€•æ‹‡æŒ‡ã€é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡å’Œå°æŒ‡åˆ†åˆ«ç¼–å·ä¸º \\(1,2,3,4\\) å’Œ \\(5\\)ï¼Œå½“å®ƒä»¬æŒ‰æ­£å¸¸é¡ºåºæ’åˆ—æ—¶ï¼Œå½¢æˆäº† \\(5\\) ä½æ•° \\(12345\\)ï¼Œå½“ä½ äº¤æ¢æ— åæŒ‡å’Œå°æŒ‡çš„ä½ç½®æ—¶ï¼Œä¼šå½¢æˆ \\(5\\) ä½æ•° \\(12354\\)ï¼Œå½“ä½ æŠŠäº”ä¸ªæ‰‹æŒ‡çš„é¡ºåºå®Œå…¨é¢ å€’æ—¶ï¼Œä¼šå½¢æˆ \\(54321\\)ï¼Œåœ¨æ‰€æœ‰èƒ½å¤Ÿå½¢æˆçš„ \\(120\\) ä¸ª \\(5\\) ä½æ•°ä¸­ï¼Œ\\(12345\\) æœ€å°ï¼Œå®ƒè¡¨ç¤º \\(1\\)ï¼›\\(12354\\) ç¬¬äºŒå°ï¼Œå®ƒè¡¨ç¤º \\(2\\)ï¼›\\(54321\\) æœ€å¤§ï¼Œå®ƒè¡¨ç¤º \\(120\\)ã€‚ä¸‹è¡¨å±•ç¤ºäº†åªæœ‰ \\(3\\) æ ¹æ‰‹æŒ‡æ—¶èƒ½å¤Ÿå½¢æˆçš„ \\(6\\) ä¸ª \\(3\\) ä½æ•°å’Œå®ƒä»¬ä»£è¡¨çš„æ•°å­—ï¼š ä¸‰è¿›åˆ¶æ•° ä»£è¡¨çš„æ•°å­— \\(123\\) \\(1\\) \\(132\\) \\(2\\) \\(213\\) \\(3\\) \\(231\\) \\(4\\) \\(312\\) \\(5\\) \\(321\\) \\(6\\) ç°åœ¨ä½ æœ‰å¹¸æˆä¸ºäº†ç¬¬ä¸€ä¸ªå’Œç«æ˜Ÿäººäº¤æµçš„åœ°çƒäººã€‚ä¸€ä¸ªç«æ˜Ÿäººä¼šè®©ä½ çœ‹ä»–çš„æ‰‹æŒ‡ï¼Œç§‘å­¦å®¶ä¼šå‘Šè¯‰ä½ è¦åŠ ä¸Šå»çš„å¾ˆå°çš„æ•°ã€‚ä½ çš„ä»»åŠ¡æ˜¯ï¼ŒæŠŠç«æ˜Ÿäººç”¨æ‰‹æŒ‡è¡¨ç¤ºçš„æ•°ä¸ç§‘å­¦å®¶å‘Šè¯‰ä½ çš„æ•°ç›¸åŠ ï¼Œå¹¶æ ¹æ®ç›¸åŠ çš„ç»“æœæ”¹å˜ç«æ˜Ÿäººæ‰‹æŒ‡çš„æ’åˆ—é¡ºåºã€‚è¾“å…¥æ•°æ®ä¿è¯è¿™ä¸ªç»“æœä¸ä¼šè¶…å‡ºç«æ˜Ÿäººæ‰‹æŒ‡èƒ½è¡¨ç¤ºçš„èŒƒå›´ã€‚ è¾“å…¥æ ¼å¼ å…±ä¸‰è¡Œã€‚ ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•° \\(N\\)ï¼Œè¡¨ç¤ºç«æ˜Ÿäººæ‰‹æŒ‡çš„æ•°ç›®ï¼ˆ\\(1 \\le N \\le 10000\\)ï¼‰ã€‚ ç¬¬äºŒè¡Œæ˜¯ä¸€ä¸ªæ­£æ•´æ•° \\(M\\)ï¼Œè¡¨ç¤ºè¦åŠ ä¸Šå»çš„å°æ•´æ•°ï¼ˆ\\(1 \\le M \\le 100\\)ï¼‰ã€‚ ä¸‹ä¸€è¡Œæ˜¯ \\(1\\) åˆ° \\(N\\) è¿™ \\(N\\) ä¸ªæ•´æ•°çš„ä¸€ä¸ªæ’åˆ—ï¼Œç”¨ç©ºæ ¼éš”å¼€ï¼Œè¡¨ç¤ºç«æ˜Ÿäººæ‰‹æŒ‡çš„æ’åˆ—é¡ºåºã€‚ è¾“å‡ºæ ¼å¼ \\(N\\) ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ”¹å˜åçš„ç«æ˜Ÿäººæ‰‹æŒ‡çš„æ’åˆ—é¡ºåºã€‚æ¯ä¸¤ä¸ªç›¸é‚»çš„æ•°ä¸­é—´ç”¨ä¸€ä¸ªç©ºæ ¼åˆ†å¼€ï¼Œä¸èƒ½æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 123531 2 3 4 5 æ ·ä¾‹è¾“å‡º #1 11 2 4 5 3 æç¤º å¯¹äº \\(30\\%\\) çš„æ•°æ®ï¼Œ\\(N \\le 15\\)ã€‚ å¯¹äº \\(60\\%\\) çš„æ•°æ®ï¼Œ\\(N \\le 50\\)ã€‚ å¯¹äº \\(100\\%\\) çš„æ•°æ®ï¼Œ\\(N \\le 10000\\)ã€‚ é¢˜è§£ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int b[10000+1]; int i,j,k,m,n,t;void init()&#123; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) cin&gt;&gt;b[i];&#125;void out()&#123; for(i=1;i&lt;=n-1;i++) cout&lt;&lt;b[i]&lt;&lt;&#x27; &#x27;; cout&lt;&lt;b[n]&lt;&lt;endl;&#125;void work()&#123; for(i=1;i&lt;=m;i++)//å¢1 å…±Mæ¬¡ &#123; for(j=n-1;j&gt;=1;j--)//æ‰¾åˆ°æœ€åå¯å¢åŠ çš„ä½ï¼Œå³å®šä½ if(b[j]&lt;b[j+1])//ä¾‹å¦‚12354åŠ 1ï¼Œåˆ™åªæœ‰3å¯å¢åŠ ä½æ•° break; for(k=n;k&gt;=1;k--)//æ‰¾åˆ°æœ€å°å¯å¢åŠ çš„æ•°å­— if(b[k]&gt;b[j])//ä¾‹å¦‚12354åŠ 1ï¼Œæœ€å°å¯å¢åŠ çš„æ•°å­—æ˜¯4 break; t=b[j];//äº¤æ¢ï¼ŒæŠŠåŸæ’åˆ—å¢å¤§ ï¼Œ b[j]=b[k];//ä¾‹å¦‚12354åŠ 1ï¼Œå³3å’Œ4äº¤æ¢ï¼Œäº¤æ¢ç»“æœä¸º12453 b[k]=t; //ä½†12453å¹¶ä¸æ˜¯æœ€ç»ˆç»“æœï¼Œè€Œæ˜¯12435å³è¦æ’åº j=j+1;//å‘åç§»ä¸€ä½ k=n; while((j&lt;k))//æŠŠåé¢çš„é€†åºï¼Œç›¸å½“äºä»å°åˆ°å¤§æ’åº &#123; t=b[j]; b[j]=b[k]; b[k]=t; j++; k--; &#125; &#125;&#125;int main()&#123; init(); work(); out(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template and stack","slug":"ç¨‹è®¾/template and stack","date":"2022-05-26T14:26:09.818Z","updated":"2022-06-01T07:15:30.791Z","comments":true,"path":"2022/05/26/ç¨‹è®¾/template and stack/","link":"","permalink":"http://example.com/2022/05/26/%E7%A8%8B%E8%AE%BE/template%20and%20stack/","excerpt":"","text":"é˜Ÿåˆ—æ¨¡æ‹Ÿæ ˆ Description In this assignment, you need to complete Class Stack's declaration and definition with templates. The different thing is that the Stack is implemented by two queues. Following is the example of Stack in integer: 1234567891011121314class Stack &#123; public: Stack(); // constructor. void push(const int&amp; data); // push operation. int pop(); // return the value in the top and pop it out of the stack. int top(); // return the value in top. int size() const; // return size of the stack. bool empty(); // check whether is empty. private: queue&lt;int&gt; q1; // two queues. queue&lt;int&gt; q2; int count; // the number of elements.&#125;; And you need to define a print function to print the content in the Stack from top to bottom. The format is: every element is followed by a blank space and an endl in the end. Hint You are not allowed to use any STL except queue. For more detail, see the codes in main.cpp. å‡ºé¢˜äººï¼šé»æ´‹ main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;Stack.h&quot;#include&lt;iostream&gt;#include&lt;exception&gt;using namespace std;class StackForbidden : public exception &#123; virtual const char *what() const throw() &#123; return &quot;Please do not use Stack in stl..&quot;; &#125;&#125;;void test1()&#123; Stack&lt;int&gt; stack; stack.push(88); stack.push(44); stack.push(99); cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack.size() &lt;&lt; endl; if (!stack.empty()) cout &lt;&lt; stack.top() &lt;&lt; endl; print(stack); stack.pop(); print(stack); stack.push(777); cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack.size() &lt;&lt; endl; if (!stack.empty()) cout &lt;&lt; stack.top() &lt;&lt; endl; print(stack); stack.pop(); stack.pop(); cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack.size() &lt;&lt; endl; print(stack); stack.pop(); if (!stack.empty()) cout &lt;&lt; stack.top() &lt;&lt; endl; else cout &lt;&lt; &quot;it is empty now.&quot; &lt;&lt; endl;&#125;void test2()&#123; Stack&lt;double&gt; stack1; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; stack1.push(i + 0.01); &#125; print(stack1); while (m--) &#123; stack1.pop(); &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; stack1.size() &lt;&lt; endl; if (!stack1.empty()) cout &lt;&lt; stack1.top() &lt;&lt; endl; print(stack1);&#125;int main() &#123; #if defined(_GLIBCXX_STACK) throw StackForbidden(); #endif test1(); test2();&#125; stack.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;template&lt;typename T&gt;class Stack &#123; public: Stack()&#123; count = 0; &#125; // constructor. void push(const T&amp; data)&#123; q1.push(data); ++count; &#125; // push operation. T pop()&#123; while(!q2.empty()) q2.pop(); if(count)&#123; --count; for(int i = 0; i &lt; count; ++i)&#123; q2.push(q1.front()); q1.pop(); &#125; swap(q1, q2); &#125; return q1.front(); &#125; // return the value in the top and pop it out of the stack. T top()&#123; return q1.back(); &#125; // return the value in top. int size() const&#123; return count; &#125; // return size of the stack. bool empty()&#123; return count == 0; &#125;// check whether is empty. //friend void print(Stack&lt;TT&gt;&amp; s); private: queue&lt;T&gt; q1; // two queues. queue&lt;T&gt; q2; int count; // the number of elements.&#125;;template&lt;class TT&gt;void print(Stack&lt;TT&gt; queue) &#123; while (!queue.empty()) &#123; cout &lt;&lt; queue.top() &lt;&lt; &quot; &quot;; queue.pop(); &#125; cout &lt;&lt; endl;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;template&lt;typename T&gt;class Stack &#123; public: Stack(); void push(const T&amp; data); T pop(); T top(); int size() const; bool empty(); private: queue&lt;T&gt; q1; queue&lt;T&gt; q2; int count;&#125;;template&lt;typename T&gt;Stack&lt;T&gt;::Stack() &#123; count = 0;&#125;template&lt;typename T&gt;int Stack&lt;T&gt;::size() const &#123; return count;&#125;template&lt;typename T&gt;bool Stack&lt;T&gt;::empty() &#123; return count == 0;&#125;template&lt;typename T&gt;void Stack&lt;T&gt;::push(const T&amp; data) &#123; if (q1.empty() &amp;&amp; q2.empty()) &#123; q1.push(data); &#125; else &#123; if (!q1.empty()) q1.push(data); else q2.push(data); &#125; count++;&#125;template&lt;typename T&gt;T Stack&lt;T&gt;::top() &#123; if (!q1.empty()) return q1.back(); return q2.back();&#125;template&lt;typename T&gt;T Stack&lt;T&gt;::pop() &#123; T value; if (!empty()) &#123; if (q1.empty()) &#123; while (q2.size() &gt;= 2) &#123; q1.push(q2.front()); q2.pop(); &#125; value = q2.front(); q2.pop(); &#125; else &#123; while (q1.size() &gt;= 2) &#123; q2.push(q1.front()); q1.pop(); &#125; value = q1.front(); q1.pop(); &#125; count--; &#125; return value;&#125;template&lt;typename T&gt;void print(Stack&lt;T&gt; stack) &#123; while (!stack.empty()) &#123; cout &lt;&lt; stack.top() &lt;&lt; &quot; &quot;; stack.pop(); &#125; cout &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Stack &#123; public: Stack()&#123; count = 0; &#125; // constructor. void push(const T&amp; data)&#123; q2.push(data); while(!q1.empty())&#123; q2.push(q1.front()); q1.pop(); &#125; swap(q1,q2); &#125; // push operation. T pop()&#123; T r = q1.front(); q1.pop(); return r; &#125; // return the value in the top and pop it out of the stack. T top()&#123; return q1.front(); &#125; // return the value in top. int size() const&#123; return count; &#125; // return size of the stack. bool empty()&#123; return q1.empty(); &#125; // check whether is empty. private: queue&lt;T&gt; q1; // two queues. queue&lt;T&gt; q2; int count; // the number of elements.&#125;;template &lt;typename T&gt;void print(Stack &lt;T&gt; stack)&#123; while (!stack.empty()) &#123; cout &lt;&lt; stack.top() &lt;&lt; &quot; &quot;; stack.pop(); &#125; cout &lt;&lt; endl;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template(queue)","slug":"ç¨‹è®¾/queue with template","date":"2022-05-24T03:03:28.851Z","updated":"2022-05-24T06:20:41.314Z","comments":true,"path":"2022/05/24/ç¨‹è®¾/queue with template/","link":"","permalink":"http://example.com/2022/05/24/%E7%A8%8B%E8%AE%BE/queue%20with%20template/","excerpt":"","text":"Description Please modify class Queue's declaration and definition so as to finish the test from main.cpp. Attention: please use template you have learned in the class to finish this assignment and DO NOT add or modify any memeber functions or member variables. Warning: DO NOT USE queue in STL. The Queue's declaration with element type int is below: 123456789101112131415161718192021222324252627class Queue &#123; public: Queue(); Queue(const Queue &amp; another); ~Queue(); bool empty(); int size(); int front() const; int back() const; void push(int element); void pop(); void swap(Queue &amp; queue); private: struct Node &#123; int element; Node* next; Node(int ele, Node* n = NULL) &#123; element = ele; next = n; &#125; &#125;; Node* front_node; Node* back_node; int node_num;&#125;; Hint å¦‚æœä½ å¯¹ç±»ä¸­çš„æˆå‘˜å‡½æ•°æœ‰ç–‘é—®ï¼Œå‡½æ•°çš„å…·ä½“ä½œç”¨ï¼Œè¯·å‚è§ï¼šwww.cplusplus.comé‡Œçš„queueå†…å®¹ Author: é»æ´‹ main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &quot;Queue.h&quot;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;class Job &#123; public: explicit Job(int pri = 0) &#123; id = number++; priority = pri; &#125; string toString() &#123; stringstream ss; ss &lt;&lt; &quot;[&quot; &lt;&lt; id &lt;&lt; &quot;:&quot; &lt;&lt; priority &lt;&lt; &quot;]&quot;; return ss.str(); &#125; private: static int number; int id; int priority;&#125;;int Job::number = 0;template&lt;class T&gt;void print(Queue&lt;T&gt; queue) &#123; while (!queue.empty()) &#123; cout &lt;&lt; queue.front() &lt;&lt; &quot; &quot;; queue.pop(); &#125; cout &lt;&lt; endl;&#125;int main() &#123; // test case 1: integer.. Queue&lt;int&gt; que; int m, n; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) que.push(i + 0.01); for (int i = 0; i &lt; n; i++) que.pop(); if (!que.empty()) &#123; cout &lt;&lt; que.front() &lt;&lt; endl; cout &lt;&lt; que.back() &lt;&lt; endl; &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; que.size() &lt;&lt; endl; if (que.empty()) cout &lt;&lt; &quot;The queue is empty!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;The queue is NOT empty!&quot; &lt;&lt; endl; // test case 2: double.. Queue&lt;double&gt; que1; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) que1.push(i + 0.01); for (int i = 0; i &lt; n; i++) que1.pop(); if (!que1.empty()) &#123; cout &lt;&lt; que1.front() &lt;&lt; endl; cout &lt;&lt; que1.back() &lt;&lt; endl; &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; que1.size() &lt;&lt; endl; if (que1.empty()) cout &lt;&lt; &quot;The queue is empty!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;The queue is NOT empty!&quot; &lt;&lt; endl; // test case 3: user defined class.. Queue&lt;Job&gt; que2; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) que2.push(Job(i)); for (int i = 0; i &lt; n; i++) que2.pop(); if (!que2.empty()) &#123; cout &lt;&lt; que2.front().toString() &lt;&lt; endl; cout &lt;&lt; que2.back().toString() &lt;&lt; endl; &#125; cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; que2.size() &lt;&lt; endl; if (que2.empty()) cout &lt;&lt; &quot;The queue is empty!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;The queue is NOT empty!&quot; &lt;&lt; endl; // test case 4: swap function.. Queue&lt;int&gt; que3, que4; for (int i = 0; i &lt; m; i++) que3.push(i); for (int i = 0; i &lt; n; i++) que4.push(m - i); cout &lt;&lt; &quot;Before Swap....&quot; &lt;&lt; endl; print(que3); print(que4); que3.swap(que4); cout &lt;&lt; &quot;After Swap....&quot; &lt;&lt; endl; cout &lt;&lt; endl; print(que3); print(que4);&#125; Queue.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;template&lt;typename T&gt;class Queue&#123; public: Queue()&#123; front_node = NULL; back_node = NULL; node_num = 0; &#125; Queue(const Queue &amp; another):node_num(0)&#123; for(Node* i = another.front_node; i != another.back_node; i = i-&gt;next)&#123; push(i-&gt;element); &#125; push(another.back_node-&gt;element); &#125; ~Queue()&#123; while(front_node)&#123; Node* temp = front_node; front_node = front_node-&gt;next; delete temp; &#125; &#125; bool empty()&#123; return node_num == 0; &#125; int size()&#123; return node_num; &#125; T front() const&#123; return front_node-&gt;element; &#125; T back() const&#123; return back_node-&gt;element; &#125; void push(T element)&#123; if(empty())&#123; Node* temp = new Node(element); back_node = temp; front_node = temp; node_num = 1; &#125; else&#123; Node* temp = new Node(element); back_node-&gt;next = temp; back_node = temp; ++node_num; &#125; &#125; void pop()&#123; if(!empty())&#123; --node_num; Node* temp = front_node; front_node = front_node-&gt;next; delete temp; &#125; &#125; void swap(Queue &amp; queue)&#123; Node* temp = front_node; front_node = queue.front_node; queue.front_node = temp; temp = back_node; back_node = queue.back_node; queue.back_node = temp; int temp1 = node_num; node_num = queue.node_num; queue.node_num = temp1; &#125; private: struct Node &#123; T element; Node* next; Node(T ele, Node* n = NULL) &#123; element = ele; next = n; &#125; &#125;; Node* front_node; Node* back_node; int node_num;&#125;; Queue.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;using namespace std; template &lt;typename ElementType&gt;class Queue &#123; public: Queue(); Queue(const Queue&lt;ElementType&gt;&amp; another); ~Queue(); bool empty(); int size(); ElementType front() const; ElementType back() const; void push(ElementType element); void pop(); void swap(Queue&lt;ElementType&gt;&amp; queue); private: struct Node &#123; ElementType element; Node* next; Node(ElementType ele, Node* n = NULL) &#123; element = ele; next = n; &#125; &#125;; Node* front_node; Node* back_node; int node_num;&#125;; template &lt;typename ElementType&gt;Queue&lt;ElementType&gt;::Queue(const Queue&lt;ElementType&gt;&amp; another) &#123; if (this == &amp;another) return; front_node = back_node = NULL; node_num = 0; Node* temp = another.front_node; while (temp != NULL) &#123; push(temp-&gt;element); temp = temp-&gt;next; &#125;&#125; template &lt;typename ElementType&gt;Queue&lt;ElementType&gt;::Queue() &#123; front_node = back_node = NULL; node_num = 0;&#125; template &lt;typename ElementType&gt;Queue&lt;ElementType&gt;::~Queue() &#123; while (!empty()) &#123; pop(); &#125;&#125; template &lt;typename ElementType&gt;bool Queue&lt;ElementType&gt;::empty() &#123; return node_num == 0;&#125; template &lt;typename ElementType&gt;int Queue&lt;ElementType&gt;::size() &#123; return node_num;&#125; template &lt;typename ElementType&gt;ElementType Queue&lt;ElementType&gt;::front() const &#123; return front_node-&gt;element;&#125; template &lt;typename ElementType&gt;ElementType Queue&lt;ElementType&gt;::back() const &#123; return back_node-&gt;element;&#125; template &lt;typename ElementType&gt;void Queue&lt;ElementType&gt;::push(ElementType element) &#123; if (front_node == NULL) &#123; front_node = back_node = new Node(element); &#125; else &#123; back_node-&gt;next = new Node(element); back_node = back_node-&gt;next; &#125; node_num++;&#125; template &lt;typename ElementType&gt;void Queue&lt;ElementType&gt;::pop() &#123; if (empty()) return; if (size() == 1) &#123; delete front_node; front_node = back_node = NULL; &#125; else &#123; Node* temp = front_node; front_node = front_node-&gt;next; delete temp; &#125; node_num--;&#125; template &lt;typename ElementType&gt;void Queue&lt;ElementType&gt;::swap(Queue&lt;ElementType&gt;&amp; queue) &#123; int old_size = size(); while (!empty()) &#123; queue.push(front()); pop(); &#125; while (queue.size() &gt; old_size) &#123; push(queue.front()); queue.pop(); &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"stack(æŒ‡é’ˆgou'jian)","slug":"ç¨‹è®¾/stack","date":"2022-05-23T13:46:36.689Z","updated":"2022-05-24T02:10:58.428Z","comments":true,"path":"2022/05/23/ç¨‹è®¾/stack/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/stack/","excerpt":"","text":"Description æ„å»ºä½¿ç”¨æŒ‡é’ˆæ„å»ºåŠ¨æ€å †æ ˆã€‚ å·²çŸ¥æ¯ä¸€ä¸ªæ•°æ®èŠ‚ç‚¹çš„ç»“æ„ä½“ï¼š 12345typedef int ELEMENT; // ä¸ºå †æ ˆå…ƒç´ ç±»å‹èµ·ä¸€ä¸ªåˆ«åstruct NODE &#123; ELEMENT element; // å­˜æ”¾å †æ ˆçš„å…ƒç´  NODE* link; // æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹çš„é“¾æ¥&#125;; ç±»å£°æ˜ï¼š 1234567891011121314class STACK &#123;public: STACK(); // æ„é€ å‡½æ•°ï¼Œè®¾ç½®æ ˆé¡¶ä¸ºç©ºæŒ‡é’ˆ ~STACK(); // ææ„å‡½æ•°ï¼Œé‡Šæ”¾å †æ ˆç»“ç‚¹å ç”¨çš„å­˜å‚¨ç©ºé—´ void push(ELEMENT obj); // å°†å…ƒç´ objå‹å…¥æ ˆé¡¶ void pop(); // å°†å½“å‰æ ˆé¡¶çš„å…ƒç´ å¼¹å‡ºæ ˆä¸­ã€‚è¦æ±‚ï¼šæ ˆä¸ä¸ºç©ºã€‚ ELEMENT get_top() const; // è¿”å›å½“å‰æ ˆé¡¶çš„å…ƒç´ å€¼ã€‚è¦æ±‚ï¼šæ ˆä¸ä¸ºç©ºã€‚ bool is_empty() const; // åˆ¤æ–­å½“å‰å †æ ˆæ˜¯å¦ä¸ºç©ºï¼Œç©ºåˆ™è¿”å›trueï¼Œéç©ºåˆ™è¿”å›false void display() const; // è‡ªé¡¶å‘ä¸‹æ˜¾ç¤ºå †æ ˆä¸­çš„å…ƒç´ private: NODE* top; // å †æ ˆçš„æ ˆé¡¶&#125;; Sample Output 12345678910111213141516171819202120 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 1 202 193 184 175 166 157 148 139 1210 1111 1012 913 814 715 616 517 418 319 220 1 STACK.H(lock) 1234567891011121314151617181920212223#ifndef STACK_H#define STACK_Htypedef int ELEMENT; // ä¸ºå †æ ˆå…ƒç´ ç±»å‹èµ·ä¸€ä¸ªåˆ«åstruct NODE &#123; ELEMENT element; // å­˜æ”¾å †æ ˆçš„å…ƒç´  NODE* link; // æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹çš„é“¾æ¥&#125;;class STACK &#123;public: STACK(); // æ„é€ å‡½æ•°ï¼Œè®¾ç½®æ ˆé¡¶ä¸ºç©ºæŒ‡é’ˆ ~STACK(); // ææ„å‡½æ•°ï¼Œé‡Šæ”¾å †æ ˆç»“ç‚¹å ç”¨çš„å­˜å‚¨ç©ºé—´ void push(ELEMENT obj); // å°†å…ƒç´ objå‹å…¥æ ˆé¡¶ void pop(); // å°†å½“å‰æ ˆé¡¶çš„å…ƒç´ å¼¹å‡ºæ ˆä¸­ã€‚è¦æ±‚ï¼šæ ˆä¸ä¸ºç©ºã€‚ ELEMENT get_top() const; // è¿”å›å½“å‰æ ˆé¡¶çš„å…ƒç´ å€¼ã€‚è¦æ±‚ï¼šæ ˆä¸ä¸ºç©ºã€‚ bool is_empty() const; // åˆ¤æ–­å½“å‰å †æ ˆæ˜¯å¦ä¸ºç©ºï¼Œç©ºåˆ™è¿”å›trueï¼Œéç©ºåˆ™è¿”å›false void display() const; // è‡ªé¡¶å‘ä¸‹æ˜¾ç¤ºå †æ ˆä¸­çš„å…ƒç´ private: NODE* top; // å †æ ˆçš„æ ˆé¡¶&#125;;#endif main.cpp(lock) 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &quot;STACK.h&quot;using namespace std;int main()&#123; STACK turner; // å£°æ˜ä¸€ä¸ªå…ƒç´ ä¸ºæ•´æ•°ç±»å‹çš„å †æ ˆ ELEMENT user_input; // ç”¨æˆ·è¾“å…¥çš„å…ƒç´ ï¼ˆå³æ•´æ•°ç±»å‹ï¼‰ int loop; // å¾ªç¯å˜é‡ int max_input = 20; for (loop = 1; loop &lt;= max_input; loop++) // ç”±ç”¨æˆ·è¾“å…¥è‹¥å¹²ä¸ªå…ƒç´  &#123; turner.push(loop); // å°†ç”¨æˆ·è¾“å…¥çš„å…ƒç´ å‹å…¥æ ˆä¸­ &#125; turner.display(); // æµ‹è¯•å †æ ˆä¸­çš„å†…å®¹ for (loop = 1; loop &lt;= max_input; loop++) &#123; if (!turner.is_empty()) // ä»…å½“å †æ ˆä¸ä¸ºç©ºæ—¶æ‰å¤„ç† &#123; user_input = turner.get_top(); // å–å‡ºæ ˆé¡¶å…ƒç´ çš„å€¼ turner.pop(); // å°†æ ˆé¡¶å…ƒç´ å¼¹å‡º cout &lt;&lt;loop&lt;&lt;&quot; &quot;&lt;&lt; user_input &lt;&lt; endl; &#125; &#125; return 0;&#125; STACK.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;STACK.h&quot;#include &lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;STACK::STACK()&#123; top = NULL; // å°†æ ˆé¡¶ç½®ä¸ºç©º&#125;STACK::~STACK()&#123; NODE* ptr; // æŒ‡å‘å †æ ˆç»“ç‚¹çš„ä¸´æ—¶æŒ‡é’ˆ while (top != NULL) // ä»ä¸Šåˆ°ä¸‹é‡Šæ”¾å †æ ˆçš„ç»“ç‚¹ï¼Œæ³¨æ„å¾ªç¯ä½“ä¸­è¯­å¥çš„æ¬¡åº &#123; ptr = top; // å…ˆè®°ä½å°†è¢«æ‘˜ä¸‹æ¥çš„æ ˆé¡¶ç»“ç‚¹ top = top-&gt;link; // æ‘˜ä¸‹æ ˆé¡¶ç»“ç‚¹ delete ptr; // é‡Šæ”¾åˆšæ‰è¢«æ‘˜ä¸‹æ¥çš„ç»“ç‚¹ &#125;&#125;void STACK::push(ELEMENT obj) // å°†objå‹å…¥å †æ ˆçš„æ ˆé¡¶&#123; NODE* temp; temp = new NODE; // åˆ›å»ºä¸€ä¸ªæ–°ç»“ç‚¹ if (temp != NULL) // å†…å­˜åˆ†é…æˆåŠŸæ—¶ &#123; temp-&gt;link = top; temp-&gt;element = obj; top = temp; &#125; else // å†…å­˜åˆ†é…å¤±è´¥æ—¶ä½œå¼‚å¸¸å¤„ç† &#123; cout &lt;&lt; &quot;Error: No enough memory.&quot;&lt;&lt; endl; exit(1); // ç»ˆæ­¢ç¨‹åº &#125;&#125;void STACK::pop() // å°†å †æ ˆå½“å‰çš„æ ˆé¡¶å…ƒç´ å¼¹å‡º&#123; NODE* temp; if (top != NULL) // å †æ ˆä¸ä¸ºç©ºæ—¶æ‰å¤„ç† &#123; temp = top; // å°†æ ˆé¡¶å…ƒç´ å¼¹å‡ºå †æ ˆ top = top-&gt;link; delete temp; // é‡Šæ”¾è¢«å¼¹å‡ºç»“ç‚¹å ç”¨çš„å­˜å‚¨ç©ºé—´ &#125; else // ç©ºæ ˆæ—¶ä½œå¼‚å¸¸å¤„ç† &#123; cout &lt;&lt; &quot;Error: Pop from empty stack.\\n&quot;; exit(1); // ç»ˆæ­¢ç¨‹åº &#125;&#125;ELEMENT STACK::get_top() const // è¿”å›å½“å‰æ ˆé¡¶çš„å…ƒç´ å€¼&#123; if (top == NULL) // ç©ºæ ˆæ—¶ä½œå¼‚å¸¸å¤„ç† &#123; cout &lt;&lt; &quot;Error: Get top from empty stack.\\n&quot;; exit(1); // ç»ˆæ­¢ç¨‹åº &#125; return top-&gt;element; // è¿”å›æ ˆé¡¶çš„å½“å‰å€¼&#125;bool STACK::is_empty() const // åˆ¤æ–­å½“å‰å †æ ˆæ˜¯å¦ä¸ºç©ºï¼Œç©ºåˆ™è¿”å›trurï¼Œéç©ºåˆ™è¿”å›false&#123; return (top == NULL);&#125;void STACK::display() const // è‡ªé¡¶å‘ä¸‹æ˜¾ç¤ºå †æ ˆä¸­çš„å…ƒç´ &#123; NODE* loop; loop = top; while (loop != NULL) // ä»¥ç©ºæŒ‡é’ˆä½œä¸ºé“¾çš„ç»“æŸæ ‡è®° &#123; cout &lt;&lt; loop-&gt;element &lt;&lt; &quot; &quot;; // å°†å½“å‰ç»“ç‚¹çš„å…ƒç´ è¾“å‡º loop = loop-&gt;link; // æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹ &#125; cout&lt;&lt;endl;&#125; stack.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;NODE* top; // å †æ ˆçš„æ ˆé¡¶STACK:: STACK()&#123; top = NULL;&#125; // æ„é€ å‡½æ•°ï¼Œè®¾ç½®æ ˆé¡¶ä¸ºç©ºæŒ‡é’ˆSTACK:: ~STACK()&#123; while(top != NULL)&#123; NODE* temp = top; top = top -&gt; link; delete top; &#125;&#125; // ææ„å‡½æ•°ï¼Œé‡Šæ”¾å †æ ˆç»“ç‚¹å ç”¨çš„å­˜å‚¨ç©ºé—´ void STACK:: push(ELEMENT obj)&#123; NODE* temp = new NODE; temp -&gt; element = obj; temp -&gt; link = top; top = temp;&#125; // å°†å…ƒç´ objå‹å…¥æ ˆé¡¶void STACK:: pop()&#123; if(!is_empty())&#123; NODE* temp = top; top = top -&gt; link; delete temp; &#125;&#125; // å°†å½“å‰æ ˆé¡¶çš„å…ƒç´ å¼¹å‡ºæ ˆä¸­ã€‚è¦æ±‚ï¼šæ ˆä¸ä¸ºç©ºã€‚ELEMENT STACK:: get_top() const&#123; if(!is_empty())&#123; return top -&gt; element; &#125;else&#123; return 0; &#125;&#125; // è¿”å›å½“å‰æ ˆé¡¶çš„å…ƒç´ å€¼ã€‚è¦æ±‚ï¼šæ ˆä¸ä¸ºç©ºã€‚bool STACK:: is_empty() const&#123; if(!top) return true; else return false;&#125; // åˆ¤æ–­å½“å‰å †æ ˆæ˜¯å¦ä¸ºç©ºï¼Œç©ºåˆ™è¿”å›trueï¼Œéç©ºåˆ™è¿”å›falsevoid STACK:: display() const&#123; NODE* temp = top; while(temp != NULL)&#123; cout &lt;&lt; temp -&gt; element &lt;&lt; &quot; &quot;; temp = temp -&gt; link; if(temp) cout &lt;&lt; &#x27; &#x27;; else cout &lt;&lt; endl; &#125;&#125; // è‡ªé¡¶å‘ä¸‹æ˜¾ç¤ºå †æ ˆä¸­çš„å…ƒç´ ","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template(func)","slug":"ç¨‹è®¾/template(func)","date":"2022-05-23T13:33:37.854Z","updated":"2022-05-23T13:34:54.344Z","comments":true,"path":"2022/05/23/ç¨‹è®¾/template(func)/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/template(func)/","excerpt":"","text":"Description Implement the 3 functions: 12345template &lt;typename T&gt;void demoFunc(const T v1, const T v2)template &lt;typename T&gt;void demoFunc(const T v)void demoFunc(const int v1, const int v2) Sample Output 12345678the first generic version of demoFunc()the arguments: 2.8 8.5the second generic version of demoFunc()the argument: 3the ordinary version of demoFunc()the arguments: 3 5the ordinary version of demoFunc()the arguments: 65 5 main.cpp(lock) 1234567891011121314151617181920212223#include &quot;demo.hpp&quot;int main()&#123; char ch1 = &#x27;A&#x27;, ch2 = &#x27;B&#x27;; int iv1 = 3, iv2 = 5; double dv1 = 2.8, dv2 = 8.5; // è°ƒç”¨ç¬¬ä¸€ä¸ªå‡½æ•°æ¨¡æ¿çš„å®ä¾‹ demoFunc(dv1, dv2); // è°ƒç”¨ç¬¬äºŒä¸ªå‡½æ•°æ¨¡æ¿çš„å®ä¾‹ demoFunc(iv1); // è°ƒç”¨éæ¨¡æ¿å‡½æ•°demoFunc(int, int) demoFunc(iv1, iv2); // è°ƒç”¨éæ¨¡æ¿å‡½æ•°demoFunc(int, int)ï¼ˆè¿›è¡Œéšå¼ç±»å‹è½¬æ¢ï¼‰ demoFunc(ch1, iv2); return 0;&#125; demo.h 123456789101112131415#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;void demoFunc(const T v1, const T v2)&#123; cout &lt;&lt; &quot;the first generic version of demoFunc()&quot; &lt;&lt; endl &lt;&lt; &quot;the arguments: &quot; &lt;&lt; v1 &lt;&lt; &#x27; &#x27; &lt;&lt; v2 &lt;&lt; endl; &#125;template &lt;typename T&gt;void demoFunc(const T v)&#123; cout &lt;&lt; &quot;the second generic version of demoFunc()&quot; &lt;&lt; endl &lt;&lt; &quot;the argument: &quot; &lt;&lt; v &lt;&lt; endl; &#125;void demoFunc(const int v1, const int v2)&#123; cout &lt;&lt; &quot;the ordinary version of demoFunc()&quot; &lt;&lt; endl &lt;&lt; &quot;the arguments: &quot; &lt;&lt; v1 &lt;&lt; &#x27; &#x27; &lt;&lt; v2 &lt;&lt; endl; &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template(class)","slug":"ç¨‹è®¾/template(class)","date":"2022-05-23T13:08:00.826Z","updated":"2022-05-23T13:29:15.244Z","comments":true,"path":"2022/05/23/ç¨‹è®¾/template(class)/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/template(class)/","excerpt":"","text":"Description Implement the following template: 1234567891011121314template &lt;typename ElementType, std::size_t N&gt;class Stack&#123;public: Stack(); void push(ElementType obj); void pop(); ElementType getTop() const; bool isEmpty() const;private: ElementType elements[N]; // å †æ ˆä¸­å­˜æ”¾çš„å…ƒç´  std::size_t count; // å †æ ˆä¸­ç°æœ‰å…ƒç´ çš„æ•°ç›®&#125;; Output 12343201 Hint Note: size_t is in header . main.cpp(lock) 1234567891011121314151617181920#include &quot;array_basedGStack.hpp&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; Stack&lt;int, 10&gt; stack; // å£°æ˜ä¸€ä¸ªä¿å­˜10ä¸ªintå‹å…ƒç´ çš„å †æ ˆ stack.push(1); stack.push(2); stack.push(3); cout &lt;&lt; stack.getTop() &lt;&lt; endl; stack.pop(); cout &lt;&lt; stack.getTop() &lt;&lt; endl; stack.pop(); cout &lt;&lt; stack.isEmpty() &lt;&lt; endl; stack.pop(); cout &lt;&lt; stack.isEmpty() &lt;&lt; endl; return 0;&#125; array_basedGStack.hpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstddef&gt;#include &lt;stdexcept&gt;template &lt;typename ElementType, std::size_t N&gt;class Stack&#123;public: Stack(); void push(ElementType obj); void pop(); ElementType getTop() const; bool isEmpty() const;private: ElementType elements[N]; // å †æ ˆä¸­å­˜æ”¾çš„å…ƒç´  std::size_t count; // å †æ ˆä¸­ç°æœ‰å…ƒç´ çš„æ•°ç›®&#125;;// #include &quot;array_basedGStack.cpp&quot; // åŒ…å«æºæ–‡ä»¶template &lt;typename ElementType, std::size_t N&gt;Stack&lt;ElementType, N&gt;::Stack() // å°†å †æ ˆåˆå§‹åŒ–ä¸ºç©ºæ ˆ&#123; count = 0; // å°†å…ƒç´ æ•°ç›®ç½®ä¸º0&#125;template &lt;typename ElementType, std::size_t N&gt;void Stack&lt;ElementType, N&gt;::push(ElementType obj)// å°†å…ƒç´ objå‹å…¥å †æ ˆ&#123; if (count &lt; N) &#123; // å †æ ˆæœªæ»¡ elements[count] = obj; count++; &#125; else &#123; // å †æ ˆå·²æ»¡ throw std::logic_error(&quot;push onto full stack&quot;); &#125;&#125;template &lt;typename ElementType, std::size_t N&gt;void Stack&lt;ElementType, N&gt;::pop()&#123; if (!isEmpty()) count--;&#125;template &lt;typename ElementType, std::size_t N&gt;bool Stack&lt;ElementType, N&gt;::isEmpty() const&#123; if (count == 0) return true; return false;&#125;template &lt;typename ElementType, std::size_t N&gt;ElementType Stack&lt;ElementType, N&gt;::getTop() const&#123; return elements[count - 1];&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"template","slug":"ç¨‹è®¾/template","date":"2022-05-23T13:02:50.690Z","updated":"2022-05-23T13:04:06.951Z","comments":true,"path":"2022/05/23/ç¨‹è®¾/template/","link":"","permalink":"http://example.com/2022/05/23/%E7%A8%8B%E8%AE%BE/template/","excerpt":"","text":"Description Implement the following function template: 12template &lt;typename T, std::size_t N&gt;void printValues(T (&amp;arr)[N]) In this function, you need print the values in the input array. Sample Output 123456789101234561.22.33.44.5 main.cpp(lock) 123456789101112#include &quot;printArray.h&quot;int main()&#123; int intArr[6] = &#123;1, 2, 3, 4, 5, 6&#125;; double dblArr[4] = &#123;1.2, 2.3, 3.4, 4.5&#125;; printValues(intArr); // ç”Ÿæˆå‡½æ•°å®ä¾‹printValues(int (&amp;) [6]) printValues(dblArr); // ç”Ÿæˆå‡½æ•°å®ä¾‹printValues(double (&amp;) [4]) return 0;&#125; printarrlist.hpp 1234567891011121314#include&lt;iostream&gt;using namespace std;template &lt;typename T, size_t N&gt;void printValues(T (&amp;arr)[N])&#123; size_t i = 0; while(i &lt; N)&#123; cout &lt;&lt; arr[i] &lt;&lt; endl; ++i; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç©å…·è°œé¢˜","slug":"ç¨‹è®¾/ç©å…·è°œé¢˜","date":"2022-05-22T12:18:39.499Z","updated":"2022-05-22T12:44:52.194Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/ç©å…·è°œé¢˜/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E7%8E%A9%E5%85%B7%E8%B0%9C%E9%A2%98/","excerpt":"","text":"ç©å…·è°œé¢˜ é¢˜ç›®èƒŒæ™¯ NOIP2016 æé«˜ç»„ D1T1 é¢˜ç›®æè¿° å°å—æœ‰ä¸€å¥—å¯çˆ±çš„ç©å…·å°äºº, å®ƒä»¬å„æœ‰ä¸åŒçš„èŒä¸šã€‚ æœ‰ä¸€å¤©, è¿™äº›ç©å…·å°äººæŠŠå°å—çš„çœ¼é•œè—äº†èµ·æ¥ã€‚ å°å—å‘ç°ç©å…·å°äººä»¬å›´æˆäº†ä¸€ä¸ªåœˆ,å®ƒä»¬æœ‰çš„é¢æœåœˆå†…,æœ‰çš„é¢æœåœˆå¤–ã€‚å¦‚ä¸‹å›¾: è¿™æ—¶\\(singer\\)å‘Šè¯‰å°å—ä¸€ä¸ªè°œé¡Œ: â€œçœ¼é•œè—åœ¨æˆ‘å·¦æ•°ç¬¬3ä¸ªç©å…·å°äººçš„å³æ•°ç¬¬\\(1\\)ä¸ªç©å…·å°äººçš„å·¦æ•°ç¬¬\\(2\\)ä¸ªç©å…·å°äººé‚£é‡Œã€‚ â€ å°å—å‘ç°, è¿™ä¸ªè°œé¢˜ä¸­ç©å…·å°äººçš„æœå‘éå¸¸å…³é”®, å› ä¸ºæœå†…å’Œæœå¤–çš„ç©å…·å°äººçš„å·¦å³æ–¹å‘æ˜¯ç›¸åçš„: é¢æœåœˆå†…çš„ç©å…·å°äºº, å®ƒçš„å·¦è¾¹æ˜¯é¡ºæ—¶é’ˆæ–¹å‘, å³è¾¹æ˜¯é€†æ—¶é’ˆæ–¹å‘; è€Œé¢å‘åœˆå¤–çš„ç©å…·å°äºº, å®ƒçš„å·¦è¾¹æ˜¯é€†æ—¶é’ˆæ–¹å‘, å³è¾¹æ˜¯é¡ºæ—¶é’ˆæ–¹å‘ã€‚ å°å—ä¸€è¾¹è‰°éš¾åœ°è¾¨è®¤ç€ç©å…·å°äºº, ä¸€è¾¹æ•°ç€: \\(singer\\)æœå†…, å·¦æ•°ç¬¬\\(3\\)ä¸ªæ˜¯\\(archer\\)ã€‚ \\(archer\\)æœå¤–,å³æ•°ç¬¬\\(1\\)ä¸ªæ˜¯\\(thinker\\)ã€‚ \\(thinker\\)æœå¤–, å·¦æ•°ç¬¬\\(2\\)ä¸ªæ˜¯\\(write\\)rã€‚ æ‰€ä»¥çœ¼é•œè—åœ¨\\(writer\\)è¿™é‡Œ! è™½ç„¶æˆåŠŸæ‰¾å›äº†çœ¼é•œ, ä½†å°å—å¹¶æ²¡æœ‰æ”¾å¿ƒã€‚ å¦‚æœä¸‹æ¬¡æœ‰æ›´å¤šçš„ç©å…·å°äººè—ä»–çš„çœ¼é•œ, æˆ–æ˜¯è°œé¡Œçš„é•¿åº¦æ›´é•¿, ä»–å¯èƒ½å°±æ— æ³•æ‰¾åˆ°çœ¼é•œäº† ã€‚ æ‰€ä»¥å°å—å¸Œæœ›ä½ å†™ç¨‹åºå¸®ä»–è§£å†³ç±»ä¼¼çš„è°œé¡Œã€‚ è¿™æ ·çš„è°œé¡Œå…·ä½“å¯ä»¥æè¿°ä¸º: æœ‰ \\(n\\)ä¸ªç©å…·å°äººå›´æˆä¸€åœˆ, å·²çŸ¥å®ƒä»¬çš„èŒä¸šå’Œæœå‘ã€‚ç°åœ¨ç¬¬\\(1\\)ä¸ªç©å…·å°äººå‘Šè¯‰å°å—ä¸€ä¸ªåŒ…å«\\(m\\)æ¡æŒ‡ä»¤çš„è°œé¡Œ, å…¶ä¸­ç¬¬ \\(z\\)æ¡æŒ‡ä»¤å½¢å¦‚â€œå·¦æ•°/å³æ•°ç¬¬$ s$,ä¸ªç©å…·å°äººâ€ã€‚ ä½ éœ€è¦è¾“å‡ºä¾æ¬¡æ•°å®Œè¿™äº›æŒ‡ä»¤å,åˆ°è¾¾çš„ç©å…·å°äººçš„èŒä¸šã€‚ è¾“å…¥æ ¼å¼ è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° \\(n,m\\)ï¼Œè¡¨ç¤ºç©å…·å°äººçš„ä¸ªæ•°å’ŒæŒ‡ä»¤çš„æ¡æ•°ã€‚ æ¥ä¸‹æ¥ \\(n\\) è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°å’Œä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä»¥é€†æ—¶é’ˆä¸ºé¡ºåºç»™å‡ºæ¯ä¸ªç©å…·å°äººçš„æœå‘å’ŒèŒä¸šã€‚å…¶ä¸­ \\(0\\) è¡¨ç¤ºæœå‘åœˆå†…ï¼Œ\\(1\\) è¡¨ç¤ºæœå‘åœˆå¤–ã€‚ ä¿è¯ä¸ä¼šå‡ºç°å…¶ä»–çš„æ•°ã€‚å­—ç¬¦ä¸²é•¿åº¦ä¸è¶…è¿‡ \\(10\\) ä¸”ä»…ç”±å°å†™å­—æ¯æ„æˆï¼Œå­—ç¬¦ä¸²ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å­—ç¬¦ä¸²ä¸¤ä¸¤ä¸åŒã€‚æ•´æ•°å’Œå­—ç¬¦ä¸²ä¹‹é—´ç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ã€‚ æ¥ä¸‹æ¥ \\(m\\) è¡Œï¼Œå…¶ä¸­ç¬¬ \\(i\\) è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° \\(a_i,s_i\\)ï¼Œè¡¨ç¤ºç¬¬ \\(i\\) æ¡æŒ‡ä»¤ã€‚è‹¥ \\(a_i=0\\)ï¼Œè¡¨ç¤ºå‘å·¦æ•° \\(s_i\\) ä¸ªäººï¼›è‹¥ \\(a_i=1\\)ï¼Œè¡¨ç¤ºå‘å³æ•° \\(s_i\\) ä¸ªäººã€‚ ä¿è¯ \\(a_i\\) ä¸ä¼šå‡ºç°å…¶ä»–çš„æ•°ï¼Œ\\(1 \\le s_i &lt; n\\)ã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä»ç¬¬ä¸€ä¸ªè¯»å…¥çš„å°äººå¼€å§‹ï¼Œä¾æ¬¡æ•°å®Œ \\(m\\) æ¡æŒ‡ä»¤ååˆ°è¾¾çš„å°äººçš„èŒä¸šã€‚ æ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 12345678910117 30 singer0 reader0 mengbier 1 thinker1 archer0 writer1 mogician 0 31 10 2 æ ·ä¾‹è¾“å‡º #1 1writer æ ·ä¾‹ #2 æ ·ä¾‹è¾“å…¥ #2 12345678910111213141516171819202110 101 C0 r0 P1 d1 e1 m1 t1 y1 u0 V1 71 11 40 50 30 11 61 20 80 4 æ ·ä¾‹è¾“å‡º #2 1y æç¤º ã€æ ·ä¾‹1è¯´æ˜ã€‘ è¿™ç»„æ•°æ®å°±æ˜¯ã€é¢˜ç›®æè¿°ã€‘ ä¸­æåˆ°çš„ä¾‹å­ã€‚ ã€å­ä»»åŠ¡ã€‘ å­ä»»åŠ¡ä¼šç»™å‡ºéƒ¨åˆ†æµ‹è¯•æ•°æ®çš„ç‰¹ç‚¹ã€‚ å¦‚æœä½ åœ¨è§£å†³é¢˜ç›®ä¸­é‡åˆ°äº†å›°éš¾, å¯ä»¥å°è¯•åªè§£å†³ä¸€éƒ¨åˆ†æµ‹è¯•æ•°æ®ã€‚ æ¯ä¸ªæµ‹è¯•ç‚¹çš„æ•°æ®è§„æ¨¡åŠç‰¹ç‚¹å¦‚ä¸‹è¡¨: å…¶ä¸­ä¸€äº›ç®€å†™çš„åˆ—æ„ä¹‰å¦‚ä¸‹: â€¢ å…¨æœå†…: è‹¥ä¸ºâ€œâˆšâ€, è¡¨ç¤ºè¯¥æµ‹è¯•ç‚¹ä¿è¯æ‰€æœ‰çš„ç©å…·å°äººéƒ½æœå‘åœˆå†…; å…¨å·¦æ•°:è‹¥ä¸ºâ€œâˆšâ€,è¡¨ç¤ºè¯¥æµ‹è¯•ç‚¹ä¿è¯æ‰€æœ‰çš„æŒ‡ä»¤éƒ½å‘å·¦æ•°,å³å¯¹ä»»æ„çš„ \\(1â‰¤zâ‰¤m, a_i=0\\); \\(s= 1\\):è‹¥ä¸ºâ€œâˆšâ€,è¡¨ç¤ºè¯¥æµ‹è¯•ç‚¹ä¿è¯æ‰€æœ‰çš„æŒ‡ä»¤éƒ½åªæ•°1ä¸ª,å³å¯¹ä»»æ„çš„ \\(1â‰¤zâ‰¤m,s_i=1\\); èŒä¸šé•¿åº¦ä¸º\\(1\\) :è‹¥ä¸ºâ€œâˆšâ€,è¡¨ç¤ºè¯¥æµ‹è¯•ç‚¹ä¿è¯æ‰€æœ‰ç©å…·å°äººçš„èŒä¸šä¸€å®šæ˜¯ä¸€ä¸ª é•¿åº¦ä¸º\\(1\\)çš„å­—ç¬¦ä¸²ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int main()&#123; co int n,m; cin&gt;&gt;n&gt;&gt;m; int people[n]; string people1 [n]; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;people[i]; cin&gt;&gt;people1 [i]; &#125; int operator[m][2]; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;operator[i][0]&gt;&gt;operator[i][1]; &#125; int ans = 0 ; for(int i=0;i&lt;m;i++)&#123; if( operator [i][0] == 0 &amp;&amp; people[ans] == 0 )&#123; ans += operator[i][1]; ans%=n; &#125; if( operator [i][0] == 0 &amp;&amp; people[ans] == 1 )&#123; ans -= operator[i][1]; if(ans&lt;0) ans+=n; &#125; if( operator [i][0] == 1 &amp;&amp; people[ans] == 0 )&#123; ans -= operator[i][1]; if(ans&lt;0) ans+=n; &#125; if( operator [i][0] == 1 &amp;&amp; people[ans] == 1 )&#123; ans += operator[i][1]; ans %=n; &#125; &#125; cout &lt;&lt; people1[ans]; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"è¯´å‡è¯","slug":"ç¨‹è®¾/è¯´å‡è¯","date":"2022-05-22T12:13:35.787Z","updated":"2022-05-22T12:14:24.156Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/è¯´å‡è¯/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E8%AF%B4%E5%81%87%E8%AF%9D/","excerpt":"","text":"åœ¨ã€Šä¸‰ä½“ã€‹ä¸­çš„ä¸‰ä½“æ–‡æ˜æ¥è§¦äº†äººç±»æ–‡æ˜ä»¥åé€æ¸å¼€å§‹å­¦ä¼šäº†è¯´å‡è¯ï¼Œäºæ˜¯ä¸‰ä½“ç¤¾ä¼šä¸­æµè¡Œèµ·äº†èšåœ¨ä¸€èµ·è¯„è®ºåˆ«äººè¯´çš„è¯æ˜¯çœŸæ˜¯å‡çš„æ´»åŠ¨ã€‚æœ‰ä¸€å¤©ï¼ŒNä¸ªäººï¼ˆç¼–å·èŒƒå›´[0,Nâˆ’1]ï¼‰èšåœ¨ä¸€èµ·ï¼Œæ¯ä¸ªäººéƒ½è¯´äº†ä¸€å¥ï¼š\"*a**i*è¯´çš„æ˜¯çœŸ/å‡è¯\"ã€‚ç°åœ¨ï¼Œå›´è§‚çš„ä½ æƒ³çŸ¥é“ä»–ä»¬æ¯ä¸ªäººè¯´çš„æ˜¯çœŸè¿˜æ˜¯å‡ï¼Ÿ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°Nï¼Œè¡¨ç¤ºæœ‰Nä¸ªäºº åé¢æ¥ç€Nè¡Œï¼Œå…¶ä¸­ç¬¬iè¡Œè¡¨ç¤ºç¼–å·ä¸ºiçš„äººè¯´çš„è¯ï¼Œæ¯è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°aiå’Œbiï¼Œè¡¨ç¤ºç¼–å·ä¸ºiçš„äººè¯´ç¼–å·ä¸ºaiçš„äººè¯´çš„æ˜¯çœŸè¯(bi=1)æˆ–å‡è¯(*b**i*=0) æ•°æ®èŒƒå›´1&lt;=N&lt;=15,0&lt;=ai&lt;N,biâˆˆ{0,1} è¾“å‡ºæ ¼å¼ Nä¸ªæ•´æ•°ï¼Œç¬¬iä¸ªæ•´æ•°ä¸º1è¡¨ç¤ºç¼–å·ä¸º i çš„äººå®é™…åœ¨è¯´çœŸè¯ï¼Œä¸º0è¡¨ç¤ºç¼–å·ä¸º i çš„äººå®é™…åœ¨è¯´å‡è¯ã€‚ è‹¥æœ‰å¤šç§æƒ…å†µï¼Œåˆ™è¾“å‡ºå­—å…¸åºæœ€å°çš„ä¸€ä¸ªã€‚ æ ·ä¾‹è¾“å…¥1 12321 00 0 æ ·ä¾‹è¾“å‡º1 10 1 æ ·ä¾‹è¾“å…¥2 123431 10 10 0 æ ·ä¾‹è¾“å‡º2 10 0 1 Hint æ ·ä¾‹è¾“å…¥1 0å·å’Œ1å·äº’ç›¸è¯´å¯¹æ–¹è¯´è°ï¼Œé‚£ä¹ˆæœ‰4ç§æƒ…å†µ 1.è‹¥0,1å®é™…éƒ½åœ¨è¯´è°ï¼š0è¯´è°æ‰€ä»¥ä»–è¯´çš„æ˜¯å‡çš„ï¼Œä»è€Œ1è¯´çš„æ˜¯çœŸçš„ï¼Œè¿™å°±ä¸1å®é™…åœ¨è¯´è°çŸ›ç›¾ 2.å®é™…0åœ¨è¯´è°ï¼Œ1åœ¨è¯´çœŸè¯ï¼š0è¯´è°æ‰€ä»¥ä»–è¯´çš„æ˜¯å‡çš„ï¼Œä»è€Œ1è¯´çš„æ˜¯çœŸçš„ï¼Œä¸çŸ›ç›¾ï¼›1åœ¨è¯´çœŸè¯æ‰€ä»¥0åœ¨è¯´è°ï¼Œä¸çŸ›ç›¾ 3.å®é™…1åœ¨è¯´è°ï¼Œ0åœ¨è¯´çœŸè¯ï¼š1è¯´è°æ‰€ä»¥ä»–è¯´çš„æ˜¯å‡çš„ï¼Œä»è€Œ0è¯´çš„æ˜¯çœŸçš„ï¼Œä¸çŸ›ç›¾ï¼›0åœ¨è¯´çœŸè¯æ‰€ä»¥1åœ¨è¯´è°ï¼Œä¸çŸ›ç›¾ 4.è‹¥0ï¼Œ1å®é™…éƒ½åœ¨è¯´çœŸè¯ï¼š0è¯´çœŸè¯æ‰€ä»¥1åœ¨è¯´è°ï¼Œè¿™å°±ä¸1å®é™…åœ¨è¯´çœŸè¯çŸ›ç›¾ æ•…åªæœ‰2ï¼Œ3ä¸¤ç§æƒ…å†µæ˜¯é€»è¾‘è‡ªæ²»çš„ï¼Œå…¶ä¸­æƒ…å†µ2ä¸ºâ€œ0 1â€è€Œæƒ…å†µ3ä¸ºâ€œ1 0â€ï¼Œæ‰€ä»¥è¾“å‡ºå°çš„é‚£ä¸€ä¸ªâ€œ0 1â€ æ ·ä¾‹è¾“å…¥2 åªæœ‰ä¸¤ç§æƒ…å†µæ˜¯é€»è¾‘è‡ªæ²»çš„ï¼š 1.0å·1å·éƒ½åœ¨è¯´è°ï¼Œ2å·åœ¨è¯´çœŸè¯ 2.0å·1å·éƒ½åœ¨è¯´çœŸè¯ï¼Œ2å·åœ¨è¯´è° æƒ…å†µ1ä¸ºâ€œ0 0 1â€ï¼Œæƒ…å†µ2ä¸ºâ€œ1 1 0â€ï¼Œæ‰€ä»¥è¾“å‡ºå°çš„é‚£ä¸ªâ€œ0 0 1â€ main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdlib&gt; using namespace std;int test [15] = &#123;0&#125;;int ans [15][2] = &#123;0,0&#125;;void dfs(int now,int n)&#123; if( now == n )&#123; int flag=0; for(int i=0 ; i&lt;n ;i++)&#123; if( ans[i][1] == 0 &amp;&amp; test [ ans[i][0] ] == 1 &amp;&amp; test[i] == 1) flag=1; if( ans[i][1] == 1 &amp;&amp; test [ ans[i][0] ] == 0 &amp;&amp; test[i] == 1) flag=1; if( ans[i][1] == 1 &amp;&amp; test [ ans[i][0] ] == 1 &amp;&amp; test[i] == 0) flag=1; if( ans[i][1] == 0 &amp;&amp; test [ ans[i][0] ] == 0 &amp;&amp; test[i] == 0) flag=1; &#125; if(flag == 0)&#123; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; test [i]&lt;&lt;&quot; &quot;; &#125; exit(0); &#125; return; &#125; test[ now ] = 0 ; dfs( now + 1 , n ); test[ now ] = 1; dfs( now + 1, n);&#125;int main()&#123; int n; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; ans[i][0]; cin &gt;&gt; ans[i][1]; &#125; dfs(0,n); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¥ç»ç½‘ç»œç±»","slug":"ç¨‹è®¾/ç¥ç»ç½‘ç»œç±»","date":"2022-05-22T12:10:53.956Z","updated":"2022-06-08T10:07:11.631Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/ç¥ç»ç½‘ç»œç±»/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%B1%BB/","excerpt":"","text":"é¢˜ç›®æè¿° æ·±åº¦ç¥ç»ç½‘ç»œç”±è‹¥å¹²ä¸åŒç±»å‹çš„å±‚ç»„æˆã€‚æ¯ä¸€å±‚å¯ä»¥è§†ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œæ–¹ä¾¿èµ·è§ï¼Œåœ¨æœ¬é¢˜ä¸­æˆ‘ä»¬è®¾å®šæ‰€æœ‰å±‚çš„è¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯é•¿åº¦ä¸º n çš„ä¸€ç»´å‘é‡ï¼Œå³ xâˆˆRnã€‚ä¸ºäº†æ–¹ä¾¿åœ°æ­å»ºæ·±åº¦ç¥ç»ç½‘ç»œï¼Œä½ éœ€è¦å…ˆåœ¨ layer.hpp ä¸­è®¾è®¡ä¸€ä¸ªè¡¨ç¤ºå±‚çš„æŠ½è±¡åŸºç±»Layerï¼Œæ‰€æœ‰å…·ä½“çš„å±‚ç±»å‹éƒ½ç»§æ‰¿è‡ªè¯¥åŸºç±»ï¼Œå¹¶ä¸”æ‰€æœ‰å…·ä½“çš„å±‚ç±»å‹éƒ½è¦æœ‰ä¸€ä¸ª forward æ–¹æ³•ï¼Œç”¨ä»¥è®¡ç®—å‰å‘ç»“æœã€‚åœ¨ linear.hpp ä¸­å·²ç»å®ç°äº†ä¸€ä¸ª Linear å±‚ï¼Œä½ å¯ä»¥å‚è€ƒè¯¥å±‚çš„å®ç°æ¥è®¾è®¡ Layerã€‚Linear å±‚çš„æ•°å­¦å®šä¹‰å¦‚ä¸‹ï¼š Linear(x)=Wx+b å…¶ä¸­ WâˆˆRnÃ—n,bâˆˆRn ä¸ºå‚æ•°ï¼Œåº”å½“åœ¨æ„é€  Linear å±‚æ—¶è¾“å…¥ã€‚ ç„¶åï¼Œä½ éœ€è¦å†åœ¨ conv.hpp ä¸­å®ç°ä¸€ä¸ª Conv å±‚ï¼Œè¯¥å±‚çš„æ•°å­¦å®šä¹‰å¦‚ä¸‹ï¼š \\[Conv_i(x)=\\sum_{j=0}^{2m}k_jX_{iâˆ’m+j}\\] å…¶ä¸­ \\[kâˆˆR^{2m+1}\\] ä¸ºå‚æ•°ï¼Œåº”å½“åœ¨æ„é€  Conv å±‚æ—¶è¾“å…¥ã€‚ ä¾‹å¦‚ï¼Œå½“m=1æ—¶ï¼Œoutputçš„å…¶ä¸­ä¸€ä¸ªç»´åº¦ï¼Œå¦‚output[2]=k[0]âˆ—x[1]+k[1]âˆ—x[2]+k[2]âˆ—x[3]ã€‚ æ³¨æ„è‹¥æœ‰è¶…å‡ºèŒƒå›´çš„éƒ¨åˆ†åˆ™ä¸éœ€è¦è®¡ç®—ï¼Œä¾‹å¦‚*outpu**t[0]=k[1]âˆ—x[0]+k[2]âˆ—x[1]ï¼Œè¿™é‡Œä¸å­˜åœ¨x*[âˆ’1]å°±ä¸ç”¨ç®—å®ƒã€‚ conv.hpp 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;class Conv: public Layer&#123;private: double * K; int n; int m;public: Conv(int a, int b,double * k):n(a),m(b)&#123; K = new double [2*m+1]; memcpy( K , k , (2*m+1) * sizeof(double) ); &#125; void forward(double *input,double *output)const&#123; for(int i=0; i &lt; n ;i++)&#123; double sum = 0; for(int j=0; j&lt;2*m +1; j++)&#123; if(i-m+j &lt; 0 ) continue; if(i-m+j &gt;= n ) continue; sum += K[j] * input [ i- m +j ]; &#125; output[i] = sum; sum = 0; &#125; &#125; ~Conv()&#123; delete [] K; &#125;&#125;; layer.hpp 12345678910111213141516171819202122#ifndef LAYER_H_#define LAYER_H_ #include &lt;iostream&gt;#include &lt;iomanip&gt;class Layer&#123;public: virtual void forward(double * const input, double * output)const = 0; virtual ~Layer()&#123;&#125;;&#125;;#endif linear.h(lock) 123456789101112131415161718192021222324252627#pragma once#include &quot;layer.hpp&quot;#include &quot;new_tensor.hpp&quot;class Linear: public Layer &#123;private: double const * const * const _W; double const * const _b; const int _n;public: Linear(int n, double * const * const W, double * const b): _W(new_tensor_2d(n, W)), _b(new_tensor_1d(n, b)), _n(n) &#123;&#125; void forward(double * const input, double * output) const &#123; for (int i = 0; i &lt; _n; ++i) &#123; output[i] = _b[i]; for (int j = 0; j &lt; _n; ++j) output[i] += _W[i][j] * input[j]; &#125; &#125; ~Linear() &#123; delete[] _b; for (int i = 0; i &lt; _n; ++i) delete[] _W[i]; delete[] _W; &#125;&#125;; main.cpp(lock) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &quot;layer.hpp&quot;#include &quot;linear.hpp&quot;#include &quot;conv.hpp&quot;int main() &#123; int d, n, m, type_mark; double **W, *b, *k; std::cin &gt;&gt; d &gt;&gt; n; Layer ** layers = new Layer * [d]; W = new double * [n]; b = new double [n]; k = new double [n]; for (int i = 0; i &lt; n; ++i) W[i] = new double [n]; for (int i = 0; i &lt; d; ++i) &#123; std::cin &gt;&gt; type_mark; if (type_mark == 0) &#123; // Linear for (int x = 0; x &lt; n; ++x) for (int y = 0; y &lt; n; ++y) std::cin &gt;&gt; W[x][y]; for (int x = 0; x &lt; n; ++x) std::cin &gt;&gt; b[x]; layers[i] = new Linear(n, W, b); &#125; else &#123; // Conv std::cin &gt;&gt; m; for (int x = 0; x &lt; 2*m+1; ++x) std::cin &gt;&gt; k[x]; layers[i] = new Conv(n, m, k); &#125; &#125; double * x = new double [n]; double ** y = new double * [d]; for (int i = 0; i &lt; d; ++i) y[i] = new double [n]; int T; std::cout &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setprecision(2); for (std::cin &gt;&gt; T; T &gt; 0; --T) &#123; for (int i = 0; i &lt; n; ++i) std::cin &gt;&gt; x[i]; layers[0]-&gt;forward(x, y[0]); for (int i = 1; i &lt; d; ++i) layers[i]-&gt;forward(y[i-1], y[i]); for (int i = 0; i &lt; n-1; ++i) std::cout &lt;&lt; y[d-1][i] &lt;&lt; &#x27; &#x27;; std::cout &lt;&lt; y[d-1][n-1] &lt;&lt; std::endl; &#125; for (int i = 0; i &lt; d; ++i) &#123; delete layers[i]; delete [] y[i]; &#125; delete [] layers; delete [] y; for (int i = 0; i &lt; n; ++i) delete [] W[i]; delete [] W; delete [] b; delete [] k; delete [] x; return 0;&#125; new_tensor.hpp(lock) 1234567891011121314151617#pragma once#include &lt;cstring&gt;double * new_tensor_1d(int n, double * const source) &#123; double * target = new double[n]; memcpy(target, source, n * sizeof(double)); return target;&#125;double * const * new_tensor_2d(int n, double * const * const source) &#123; double * * target = new double * [n]; for (int i = 0; i &lt; n; ++i) &#123; target[i] = new_tensor_1d(n, source[i]); &#125; return target;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"é“¾è¡¨","slug":"ç¨‹è®¾/é“¾è¡¨","date":"2022-05-22T12:09:33.144Z","updated":"2022-05-22T12:10:41.542Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/é“¾è¡¨/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"é¢˜ç›®æè¿° è¯·åœ¨ orderedList.hpp ä¸­å®šä¹‰ä»¥ä¸‹ä¸‰ä¸ªç±»ï¼š æŠ½è±¡ åŸºç±» 1OrderedList ï¼Œè¡¨ç¤ºä¸€ä¸ªæ•´æ•°é“¾è¡¨ï¼Œæœ‰ä»¥ä¸‹æ–¹æ³•ï¼š æ„é€ å‡½æ•°ï¼šæ— å‚æ•°ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„é“¾è¡¨ï¼› void insert(int val) å‘é“¾è¡¨ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œåœ¨ OrderedList ä¸­è¯¥æ–¹æ³•åº”å½“ä¸ºçº¯è™šå‡½æ•°ï¼› void printList() const ä¾æ¬¡åœ¨å±å¹•ä¸Šè¾“å‡ºé“¾è¡¨ä¸­çš„å…ƒç´ ï¼Œå…ƒç´ ä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ï¼Œè¾“å‡ºå®Œæ•´ä¸ªé“¾è¡¨åæ¢è¡Œï¼› ææ„å‡½æ•°ï¼šé‡Šæ”¾é“¾è¡¨æ‰€å ç”¨çš„ç©ºé—´ã€‚ å…·ä½“ç±» AscendOrderedListï¼Œè¡¨ç¤ºä¸€ä¸ªå‡åºçš„é“¾è¡¨ï¼Œç»§æ‰¿è‡ª OrderedListï¼Œéœ€è¦é‡è½½ void insert(int val) å‡½æ•°æ¥å®ç°å‡åºã€‚ å…·ä½“ç±» DescendOrderedListï¼Œè¡¨ç¤ºä¸€ä¸ªé™åºçš„é“¾è¡¨ï¼Œç»§æ‰¿è‡ª OrderedListï¼Œéœ€è¦é‡è½½ void insert(int val) å‡½æ•°æ¥å®ç°é™åºã€‚ main.cpp(lock) 12345678910111213141516171819#include &lt;iostream&gt;#include &quot;orderedList.hpp&quot;int main() &#123; int n, x; OrderedList * a = new AscendOrderedList, * d = new DescendOrderedList; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; x; a-&gt;insert(x); d-&gt;insert(x); &#125; a-&gt;printList(); d-&gt;printList(); delete a; delete d; return 0;&#125; orderlist.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;using namespace std;class node&#123;public: int data; node * Node; node()&#123; Node = NULL; &#125; node(int a)&#123; data = a; Node = NULL; &#125; // node(int a, node * b): data(a)&#123; // node* temp = b; // while(temp-&gt;Node != NULL)&#123; // temp = temp -&gt; Node; // &#125; // &#125;&#125;;class OrderedList&#123;public: node* head; OrderedList()&#123; head = new node (); &#125; virtual void insert(int val) = 0; void printList()const&#123; node* temp = head; if(temp -&gt; Node == NULL) return; else &#123; temp = temp -&gt; Node; &#125; while(temp != NULL)&#123; cout&lt;&lt;temp -&gt; data &lt;&lt; &quot; &quot;; temp = temp -&gt; Node; &#125; cout&lt;&lt;endl; &#125; virtual ~OrderedList()&#123; node * temp = head; while(temp -&gt; Node != NULL)&#123; node* a = temp; temp = temp -&gt; Node; delete a; &#125; delete temp; &#125;&#125;;class AscendOrderedList : public OrderedList&#123; public: void insert(int val)&#123; node* temp = head; if(temp -&gt; Node == NULL)&#123; temp -&gt; Node = new node (val); return ; &#125; temp = temp -&gt; Node; while(temp -&gt;data &lt;= val &amp;&amp; temp -&gt; Node != NULL )&#123; temp = temp -&gt; Node; &#125; if( temp -&gt; data &gt; val )&#123; node* a = head; while(a-&gt;Node != temp)&#123; a = a -&gt;Node; &#125; a-&gt;Node = new node (val); a-&gt;Node-&gt;Node = temp; return ; &#125; if( temp -&gt; Node == NULL )&#123; temp -&gt; Node = new node (val); return ; &#125; &#125;&#125;;class DescendOrderedList : public OrderedList&#123;public: void insert(int val)&#123; node* temp = head; if(temp -&gt; Node == NULL)&#123; temp -&gt; Node = new node (val); return ; &#125; temp = temp -&gt; Node; while(temp -&gt;data &gt;= val &amp;&amp; temp -&gt; Node != NULL )&#123; temp = temp -&gt; Node; &#125; if( temp -&gt; data &lt; val )&#123; node* a = head; while(a-&gt;Node != temp)&#123; a = a -&gt;Node; &#125; a-&gt;Node = new node (val); a-&gt;Node-&gt;Node = temp; return ; &#125; if( temp -&gt; Node == NULL )&#123; temp -&gt; Node = new node (val); return ; &#125; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"å¤šæ€","slug":"ç¨‹è®¾/å¤šæ€","date":"2022-05-22T12:07:59.961Z","updated":"2022-05-22T12:08:51.376Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/å¤šæ€/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E5%A4%9A%E6%80%81/","excerpt":"","text":"Description Design a class named Person and its two derived classes namedStudent and Employee. Make Faculty and Staff derived classes of Employee. Person class has the following members: 1234string name;string address;string phoneNumber;string email; Student class has the following members: 12enum class_status&#123;frssman,sophomore,junior,senior&#125;; class_status status; Employee class has the following members: 123string office;int salary;MyDate dateHired; Faculty class has the following members: 12string officeHours;int rank; Staff class has the following members: 1string title; MyDate class contains the following members: 123int year;int month;int day; Override the toString function in each class to display the class name. For example, in Employee class: 1234string toString() const&#123; return &quot;Employee&quot;;&#125; Make sure that the following code: 123456789101112131415void f(const Person &amp;p)&#123; cout &lt;&lt; p.toString() &lt;&lt; endl;&#125;Person person;Student student;Employee employee;Faculty faculty;Staff staff;f(person);f(student);f(employee);f(faculty);f(staff); outputs: 12345PersonStudentEmployeeFacultyStaff source.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person&#123;public: string name; string address; string phoneNumber; string email; virtual string toString() const &#123; return &quot;Person&quot;; &#125;&#125;;class Student: public Person&#123;public: enum class_status&#123;frssman,sophomore,junior,senior&#125;; class_status status; virtual string toString() const &#123; return &quot;Student&quot;; &#125;&#125;;class MyDate&#123;public: int year; int month; int day;&#125;;class Employee: public Person&#123;public: string office; int salary; MyDate dateHired; virtual string toString() const &#123; return &quot;Employee&quot;; &#125;&#125;;class Faculty: public Employee&#123;public: string officeHours; int rank; virtual string toString() const &#123; return &quot;Faculty&quot;; &#125;&#125;;class Staff : public Employee&#123;public: string title; virtual string toString() const &#123; return &quot;Staff&quot;; &#125;&#125;; framework.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;source.h&quot;using namespace std;void f1(Person p)&#123; cout &lt;&lt; p.toString() &lt;&lt; endl;&#125;void f2(Employee e)&#123; cout &lt;&lt; e.toString() &lt;&lt; endl;&#125;void f(const Person &amp;p)&#123; cout &lt;&lt; p.toString() &lt;&lt; endl;&#125;int main()&#123; Person person; Student student; Employee employee; Faculty faculty; Staff staff; f1(person); f1(student); f1(employee); f1(faculty); f1(staff); f2(employee); f2(faculty); f2(staff); f(person); f(student); f(employee); f(faculty); f(staff); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"è™šå‡½æ•°","slug":"ç¨‹è®¾/è™šå‡½æ•°","date":"2022-05-22T12:06:35.792Z","updated":"2022-05-31T12:16:12.818Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/è™šå‡½æ•°/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E8%99%9A%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++:Instance of Description åœ¨Javaè¯­è¨€é‡Œè¾¹ï¼Œæ‰€æœ‰çš„å¯¹è±¡éƒ½ä¼šç»§æ‰¿Objectç±»ï¼Œä½†C++å´æ˜¯æ²¡æœ‰çš„ ä¾‹å¦‚ä»¥ä¸‹çš„ä¸€äº›ç±»ï¼š class Object; class Animal:public Object; class Dog:public Animal; class Cat:public Animal; class Vehicle:public Object; class Bus:public Vehicle; class Car:public Vehicle; class Person:public Object; class Student:public Person; class Teacher:public Person; æˆ‘ä»¬çŸ¥é“å¯¹è±¡æ˜¯å¯ä»¥å‘ä¸Šå‘ä¸‹è½¬å‹çš„ï¼Œå°±ä¾‹å¦‚ Animal* animal = new Dog(); å› ä¸ºç»§æ‰¿æœ¬èº«å°±æ˜¯ä¸€ç§is-açš„å…³ç³»ï¼Œç‹—å°±æ˜¯åŠ¨ç‰©ï¼Œå› æ­¤è¿™æ ·èµ‹å€¼æ˜¯æ²¡é—®é¢˜çš„ã€‚ ä½†æ˜¯é—®é¢˜æ¥äº†ã€‚å€˜è‹¥åˆ«äººä¼ é€’ä¸Šè¿°ä»£ç çš„animalå¯¹è±¡ç»™ä½ ï¼Œä½ è¿™ä¸ªæ—¶å€™å´ä¸çŸ¥é“å®ƒåŸæœ¬æ˜¯Dogè¿™ä¸ªç±»çš„ï¼ˆåœ¨Javaé‡Œè¾¹æ˜¯æœ‰instance of å¯ä»¥åˆ¤æ–­çš„ï¼‰ï¼Œäºæ˜¯ç°åœ¨ä½ çš„ä»»åŠ¡æ¥äº†ã€‚ è¯·å®Œæˆä»¥ä¸‹å‡½æ•°ä»¥åŠç±»ï¼Œä½¿å¾—æ»¡è¶³instanceofå‡½æ•°å¯ä»¥è¿”å›è¯¥å¯¹è±¡çš„ç±»å‹åå­—ã€‚ï¼ˆæ³¨æ„è¿™é‡Œçš„ç±»å…¨éƒ¨éƒ½è¿˜æ²¡å®šä¹‰ï¼Œä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„æ€è·¯å»å®Œæˆå®šä¹‰ï¼Œå®Œæˆçš„æ–¹æ³•ä¸é™ï¼Œèƒ½ACå³å¯ï¼‰ 123456789101112131415161718192021222324252627282930class Object;class Animal:public Object;class Dog:public Animal;class Cat:public Animal;class Vehicle:public Object;class Bus:public Vehicle;class Car:public Vehicle;class Person:public Object;class Student:public Animal;class Teacher:public Animal;/** ä¸€ä¸ªObjectå¯¹è±¡* è¿”å›è¿™ä¸ªå¯¹è±¡å®ä¾‹å®é™…çš„ç±»å‹å* ä¾‹å¦‚ï¼š Object *obj = new Bus();* åˆ™instanceof(*obj) == &quot;Bus&quot;*/string instanceof(Object obj); Input N/A Output N/A Sample_Input 123456æ ·ä¾‹æµ‹è¯•: Object *obj = new Dog(); cout &lt;&lt; instanceof(*obj) &lt;&lt; endl; Object *obj = new Car(); cout &lt;&lt; instanceof(*obj) &lt;&lt; endl; Sample_Ouput 12DogCar Hint æ— éœ€æäº¤ä¸»å‡½æ•°ï¼ framework.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;source.h&quot;using namespace std;int main()&#123; Object *obj = new Dog(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Animal(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Car(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Bus(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Cat(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Vehicle(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Teacher(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Person(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Student(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; obj = new Object(); cout &lt;&lt; instanceof (*obj) &lt;&lt; endl; delete obj; return 0;&#125; source.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Object&#123;public: string a; Object():a(&quot;Object&quot;)&#123;&#125; Object(string b):a(b)&#123;&#125; virtual ~Object()&#123;&#125;&#125;;class Animal:public Object&#123;public: Animal():Object(&quot;Animal&quot;)&#123;&#125; Animal(string a):Object(a)&#123; &#125;&#125;;class Dog:public Animal&#123;public: Dog():Animal(&quot;Dog&quot;)&#123;&#125;&#125;;class Cat:public Animal&#123;public: Cat():Animal(&quot;Cat&quot;)&#123;&#125;&#125;;class Vehicle:public Object&#123;public: Vehicle():Object(&quot;Vehicle&quot;)&#123;&#125; Vehicle(string a):Object(a)&#123;&#125;&#125;;class Bus:public Vehicle&#123;public: Bus():Vehicle(&quot;Bus&quot;)&#123;&#125;&#125;;class Car:public Vehicle&#123;public: Car():Vehicle(&quot;Car&quot;)&#123;&#125;&#125;;class Person:public Object&#123;public: Person():Object(&quot;Person&quot;)&#123;&#125; Person(string a):Object(a)&#123;&#125;&#125;;class Student:public Person&#123;public: Student():Person(&quot;Student&quot;)&#123;&#125;&#125;;class Teacher:public Person&#123;public: Teacher():Person(&quot;Teacher&quot;)&#123;&#125;&#125;;/** ä¸€ä¸ªObjectå¯¹è±¡* è¿”å›è¿™ä¸ªå¯¹è±¡å®ä¾‹å®é™…çš„ç±»å‹å* ä¾‹å¦‚ï¼š Object *obj = new Bus();* åˆ™instanceof(*obj) == &quot;Bus&quot;*/string instanceof(Object&amp; obj)&#123; return obj.a;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"æŠ½è±¡ç±»","slug":"ç¨‹è®¾/æŠ½è±¡ç±»","date":"2022-05-22T12:04:52.255Z","updated":"2022-05-22T12:06:00.492Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/æŠ½è±¡ç±»/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"Description å£°æ˜ä¸€ä¸ªShapeæŠ½è±¡ç±»ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šæ´¾ç”Ÿå‡ºRectangleç±»å’ŒCircleç±»ï¼Œä¸¤è€…éƒ½æœ‰GetAreaï¼ˆï¼‰å’ŒGetPerimï¼ˆï¼‰å‡½æ•°ï¼Œç”¨æ¥è®¡ç®—é¢ç§¯å’Œå‘¨é•¿ï¼Œéº»çƒ¦å°è£…ä»¥ä¸Šå„ç±»ï¼Œç¼–å†™ç¨‹åºã€‚éœ€è¦æäº¤ç±»shapeã€Rectangleã€Cricleç±» Input ç¬¬ä¸€è¡Œè¾“å…¥nï¼Œè¡¨ç¤ºnä¸ªæµ‹è¯•ä¾‹å­ï¼›æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œæ¯ä¸€è¡Œè¾“å…¥æ•°ï¼Œaã€bã€cï¼Œè¡¨ç¤ºçŸ©å½¢çš„å®½ã€é•¿ï¼Œä»¥åŠåœ†å½¢çš„åŠå¾„ Output å¯¹åº”æ¯ä¸€è¡Œè¾“å…¥ï¼š ç¬¬ä¸€è¡Œè¾“å‡ºçŸ©å½¢çš„é¢ç§¯ã€å‘¨é•¿ ç¬¬äºŒè¡Œè¾“å‡ºåœ†å½¢çš„é¢ç§¯ã€å‘¨é•¿ Sample_Input 1212 2 3 Sample_Ouput 124 828.26 18.84 Hint const double PI = 3.14ï¼› (Already defined) framework.cpp 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const double PI = 3.14;#include &quot;source.h&quot;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); double n,a,b,c; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; Shape *s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; s = new Rectangle(a,b); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; s = new Circle(c); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; &#125; return 0;&#125; source.h 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Shape&#123;public: virtual double GetArea() = 0; virtual double GetPerim() = 0;&#125;;class Rectangle :public Shape&#123;public: double wid; double leng; Rectangle(double a,double b):wid(a),leng(b)&#123;&#125; double GetArea()&#123; return wid*leng; &#125; double GetPerim()&#123; return 2*(wid+leng); &#125; &#125;;class Circle :public Shape&#123;public: double rad; Circle(double a):rad(a)&#123;&#125; double GetArea()&#123; return rad*rad*PI; &#125; double GetPerim()&#123; return 2*PI*rad; &#125; &#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ä¼ å‚","slug":"ç¨‹è®¾/è®¿é—®æ§åˆ¶","date":"2022-05-22T12:00:26.283Z","updated":"2022-05-22T12:04:37.497Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/è®¿é—®æ§åˆ¶/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","excerpt":"","text":"Description å†™å‡º3ç»„Pluså‡½æ•°çš„å£°æ˜ä¸å®ç°ï¼Œç±»å‹åˆ†åˆ«ä¸ºintï¼Œdoubleï¼Œstringã€‚ ä¸»å‡½æ•°å¦‚ä¸‹ï¼Œæ³¨æ„åªéœ€è¦å®ç°Pluså‡½æ•°å’ŒåŒ…å«ç›¸å…³çš„å¤´æ–‡ä»¶ã€‚ 1234567891011121314151617int main() &#123; int n; int a,b; double c,d; std::string str1,str2; std::cin&gt;&gt;n; while(n--) &#123; std::cin &gt;&gt; a &gt;&gt; b ; std::cin &gt;&gt; c &gt;&gt; d; std::cin &gt;&gt; str1 &gt;&gt; str2; std::cout &lt;&lt; myplus(a, b) &lt;&lt; endl; std::cout &lt;&lt; myplus(d, c) &lt;&lt; endl; std::cout &lt;&lt; myplus(str1, str2) &lt;&lt; endl; &#125; return 0;&#125; Sample Input 123412 32.5 3.5women day Sample Output 12356womenday Hint PSï¼šPlease add std:: before using the string type. framework.cpp(lock) 1234567891011121314#include&lt;iostream&gt;using namespace std;int myplus(int a, int b)&#123; return a+b;&#125;double myplus(double a, double b)&#123; return a+b;&#125;std::string myplus(const std::string&amp; a, const std::string&amp; b)&#123; return a+b;&#125; source.h 1234567891011121314#include&lt;iostream&gt;using namespace std;int myplus(int a, int b)&#123; return a+b;&#125;double myplus(double a, double b)&#123; return a+b;&#125;std::string myplus(const std::string&amp; a, const std::string&amp; b)&#123; return a+b;&#125; Description As shown in the following code segment, op is an object of class Number. Please implement Number in which you should: write the member functions of add and sub with one int parameter respectively. write a constructor with one int parameter. write a print function to print the result. Number op(1); op.add(2).sub(3).add(4) op.print(); // outputï¼š4 Input Output Sample_Input 1234Sample Test Number n(1); n.add(2).sub(3).add(4); n.print(); Sample_Ouput 14 Hint framework.cpp 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &quot;source.h&quot;using namespace std;int main()&#123; Number n(1); n.add(2).sub(3).add(4); n.print(); Number n1(-1); n1.sub(12).sub(3).sub(4); n1.print(); Number n2(0); n2.add(-13).add(0).add(0); n2.add(13); n2.print(); return 0;&#125; source.h 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Number&#123;private: int n;public: Number(int a)&#123; n=a; &#125; Number&amp; add(int a)&#123; n+=a; return *this; &#125; Number&amp; sub(int a)&#123; n-=a; return *this; &#125; void print()&#123; cout&lt;&lt;n&lt;&lt;endl; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Tiger and cat","slug":"ç¨‹è®¾/Tiger and cat","date":"2022-05-22T11:59:00.673Z","updated":"2022-05-22T12:00:21.299Z","comments":true,"path":"2022/05/22/ç¨‹è®¾/Tiger and cat/","link":"","permalink":"http://example.com/2022/05/22/%E7%A8%8B%E8%AE%BE/Tiger%20and%20cat/","excerpt":"","text":"çŒ«ç§‘åŠ¨ç‰©å’Œè€è™ Description ä¸‹é¢æ˜¯ä¸å®Œæ•´çš„ç»§æ‰¿ç±»å®šä¹‰ï¼Œ 12345678910111213class Cat&#123; int data;public: Cat();&#125;;class Tiger : public Cat&#123; int data;public: Tiger(int);&#125;; è¯•å®Œæˆå…¶å®šä¹‰(ä½ å¯ä»¥æ ¹æ®éœ€è¦å¢åŠ å¿…è¦çš„æ„é€ å‡½æ•°å’Œææ„å‡½æ•°)ï¼Œä½¿å¾—ä¸»å‡½æ•°mainè¿è¡Œåèƒ½å¾—åˆ°å…¶åç»“æœï¼š 12345678int main()&#123; Cat bc; Tiger dc(6); Tiger dc1(18); return 0;&#125; è¿è¡Œç»“æœï¼š Default Constructor of Cat is Running Constructor of Cat is Running 6 Constructor of Tiger is Running 6 Constructor of Cat is Running 18 Constructor of Tiger is Running 18 Destructor of Tiger is Running 18 Destructor of Cat is Running 18 Destructor of Tiger is Running 6 Destructor of Cat is Running 6 Destructor of Cat is Running 0 framework.cpp 1234567891011121314#include &lt;iostream&gt;using namespace std;#include &quot;source.h&quot;int main()&#123; Tiger t1(9); Cat c1; Tiger t2(25); return 0;&#125; source.h 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class Cat&#123; int data;public: Cat():data(0)&#123; cout&lt;&lt;&quot;Default Constructor of Cat is Running&quot;&lt;&lt;endl; &#125; Cat(int a):data(a)&#123; cout&lt;&lt;&quot;Constructor of Cat is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125; ~Cat()&#123; cout&lt;&lt;&quot;Destructor of Cat is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125;&#125;;class Tiger : public Cat&#123; int data;public: Tiger(int a):Cat(a),data(a)&#123; cout&lt;&lt;&quot;Constructor of Tiger is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125; ~Tiger()&#123; cout&lt;&lt;&quot;Destructor of Tiger is Running &quot;&lt;&lt;data&lt;&lt;endl; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"time(ç»§æ‰¿)","slug":"ç¨‹è®¾/time","date":"2022-05-14T09:26:42.205Z","updated":"2022-05-14T10:45:11.513Z","comments":true,"path":"2022/05/14/ç¨‹è®¾/time/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/time/","excerpt":"","text":"Description éœ€è¦å®ç°çš„æ˜¯ä¸€ä¸‹ä¸¤ä¸ªç±»ï¼Œtimeä½œä¸ºçˆ¶ç±»ï¼ŒExtTimeä½œä¸ºå­ç±»ï¼Œä»¥ä¸‹æ˜¯ä¸¤ä¸ªç±»çš„å£°æ˜ï¼Œä½ éœ€è¦åšçš„æ˜¯ï¼Œå®ç°è¿™ä¸¤ä¸ªç±»ã€‚ 123456789101112131415161718192021222324252627class Time&#123; public : void Set ( int hours , int minutes , int seconds ) ; void Increment ( ) ; void Write ( ) const ; Time ( int initHrs, int initMins, int initSecs ) ; // constructor Time ( ) ; // default constructorprivate : int hrs ; int mins ; int secs ;&#125; class ExtTime : public Time // Time is the base class&#123;public : ExtTime ( int initHrs , int initMins , int initSecs , ZoneType initZone ) ; // constructor ExtTime ( ) ; // default constructor void Set ( int hours, int minutes, int seconds , ZoneType timeZone ) ; void Write ( ) const ; private : ZoneType zone ; // added data member&#125; ; Sample Output 1234567891011121314151617time1: 05:30:00 CDTtime2: 00:00:00 ESTNew time2: 23:59:55 PSTIncrementing time2:23:59:55 PST23:59:56 PST23:59:57 PST23:59:58 PST23:59:59 PST00:00:00 PST00:00:01 PST00:00:02 PST00:00:03 PST00:00:04 PSTtime3: 01:02:0303:04:05 main.cpp(lock) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &quot;ExtTime.h&quot; //ç¨‹åº4_4#include &quot;Time.h&quot;using namespace std;int main()&#123; ExtTime time1(5, 30, 0, CDT); ExtTime time2; int count; cout &lt;&lt; &quot;time1: &quot;; time1.Write(); cout &lt;&lt; endl; cout &lt;&lt; &quot;time2: &quot;; time2.Write(); cout &lt;&lt; endl; time2.Set(23, 59, 55, PST); cout &lt;&lt; &quot;New time2: &quot;; time2.Write(); cout &lt;&lt; endl; cout &lt;&lt; &quot;Incrementing time2:&quot; &lt;&lt; endl; for (count = 1; count &lt;= 10; count++) &#123; time2.Write(); cout &lt;&lt; endl; time2.Increment(); &#125; Time time3(1,2,3); cout &lt;&lt; &quot;time3: &quot;; time3.Write(); cout &lt;&lt; endl &lt;&lt; endl; time1.Time::Set(3,4,5); time1.Time::Write(); cout &lt;&lt; endl; return 0;&#125; ExtTime.h(lock) 12345678910111213141516171819202122#ifndef ExtTime_H#define ExtTime_H#include &quot;Time.h&quot;enum ZoneType &#123;EST, CST, MST, PST, EDT, CDT, MDT, PDT &#125; ;class ExtTime : public Time // Time is the base class&#123;public : ExtTime ( int initHrs , int initMins , int initSecs , ZoneType initZone ) ; // constructor ExtTime ( ) ; // default constructor void Set ( int hours, int minutes, int seconds , ZoneType timeZone ) ; void Write ( ) const ; private : ZoneType zone ; // added data member&#125; ;#endif Time.h 12345678910111213141516171819202122#ifndef Time_H#define Time_H#include &lt;iostream&gt;using namespace std;class Time&#123;public: void Set(int hours, int minutes, int seconds); void Increment(); void Write() const; Time(int initHrs, int initMins, int initSecs); // constructor Time(); // default constructorprivate: int hrs; int mins; int secs;&#125;;#endif Time.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;Time.h&quot;#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;Time::Time( int initHrs, int initMins, int initSecs )&#123; hrs = initHrs; mins = initMins; secs = initSecs;&#125;Time::Time()&#123; hrs = 0; mins = 0; secs = 0;&#125;void Time::Set( int hours, int minutes, int seconds )&#123; hrs = hours; mins = minutes; secs = seconds;&#125;void Time::Increment() // IMPLEMENTATION FILE ( time.cpp )&#123; secs++; if (secs &gt; 59) &#123; secs = 0; mins++; if (mins &gt; 59) &#123; mins = 0; hrs++; if (hrs &gt; 23) hrs = 0; &#125; &#125;&#125;void Time::Write() const&#123; if (hrs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; hrs &lt;&lt; &quot;:&quot;; if (mins &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; mins &lt;&lt; &quot;:&quot;; if (secs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; secs;&#125; ExtTime.cpp 1234567891011121314151617181920212223242526#include&quot;Time.h&quot;#include&lt;iomanip&gt;void Time::Set(int hours, int minutes, int seconds)&#123; hrs = hours; mins = minutes; secs = seconds;&#125;void Time::Increment()&#123; secs++; if(secs == 60)&#123; secs = 0; mins++; if(mins == 60)&#123; mins = 0; hrs++; if(hrs == 24)&#123; hrs = 0; &#125; &#125; &#125;&#125;void Time::Write() const&#123; cout &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;)&lt;&lt; hrs &lt;&lt; &#x27;:&#x27; &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;)&lt;&lt; mins &lt;&lt; &#x27;:&#x27; &lt;&lt; setw(2) &lt;&lt; setfill(&#x27;0&#x27;)&lt;&lt; secs;&#125;Time::Time(int initHrs, int initMins, int initSecs):hrs(initHrs), mins(initMins), secs(initSecs)&#123;&#125;Time::Time():hrs(0), mins(0), secs(0)&#123;&#125; å‚è€ƒç­”æ¡ˆ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;Time.h&quot;#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;Time::Time( int initHrs, int initMins, int initSecs )&#123; hrs = initHrs; mins = initMins; secs = initSecs;&#125;Time::Time()&#123; hrs = 0; mins = 0; secs = 0;&#125;void Time::Set( int hours, int minutes, int seconds )&#123; hrs = hours; mins = minutes; secs = seconds;&#125;void Time::Increment() // IMPLEMENTATION FILE ( time.cpp )&#123; secs++; if (secs &gt; 59) &#123; secs = 0; mins++; if (mins &gt; 59) &#123; mins = 0; hrs++; if (hrs &gt; 23) hrs = 0; &#125; &#125;&#125;void Time::Write() const&#123; if (hrs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; hrs &lt;&lt; &quot;:&quot;; if (mins &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; mins &lt;&lt; &quot;:&quot;; if (secs &lt; 10) cout &lt;&lt; &quot;0&quot;; cout &lt;&lt; secs;&#125; 123456789101112131415161718192021222324252627282930313233343536#include &quot;ExtTime.h&quot;#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;ExtTime::ExtTime( int initHrs, int initMins, int initSecs, ZoneType initZone ) : Time(initHrs, initMins, initSecs)&#123; zone = initZone;&#125;ExtTime::ExtTime()&#123; zone = EST;&#125;void ExtTime::Set( int hours, int minutes, int seconds, ZoneType timeZone )&#123; Time::Set(hours, minutes, seconds); //è°ƒç”¨åŸºç±»å‡½æ•°ã€‚Why? zone = timeZone;&#125;void ExtTime::Write() const&#123; static string zoneString[8] = &#123; &quot;EST&quot;, &quot;CST&quot;, &quot;MST&quot;, &quot;PST&quot;, &quot;EDT&quot;, &quot;CDT&quot;, &quot;MDT&quot;, &quot;PDT&quot; &#125;; Time::Write(); cout &lt;&lt; &quot; &quot; &lt;&lt; zoneString[zone];&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"shape(å¤šæ€)","slug":"ç¨‹è®¾/shape(å¤šæ€)","date":"2022-05-14T09:17:11.258Z","updated":"2022-05-14T09:25:52.529Z","comments":true,"path":"2022/05/14/ç¨‹è®¾/shape(å¤šæ€)/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/shape(%E5%A4%9A%E6%80%81)/","excerpt":"","text":"Description å£°æ˜ä¸€ä¸ªShapeæŠ½è±¡ç±»ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šæ´¾ç”Ÿå‡ºRectangleç±»å’ŒCircleç±»ï¼Œä¸¤è€…éƒ½æœ‰GetArea()å’ŒGetPerim()å‡½æ•°ï¼Œç”¨æ¥è®¡ç®—é¢ç§¯å’Œå‘¨é•¿ï¼Œéº»çƒ¦å°è£…ä»¥ä¸Šå„ç±»ï¼Œç¼–å†™ç¨‹åºã€‚éœ€è¦æäº¤ç±»Shapeã€Rectangleã€Cricleã€‚ ä»¥ä¸‹æ˜¯ä¸»å‡½æ•°ï¼š 1234567891011121314151617int main ()&#123; double n,a,b,c; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; Shape *s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; s = new Rectangle(a,b); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; s = new Circle(c); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; &#125; return 0;&#125; Input ç¬¬ä¸€è¡Œè¾“å…¥nï¼Œè¡¨ç¤ºnä¸ªæµ‹è¯•ä¾‹å­ï¼›æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œæ¯ä¸€è¡Œè¾“å…¥æ•°aã€bã€cï¼Œè¡¨ç¤ºçŸ©å½¢çš„å®½ã€é•¿ï¼Œä»¥åŠåœ†å½¢çš„åŠå¾„ã€‚ è¾“å…¥å¤„ç†å·²ç»ç”±æ¡†æ¶ä»£ç å¤„ç†ï¼Œä½ æ— éœ€å¦å¤–å¤„ç†ã€‚ Output å¯¹åº”æ¯ä¸€è¡Œè¾“å…¥ï¼š ç¬¬ä¸€è¡Œè¾“å‡ºçŸ©å½¢çš„é¢ç§¯ã€å‘¨é•¿ï¼› ç¬¬äºŒè¡Œè¾“å‡ºåœ†å½¢çš„é¢ç§¯ã€å‘¨é•¿ã€‚ è¾“å‡ºå¤„ç†å·²ç»ç”±æ¡†æ¶ä»£ç å¤„ç†ï¼Œä½ æ— éœ€å¦å¤–å¤„ç†ã€‚ Sample Input 1212 2 3 Sample Output 124 828.26 18.84 Hint æˆ‘ä»¬å·²ç»ä¸ºä½ å®šä¹‰äº†åœ†å‘¨ç‡PIï¼Œè¯·å‹¿ä½¿ç”¨å…¶ä»–æ•°å€¼ã€‚ 1const double PI = 3.14; framework.cpp(lock) 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;const double PI = 3.14;#include &quot;source.h&quot;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); double n,a,b,c; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; Shape *s; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; s = new Rectangle(a,b); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; s = new Circle(c); cout&lt;&lt;s-&gt;GetArea()&lt;&lt;&quot; &quot;&lt;&lt;s-&gt;GetPerim()&lt;&lt;endl; delete s; &#125; return 0;&#125; source.h 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class Shape &#123; public: virtual double GetArea() &#123;&#125;; virtual double GetPerim() &#123;&#125;;&#125;;class Rectangle: public Shape &#123; private: double length; double height; public: Rectangle(double l, double h) &#123; length = l; height = h; &#125; virtual double GetArea() &#123; return length * height; &#125; virtual double GetPerim() &#123; return 2*(length + height); &#125;&#125;;class Circle: public Shape &#123; private: double radius; public: Circle(double r) &#123; radius = r; &#125; virtual double GetArea() &#123; return 3.14 * radius * radius; &#125; virtual double GetPerim() &#123; return 6.28 * radius; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"å¤šæ€","slug":"ç¨‹è®¾/å¤šæ€(æ·˜å®æ’åº)","date":"2022-05-14T08:56:26.672Z","updated":"2022-05-14T08:58:27.293Z","comments":true,"path":"2022/05/14/ç¨‹è®¾/å¤šæ€(æ·˜å®æ’åº)/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/%E5%A4%9A%E6%80%81(%E6%B7%98%E5%AE%9D%E6%8E%92%E5%BA%8F)/","excerpt":"","text":"Description Feng Goré™¤äº†æ˜¯ä¸ªæˆ¿åœ°äº§å•†å¤–ï¼Œåƒå¤§å¤šæ•°å¥³ç”Ÿä¸€æ ·ï¼Œå¥¹ä¹Ÿæ˜¯å–œæ¬¢é€›æ·˜å®çš„ã€‚æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œåœ¨æ·˜å®ä¸Šæœ‰å¾ˆå¤šå¾ˆå¤šçš„å•†å“ã€‚å½“ç„¶ï¼ŒFeng GoræŒ‘çš„ä¸€èˆ¬éƒ½æ˜¯æœ€è´µçš„ï¼Œä½†æ˜¯å¶å°”ä¹Ÿæ˜¯è¦çœ‹çœ‹é”€é‡å‚è€ƒä¸€ä¸‹çš„å•Šã€‚å› æ­¤ï¼Œå¥¹å¸Œæœ›æ·˜å®èƒ½å¤ŸæŒ‰ç…§å¥¹æƒ³è¦çš„æ–¹å¼æ¥æ’åºï¼šå½“å¥¹æƒ³è¦æŒ‰ä»·æ ¼æ’åºï¼Œå•†å“å°±æŒ‰ä»·æ ¼æ’åºï¼›å½“å¥¹æƒ³è¦æŒ‰é”€é‡æ’åºï¼Œå•†å“å°±æŒ‰é”€é‡æ’åºï¼ˆéƒ½æ˜¯æŒ‰ç…§ä»å¤§åˆ°å°æ’åºï¼‰ã€‚æ·˜å®è¿™ç§å¤§å…¬å¸è‚¯å®šå·²ç»æä¾›è¿™ä¸ªåŠŸèƒ½çš„å•Šã€‚ä¸è¿‡ï¼Œä½œä¸ºä¸€ä¸ªç¨‹åºçŒ¿ï¼Œå¥¹å¸Œæœ›å¤§å®¶ä¹Ÿæ¥ç”¨C++æ¨¡æ‹Ÿå®ç°ä¸€ä¸‹ã€‚ ä»£è¡¨å•†å“çš„ç»“æ„ä½“å¦‚ä¸‹ï¼š 1234struct TaoBaoItem &#123; int price; int volume_of_sales;&#125;; ä¸ºäº†èƒ½å®ç°ä¸åŒçš„æ’åºæ–¹å¼ï¼Œå¥¹ç‰¹æ„æŠ½è±¡å‡ºäº†ä¸€ä¸ªæ¥å£å‡ºæ¥ï¼š 123456class SortInterface &#123; public: virtual ~SortInterface() &#123;&#125;; virtual void DoSort(TaoBaoItem item[], int size) = 0;&#125;; æ¥ä¸‹æ¥ï¼Œå¥¹è¦ä½ ä»¬å®ç°çš„ç±»å¦‚ä¸‹ï¼š 12345678910111213141516171819202122class SortByPrice : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size);&#125;; class SortBySales : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size);&#125;;class TaoBao &#123; public: TaoBao(SortInterface* strategy); void SetSortStrategy(SortInterface* strategy); // Use current strategy_ to do the sort. void sort(TaoBaoItem item[], int size); private: SortInterface *strategy_;&#125;; ä½ æäº¤çš„å®ç°å¯èƒ½ä¼šè¢«æµ‹è¯•æ¡†æ¶ç”¨å¦‚ä¸‹çš„æ–¹å¼è¿›è¡Œè°ƒç”¨ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct TaoBaoItem &#123; int price; int volume_of_sales;&#125;;class SortInterface &#123; public: virtual ~SortInterface() &#123;&#125;; virtual void DoSort(TaoBaoItem item[], int size) = 0;&#125;;#include &quot;source.cpp&quot;void printItem(TaoBaoItem arr[], int size) &#123; for (int i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; arr[i].price &lt;&lt; &quot; &quot; &lt;&lt; arr[i].volume_of_sales &lt;&lt; endl; &#125;&#125;int main(int argc, char *argv[]) &#123; TaoBaoItem item[4] = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;, &#123;5, 1&#125;, &#123;3, 10&#125; &#125;; SortByPrice price; SortBySales sales; TaoBao taobao(&amp;price); taobao.sort(item, 4); printItem(item, 4); taobao.SetSortStrategy(&amp;sales); taobao.sort(item, 4); printItem(item, 4); return 0;&#125; Sample Output 123456785 13 102 31 23 102 31 25 1 Hint è¿™å…¶å®æ˜¯ä¸€ç§å«åšâ€œç­–ç•¥æ¨¡å¼â€çš„è®¾è®¡æ¨¡å¼ï¼Œæœ‰å…´è¶£çš„åŒå­¦æŸ¥é˜…è¯¥æ¡ç›®çš„ç»´åŸºç™¾ç§‘é¡µé¢ï¼ˆä¸­æ–‡ï¼Œè‹±æ–‡ï¼‰ã€‚ä¸è¿‡ï¼Œè¿™ä¸ªé¢˜ç›®æœ€ä¸»è¦çš„ç›®çš„æ˜¯æƒ³è®©å¤§å®¶ä½“éªŒä¸€ä¸‹å¤šæ€å¸¦æ¥çš„å¥½å¤„ã€‚ å…³äºæ’åºçš„å®ç°ï¼Œå¤§å®¶å¯ä»¥å°è¯•ä½¿ç”¨std::sortå‡½æ•°ï¼Œä½¿ç”¨æ–¹æ³•è¯·è‡ªè¡ŒæŸ¥æ‰¾ã€‚ framework.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct TaoBaoItem &#123; int price; int volume_of_sales;&#125;;class SortInterface &#123; public: virtual ~SortInterface() &#123;&#125;; virtual void DoSort(TaoBaoItem item[], int size) = 0;&#125;;#include &quot;source.h&quot;void printItem(TaoBaoItem arr[], int size) &#123; for (int i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; arr[i].price &lt;&lt; &quot; &quot; &lt;&lt; arr[i].volume_of_sales &lt;&lt; endl; &#125;&#125;int main(int argc, char *argv[]) &#123; TaoBaoItem item[4] = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;, &#123;5, 1&#125;, &#123;3, 10&#125; &#125;; SortByPrice price; SortBySales sales; TaoBao taobao(&amp;price); taobao.sort(item, 4); printItem(item, 4); taobao.SetSortStrategy(&amp;sales); taobao.sort(item, 4); printItem(item, 4); return 0;&#125; source.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#ifndef SOURCE_H#define SOURCE_Hclass SortByPrice : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size) &#123; TaoBaoItem temp; for(int i = 0; i &lt; size; i++) &#123; for(int j = 0; j &lt; size - i - 1; j++) &#123; if(item[j].price &lt; item[j + 1].price) &#123; temp = item[j]; item[j] = item[j + 1]; item[j + 1] = temp; &#125; &#125; &#125; &#125;&#125;;class SortBySales : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size) &#123; TaoBaoItem temp; for(int i = 0; i &lt; size; i++) &#123; for(int j = 0; j &lt; size - i - 1; j++) &#123; if(item[j].volume_of_sales &lt; item[j + 1].volume_of_sales) &#123; temp = item[j]; item[j] = item[j + 1]; item[j + 1] = temp; &#125; &#125; &#125; &#125;&#125;;class TaoBao &#123; public: TaoBao(SortInterface* strategy) &#123; this-&gt;strategy_ = strategy; &#125; void SetSortStrategy(SortInterface* strategy) &#123; this-&gt;strategy_ = strategy; &#125; // Use current strategy_ to do the sort. void sort(TaoBaoItem item[], int size) &#123; this-&gt;strategy_-&gt;DoSort(item, size); &#125; private: SortInterface *strategy_;&#125;;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;numeric&gt;using namespace std;bool cmp1(TaoBaoItem&amp; a, TaoBaoItem&amp; b)&#123; return a.price &gt; b.price;&#125;bool cmp2(TaoBaoItem&amp; a, TaoBaoItem&amp; b)&#123; return a.volume_of_sales &gt; b.volume_of_sales;&#125;class SortByPrice : public SortInterface &#123;public: virtual void DoSort(TaoBaoItem item[], int size)&#123; sort(item, item + size, cmp1); &#125;&#125;; class SortBySales : public SortInterface &#123; public: virtual void DoSort(TaoBaoItem item[], int size)&#123; sort(item, item + size, cmp2); &#125;&#125;;class TaoBao &#123; public: TaoBao(SortInterface* strategy)&#123; strategy_ = strategy; &#125; void SetSortStrategy(SortInterface* strategy)&#123; strategy_ = strategy; &#125; // Use current strategy_ to do the sort. void sort(TaoBaoItem item[], int size)&#123; strategy_-&gt;DoSort(item, size); &#125; private: SortInterface *strategy_;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Product and Factory","slug":"ç¨‹è®¾/Product and Factory","date":"2022-05-14T08:06:34.096Z","updated":"2022-05-14T08:52:58.883Z","comments":true,"path":"2022/05/14/ç¨‹è®¾/Product and Factory/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/Product%20and%20Factory/","excerpt":"","text":"Description åœ¨è½¯ä»¶è®¾è®¡ä¸­ï¼Œä¸€ä¸ªå¯¹è±¡çš„åˆ›å»ºå¯èƒ½æ²¡æœ‰å®ƒçœ‹ä¸Šå»é‚£ä¹ˆå®¹æ˜“ã€‚æ¯”å¦‚è¯¾ç¨‹ç®¡ç†ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªè¯¾ç¨‹çš„åˆ›å»ºä¾èµ–äºè®¸å¤šä¸šåŠ¡é€»è¾‘ã€‚ æŸäº›æƒ…å†µä¸‹ï¼Œå°†å¯¹è±¡çš„åˆ›å»ºå’Œä½¿ç”¨åˆ†ç¦»å¼€æ¥ï¼Œæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ï¼Œè¿™è®©æˆ‘ä»¬å¯ä»¥æ›´ä¼˜é›…åœ°ç»„ç»‡ä»£ç ï¼Œé™ä½å„æ¨¡å—çš„è€¦åˆæ€§ã€‚ æˆ‘ä»¬å°†ä½¿ç”¨ Product å’Œ Factory çš„æ¦‚å¿µï¼š å½“å®¢æˆ·ç«¯éœ€è¦æŸä¸ª Product æ—¶ï¼Œå¹¶ä¸ç›´æ¥æ‹¿åˆ°å®ƒï¼Œè€Œæ˜¯é€šè¿‡ä¸€ä¸ª Factory æ‹¿åˆ° åªæœ‰ Factory å…³å¿ƒå¦‚ä½•åˆ›å»ºè¿™ä¸ª Productï¼Œè€Œå®¢æˆ·ç«¯æ— éœ€å…³å¿ƒ å®¢æˆ·ç«¯æ‹¿åˆ° Productï¼Œå³å¯ä½¿ç”¨å®ƒæ”¯æŒçš„å„ç§æ–¹æ³• ä¾æ¬¡é˜…è¯» Hint ä¸­ç»™å‡ºçš„ä¸‰ä¸ªé“¾æ¥ï¼Œç†è§£è¿™ä¸‰ç§æ¨¡å¼å’Œå®ƒä»¬ä¹‹é—´çš„å…³ç³»ï¼Œç†è§£â€œäº§å“ç­‰çº§ç»“æ„â€ã€â€œäº§å“æ—â€ã€‚ æ ¹æ®ç»™å‡ºçš„ä¿¡æ¯ï¼Œåº”ç”¨â€œæŠ½è±¡å·¥å‚æ¨¡å¼â€ï¼Œå®Œæˆè¯¥ç¨‹åºã€‚ Sample Input 1 10 Sample Output 1 12Apple Laptop compiles a cpp program.Apple MobilePhone sends a short message. Sample Input 2 11 Sample Output 2 12Xiaomi Laptop compiles a cpp program.Xiaomi MobilePhone sends a short message. Hint å…³é”®çŸ¥è¯†ç‚¹ï¼šæŠ½è±¡ç±»ï¼ˆæ¥å£ç»§æ‰¿ï¼‰ã€å¤šæ€ Laptop å¯ä»¥ compileCppProgramï¼ŒMobilePhone å¯ä»¥ sendShortMessage æƒ³è¦ AppleLaptop æˆ– AppleMobilePhoneï¼Œå»æ‰¾ AppleFactory æƒ³è¦ XiaomiLaptop æˆ– XiaomiMobilePhoneï¼Œå»æ‰¾ XiaomiFactory ç®€å•å·¥å‚æ¨¡å¼ å·¥å‚æ–¹æ³•æ¨¡å¼ æŠ½è±¡å·¥å‚æ¨¡å¼ Client.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &quot;Product.hpp&quot;#include &quot;Factory.hpp&quot;using std::cin;void test() &#123; Factory* factory = NULL; int choose; cin &gt;&gt; choose; switch (choose) &#123; case 0: factory = new AppleFactory(); break; case 1: default: factory = new XiaomiFactory(); break; &#125; Laptop* laptop = factory-&gt;produceLaptop(); MobilePhone* phone = factory-&gt;produceMobilePhone(); laptop-&gt;compileCppProgram(); phone-&gt;sendShortMessage(); delete laptop; delete phone; delete factory;&#125;int main() &#123; test(); return 0;&#125; Factory.hpp 12345678910111213141516171819202122232425#ifndef FACTORY_HPP_#define FACTORY_HPP_#include &quot;Product.hpp&quot;class Factory &#123;public: virtual Laptop* produceLaptop() = 0; virtual MobilePhone* produceMobilePhone() = 0; virtual ~Factory() &#123;&#125;&#125;;class AppleFactory : public Factory &#123;public: Laptop* produceLaptop() &#123; return new AppleLaptop(); &#125; MobilePhone* produceMobilePhone() &#123; return new AppleMobilePhone(); &#125;&#125;;class XiaomiFactory : public Factory &#123;public: Laptop* produceLaptop() &#123; return new XiaomiLaptop(); &#125; MobilePhone* produceMobilePhone() &#123; return new XiaomiMobilePhone(); &#125;&#125;;#endif Product.hpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef PRODUCT_HPP_#define PRODUCT_HPP_#include &lt;iostream&gt;using std::cout;using std::endl;class Laptop &#123;public: virtual void compileCppProgram() = 0; virtual ~Laptop() &#123;&#125;&#125;;class AppleLaptop : public Laptop &#123;public: void compileCppProgram() &#123; cout &lt;&lt; &quot;Apple Laptop compiles a cpp program.&quot; &lt;&lt; endl; &#125;&#125;;class XiaomiLaptop : public Laptop &#123;public: void compileCppProgram() &#123; cout &lt;&lt; &quot;Xiaomi Laptop compiles a cpp program.&quot; &lt;&lt; endl; &#125;&#125;;class MobilePhone &#123;public: virtual void sendShortMessage() = 0; virtual ~MobilePhone() &#123;&#125;&#125;;class AppleMobilePhone : public MobilePhone &#123;public: void sendShortMessage() &#123; cout &lt;&lt; &quot;Apple MobilePhone sends a short message.&quot; &lt;&lt; endl; &#125;&#125;;class XiaomiMobilePhone : public MobilePhone &#123;public: void sendShortMessage() &#123; cout &lt;&lt; &quot;Xiaomi MobilePhone sends a short message.&quot; &lt;&lt; endl; &#125;&#125;;#endif","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"è™šå‡½æ•°(virtual destructor)","slug":"ç¨‹è®¾/destructor","date":"2022-05-14T07:53:33.813Z","updated":"2022-05-14T08:02:02.350Z","comments":true,"path":"2022/05/14/ç¨‹è®¾/destructor/","link":"","permalink":"http://example.com/2022/05/14/%E7%A8%8B%E8%AE%BE/destructor/","excerpt":"","text":"Description ä¸‹é¢æ˜¯ä¸å®Œæ•´çš„ç»§æ‰¿ç±»å®šä¹‰ï¼š 1234567891011121314class A &#123;public: virtual void Prin() &#123; cout&lt;&lt;&quot;Prin come form class A&quot;&lt;&lt;endl; &#125;&#125;;class B &#123; char *buf;public: void Prin() &#123; cout&lt;&lt;&quot;Prin come from class B&quot;&lt;&lt;endl; &#125;&#125;; è¯•å®Œæˆå…¶å®šä¹‰ï¼ˆä½ å¯ä»¥æ ¹æ®éœ€è¦å¢åŠ å¿…è¦çš„æ„é€ å‡½æ•°ã€ææ„å‡½æ•°ï¼‰ï¼Œä½¿å¾—ä¸»å‡½æ•°mainè¿è¡Œåèƒ½å¾—åˆ°é¢„æœŸç»“æœã€‚ 123456789101112void fun(A *a) &#123; delete a;&#125;int main() &#123; A *a = new B(10); a-&gt;Prin(); fun(a); B *b = new B(20); fun(b); return 0;&#125; Sample Output 12345Prin come from class BB::~B()calledA::~A()calledB::~B()calledA::~A()called Hint Virtual destructor! Only need to submit class A and B. Please check your spelling carefully. source.cpp 123456789101112131415161718192021222324#include &lt;iostream&gt;class A &#123;public: virtual void Prin() &#123; std::cout &lt;&lt; &quot;Prin come form class A&quot; &lt;&lt; std::endl; &#125; virtual ~A() &#123; std::cout &lt;&lt; &quot;A::~A()called&quot; &lt;&lt; std::endl; &#125;&#125;;class B: public A &#123;private: char *buf;public: B(int)&#123;&#125; void Prin() &#123; std::cout &lt;&lt; &quot;Prin come from class B&quot; &lt;&lt; std::endl; &#125; virtual ~B() &#123; std::cout &lt;&lt; &quot;B::~B()called&quot; &lt;&lt; std::endl; &#125;&#125;; framework.cpp(lock) 1234567891011121314151617#include &lt;iostream&gt;using namespace std;#include &quot;source.cpp&quot;void fun(A *a) &#123; delete a;&#125;int main() &#123; A *a = new B(10); a-&gt;Prin(); fun(a); B *b = new B(20); fun(b); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"polymorphismå¤šæ€(ä¸€ä¸ªæ¥å£ï¼Œå¤šç§æ–¹æ³•)","slug":"ç¨‹è®¾/vitual class(å¤šæ€)","date":"2022-05-08T08:30:04.373Z","updated":"2022-05-08T08:39:39.587Z","comments":true,"path":"2022/05/08/ç¨‹è®¾/vitual class(å¤šæ€)/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/vitual%20class(%E5%A4%9A%E6%80%81)/","excerpt":"","text":"Description There are 4 classes, Figure is the base class, both Triangle, Rectangle and Circle are all inherited from it. Figure class is like following: 1234567class FIGURE &#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()è¢«å£°æ˜ä¸ºçº¯è™šå‡½æ•°protected: double x_size, y_size;&#125;; You should implement Figure, Triangle, Rectange, Circle class. Sample Output 123Area of triangle is 60Area of rectangle is 120Area of circle is 706.858 Figure.h(lock) 123456789101112131415#ifndef FIGURE_H#define FIGURE_Hconst double PI = 3.14159; // åœ†å‘¨ç‡å¸¸é‡class FIGURE&#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()è¢«å£°æ˜ä¸ºçº¯è™šå‡½æ•°protected: double x_size, y_size;&#125;;#endif main.cpp(lock) 123456789101112131415161718192021222324252627#include &quot;Figure.h&quot;#include &quot;Triangle.h&quot;#include &quot;Rectangel.h&quot;#include &quot;Circle.h&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; TRIANGLE triangle; RECTANGLE rectangle; CIRCLE circle; // å¤„ç†ä¸‰è§’å½¢ triangle.set_size(15, 8); // è®¾ç½®ä¸‰è§’å½¢çš„åº•å’Œé«˜ cout &lt;&lt; &quot;Area of triangle is &quot; &lt;&lt; triangle.get_area() &lt;&lt; &quot;\\n&quot;; // å¤„ç†çŸ©å½¢ rectangle.set_size(15, 8); // è®¾ç½®çŸ©å½¢çš„é•¿å’Œå®½ cout &lt;&lt; &quot;Area of rectangle is &quot; &lt;&lt; rectangle.get_area() &lt;&lt; &quot;\\n&quot;; // å¤„ç†åœ† circle.set_size(15); // è®¾ç½®åœ†çš„åŠå¾„ cout &lt;&lt; &quot;Area of circle is &quot; &lt;&lt; circle.get_area() &lt;&lt; &quot;\\n&quot;; return 0;&#125; Figure.cpp 12345678910111213#include&quot;Figure.h&quot;using namespace std; double FIGURE::get_area()&#123;&#125;void FIGURE::set_size(double x, double y)&#123; x_size = x; y_size = y;&#125; Triangle.h 123456789101112#include&quot;Figure.h&quot;class TRIANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size / 2; &#125;&#125;; Rectangle.h 123456789101112#include&quot;Figure.h&quot;class RECTANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size ; &#125;&#125;; Circle.h 123456789101112#include&quot;Figure.h&quot;class CIRCLE:public FIGURE&#123;public:void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * x_size * PI; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Complex class(é‡è½½ã€æ ¼å¼æ§åˆ¶)","slug":"ç¨‹è®¾/simple complex class","date":"2022-05-08T08:07:51.421Z","updated":"2022-05-08T08:07:51.421Z","comments":true,"path":"2022/05/08/ç¨‹è®¾/simple complex class/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/simple%20complex%20class/","excerpt":"","text":"Description You need to define a class named complex which has private two members, one is real which represents the real part of the complex, and another is imag which represents the imaginary part of the complex, both of them are integer; The class has some member functions: 1234void display() const;//print the complex with this form like 3 + 4i, if the real part and the imaginary part both are 0, you need to print 0;double getModuli() const;//like the function&#x27;s name, you need to return the moduli of the complex; What's more, you need to finish two friend function, overload \"+\" and \"-\", the rule follow the rules of the complex. Sample Input 120 -35 2 Sample Output 12345-3i5+2i5.09902 7.071075-1i-5-5i complex.hpp(lock) 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;class complex&#123; public: complex(int a, int b); complex operator=(complex&amp; other); complex operator+(complex&amp; other); complex operator-(complex&amp; other); void display() const; double getModuli() const; private: int real; int imag;&#125;; main.cpp(lock) 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;complex.hpp&quot;using namespace std;int main() &#123; int real, imag; cin &gt;&gt; real &gt;&gt; imag; complex a(real, imag); a.display(); cout &lt;&lt; endl; cin &gt;&gt; real &gt;&gt; imag; complex b(real, imag); b.display(); cout &lt;&lt; endl; complex c = a + b; complex d = a - b; cout &lt;&lt; c.getModuli() &lt;&lt; &quot; &quot; &lt;&lt; d.getModuli() &lt;&lt; endl; c.display(); cout &lt;&lt; endl; d.display();&#125; complex.cpp 1234567891011121314151617181920212223242526272829303132#include&quot;complex.hpp&quot;complex::complex(int a, int b)&#123; real = a; imag = b;&#125;complex complex::operator=(complex&amp; other)&#123; this-&gt;real = other.real; this-&gt;imag = other.imag; return *this;&#125;complex complex::operator+(complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real + other.real; temp.imag = this-&gt;imag + other.imag; return temp;&#125;complex complex::operator - (complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real - other.real; temp.imag = this-&gt;imag - other.imag; return temp;&#125;void complex::display() const&#123; if(!real &amp;&amp; !imag ) cout &lt;&lt; 0 &lt;&lt; endl; else if(!real) cout &lt;&lt; noshowpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; else if( !imag) cout&lt;&lt; noshowpos&lt;&lt; real; else cout &lt;&lt; noshowpos&lt;&lt; real &lt;&lt;showpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; cout &lt;&lt; noshowpos;&#125;double complex::getModuli() const&#123; return sqrt(real * real + imag * imag);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"point class 3ï¼ˆç»§æ‰¿ï¼‰","slug":"ç¨‹è®¾/point class3(ç»§æ‰¿)","date":"2022-05-08T08:07:01.347Z","updated":"2022-05-08T08:09:36.905Z","comments":true,"path":"2022/05/08/ç¨‹è®¾/point class3(ç»§æ‰¿)/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/point%20class3(%E7%BB%A7%E6%89%BF)/","excerpt":"","text":"é¢˜ç›®æè¿° åœ¨å…ˆå‰Point Class 2çš„é¢˜ç›®ä¸­ï¼Œä½¿ç”¨çš„æ–¹æ³•æ˜¯ç”¨ä¸‰ç»´çš„ThreeDPointç»§æ‰¿äºŒç»´çš„TwoDPointï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå°†äºŒç»´ç‚¹ä½œä¸ºåŸºç±»å…¶å®æ˜¯ä¸å…·æœ‰ç»§æ‰¿æ„ä¹‰çš„ã€‚ ä¸ºäº†å®ç°ä¸€ä¸ªå…·æœ‰çœŸå®ç»§æ‰¿æ„ä¹‰çš„PointåŸºç±»ï¼Œæˆ‘ä»¬åœ¨åŸºç±»Pointä¸­è®©ç‚¹çš„ç»´åº¦ä½œä¸ºä¸€ä¸ªå˜é‡å­˜åœ¨ï¼Œè¿™æ ·å¤šç»´åº¦çš„ç‚¹æˆ‘ä»¬åªéœ€è¦ç»§æ‰¿åŸºç±»å°±å¯ä»¥å¾—åˆ°äº†ï¼ŒåŒæ—¶é¿å…äº†Distanceæ–¹æ³•çš„é‡å†™ã€‚ è¯·åœ¨ derivedPoint.hã€derivedPoint.cppã€point.cppä¸­åˆ†åˆ«å®Œæˆç±»çš„å£°æ˜å’Œå®šä¹‰ã€‚ Hint è¯·æ ¹æ®main.cppå’Œpoint.hçš„å†…å®¹å®Œæˆä»£ç ç¼–å†™ åœ¨getDistanceæ–¹æ³•ä¸­ï¼Œå¦‚æœä¸¤ä¸ªç‚¹ç»´åº¦ä¸åŒï¼Œé‚£ä¹ˆè¿”å›-1 å‡ºç°é¢å¤–æ–¹æ³•ï¼š getAbsSlopeä¸ºè·å–æ–œç‡çš„ç»å¯¹å€¼ï¼Œå¦‚æœæ–œç‡æ— ç©·åˆ™è¿”å›-1 isOnAxisä¸ºåˆ¤æ–­ç‚¹æ˜¯å¦åœ¨åæ ‡è½´ä¸Šï¼Œæ˜¯è¿”å›trueï¼Œå¦åˆ™è¿”å›false point.h 123456789101112131415161718192021#ifndef POINT_H#define POINT_H#include &lt;iostream&gt;using namespace std;class Point&#123; private: int *coordinate; // è®°å½•åæ ‡çš„æ•°ç»„ int dim; // ç»´åº¦ public: Point(int dim); // åˆå§‹åŒ–ä¸ºåŸç‚¹åæ ‡ Point(int dim, int *coordinate); int getDimension(); int getByIndex(int); double getDistance(Point&amp; another); virtual ~Point();&#125;;#endif main.cpp(lock) 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &quot;point.h&quot;#include &quot;derivedPoint.h&quot;int main() &#123; int point1[2], point2[2]; int point[3]; cin &gt;&gt; point1[0] &gt;&gt; point1[1]; cin &gt;&gt; point2[0] &gt;&gt; point2[1]; cin &gt;&gt; point[0] &gt;&gt; point[1] &gt;&gt; point[2]; TwoDPoint p1(point1), p2(point2); cout &lt;&lt; &quot;Distance between p1 and p2 is &quot; &lt;&lt; p1.getDistance(p2) &lt;&lt; endl; cout &lt;&lt; &quot;The absolute slope of the line through p1 and p2 is &quot; &lt;&lt; p1.getAbsSlope(p2) &lt;&lt; endl; cout &lt;&lt; &quot;X = &quot; &lt;&lt; p2.getX() &lt;&lt; endl; cout &lt;&lt; &quot;Y = &quot; &lt;&lt; p2.getY() &lt;&lt; endl; ThreeDPoint p(point); cout &lt;&lt; &quot;Distance between p1 and p is &quot; &lt;&lt; p1.getDistance(p) &lt;&lt; endl; if(p.isOnAxis()) cout &lt;&lt; &quot;ThreeDPoint is on the axis.\\n&quot;; else cout &lt;&lt; &quot;ThreeDPoint is not on the axis.\\n&quot;; return 0;&#125; derived point.cpp 123456789101112131415161718192021222324#include&quot;point.h&quot;#include&lt;cmath&gt;class TwoDPoint:public Point&#123;public: TwoDPoint(int* p):Point(2, p)&#123;&#125; double getAbsSlope(TwoDPoint&amp; another)&#123; if(abs(this-&gt;getByIndex(0) - another.getByIndex(0) == 0) )return -1; return 1.0 * abs(this-&gt;getByIndex(1) - another.getByIndex(1)) / abs(this-&gt;getByIndex(0) - another.getByIndex(0)); &#125; int getX()&#123; return this-&gt;getByIndex(0); &#125; int getY()&#123; return this-&gt;getByIndex(1); &#125;&#125;;class ThreeDPoint:public Point&#123;public: ThreeDPoint(int* p):Point(3, p)&#123;&#125; bool isOnAxis()&#123; return !this-&gt;getByIndex(0) || !this-&gt;getByIndex(1) || !this-&gt;getByIndex(2); &#125;&#125;; point.cpp 123456789101112131415161718192021222324252627282930313233#include&quot;point.h&quot;#include&lt;math.h&gt;Point::Point(int newdim)&#123; dim = newdim; coordinate = new int[dim]; for(int i = 0; i &lt; dim; i++)&#123; coordinate[i] = 0; &#125;&#125;Point::Point(int newdim, int *newcoordinate)&#123; dim = newdim; coordinate = newcoordinate;&#125;int Point::getDimension()&#123; return dim;&#125;int Point::getByIndex(int ind)&#123; return coordinate[ind];&#125;double Point::getDistance(Point&amp; another)&#123; if(dim != another.dim) return -1; double s = 0.0; int dim1 = dim; while(dim1 &gt; 0)&#123; --dim1; s += (this-&gt;coordinate[dim1] - another.coordinate[dim1])*(this-&gt;coordinate[dim1] - another.coordinate[dim1]); &#125; //cout &lt;&lt; sqrt(s) &lt;&lt; endl; return sqrt(s);&#125;Point::~Point()&#123; //delete []coordinate;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"point class 2ï¼ˆç»§æ‰¿ï¼‰","slug":"ç¨‹è®¾/point class2(ç»§æ‰¿)","date":"2022-05-08T08:00:11.103Z","updated":"2022-05-08T08:04:05.431Z","comments":true,"path":"2022/05/08/ç¨‹è®¾/point class2(ç»§æ‰¿)/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/point%20class2(%E7%BB%A7%E6%89%BF)/","excerpt":"","text":"Description Recall the \"Point\" class before, we want to create TwoDPoint class to model a point in a two-dimensional space.(Default value (0,0), int). It has functions to get its coordinates getX(), getY() and a member function to calculate the distance between it and another TwoDPoint distance(return type double). Based on TwoDPoint, create a class named ThreeDPoint to model a point in a three-dimensional space.x, y, z represent x-, y- and z-coordinates(Default value (0,0,0), int).Let ThreeDPoint be derived from TwoDPoint, adding function getZ() and overload the member functiondistance. Hint Get to know details in framework.cpp and try to separate declaration and definition in Points.h and Points.cpp . framwork.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;Points.h&quot;using namespace std;ostream&amp; operator&lt;&lt;(ostream&amp; out, const TwoDPoint&amp; point)&#123; out &lt;&lt; &#x27;(&#x27; &lt;&lt; point.getX() &lt;&lt; &#x27;,&#x27; &lt;&lt; point.getY() &lt;&lt; &#x27;)&#x27;; return out;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, const ThreeDPoint&amp; point)&#123; out &lt;&lt; &#x27;(&#x27; &lt;&lt; point.getX() &lt;&lt; &#x27;,&#x27; &lt;&lt; point.getY() &lt;&lt; &#x27;,&#x27; &lt;&lt; point.getZ() &lt;&lt; &#x27;)&#x27;; return out;&#125;int main()&#123; //2-D Point TwoDPoint pa1, pa; int pa2_x, pa2_y; cin &gt;&gt; pa2_x &gt;&gt; pa2_y; TwoDPoint pa2(pa2_x,pa2_y); cout &lt;&lt; &quot;Distance between &quot; &lt;&lt; pa1 &lt;&lt; &quot; and &quot; &lt;&lt; pa2 &lt;&lt;&quot; is &quot;&lt;&lt;pa1.distance(pa2) &lt;&lt; endl; //3-D Point ThreeDPoint pb1; int pb2_x, pb2_y, pb2_z, pb3_x, pb3_y, pb3_z; cin &gt;&gt; pb2_x &gt;&gt; pb2_y &gt;&gt; pb2_z; cin &gt;&gt; pb3_x &gt;&gt; pb3_y &gt;&gt; pb3_z; ThreeDPoint pb2(pb2_x, pb2_y, pb2_z), pb3(pb3_x, pb3_y, pb3_z); cout &lt;&lt; &quot;Distance between &quot; &lt;&lt; pb1 &lt;&lt; &quot; and &quot; &lt;&lt; pb2 &lt;&lt;&quot; is &quot;&lt;&lt;pb1.distance(pb2) &lt;&lt; endl; cout &lt;&lt; &quot;Distance between &quot; &lt;&lt; pb1 &lt;&lt; &quot; and &quot; &lt;&lt; pb3 &lt;&lt;&quot; is &quot;&lt;&lt;pb1.distance(pb3) &lt;&lt; endl; return 0;&#125; points.hpp 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;cmath&gt;using namespace std;class TwoDPoint&#123;protected: int x, y;public: TwoDPoint(int xx = 0, int yy = 0):x(xx), y(yy)&#123;&#125; int getX() const&#123;return x;&#125; int getY() const&#123;return y;&#125; double distance(const TwoDPoint&amp; other)&#123; return sqrt( 1.0 * (x + other.getX()) * (x + other.getX()) + 1.0 * (y + other.getY()) * (y + other.getY())); &#125;&#125;;class ThreeDPoint:public TwoDPoint&#123; int z;public: ThreeDPoint(int xx = 0, int yy = 0, int zz = 0):TwoDPoint(xx, yy), z(zz)&#123;&#125; int getZ() const&#123; return z; &#125; double distance(const ThreeDPoint&amp; other)&#123; return sqrt( 1.0 * (x + other.getX()) * (x + other.getX()) + 1.0 * (y + other.getY()) * (y + other.getY()) + 1.0 * (z + other.getZ()) * (z + other.getZ())); &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Complex class(é‡è½½ã€æ ¼å¼æ§åˆ¶)","slug":"ç¨‹è®¾/simple complex class(å¤ä¹ )","date":"2022-05-08T07:44:24.227Z","updated":"2022-05-08T07:48:48.925Z","comments":true,"path":"2022/05/08/ç¨‹è®¾/simple complex class(å¤ä¹ )/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/simple%20complex%20class(%E5%A4%8D%E4%B9%A0)/","excerpt":"","text":"Description You need to define a class named complex which has private two members, one is real which represents the real part of the complex, and another is imag which represents the imaginary part of the complex, both of them are integer; The class has some member functions: 1234void display() const;//print the complex with this form like 3 + 4i, if the real part and the imaginary part both are 0, you need to print 0;double getModuli() const;//like the function&#x27;s name, you need to return the moduli of the complex; What's more, you need to finish two friend function, overload \"+\" and \"-\", the rule follow the rules of the complex. Sample Input 120 -35 2 Sample Output 12345-3i5+2i5.09902 7.071075-1i-5-5i complex.hpp(lock) 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;class complex&#123; public: complex(int a, int b); complex operator=(complex&amp; other); complex operator+(complex&amp; other); complex operator-(complex&amp; other); void display() const; double getModuli() const; private: int real; int imag;&#125;; main.cpp(lock) 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;complex.hpp&quot;using namespace std;int main() &#123; int real, imag; cin &gt;&gt; real &gt;&gt; imag; complex a(real, imag); a.display(); cout &lt;&lt; endl; cin &gt;&gt; real &gt;&gt; imag; complex b(real, imag); b.display(); cout &lt;&lt; endl; complex c = a + b; complex d = a - b; cout &lt;&lt; c.getModuli() &lt;&lt; &quot; &quot; &lt;&lt; d.getModuli() &lt;&lt; endl; c.display(); cout &lt;&lt; endl; d.display();&#125; complex.cpp 1234567891011121314151617181920212223242526272829303132#include&quot;complex.hpp&quot;complex::complex(int a, int b)&#123; real = a; imag = b;&#125;complex complex::operator=(complex&amp; other)&#123; this-&gt;real = other.real; this-&gt;imag = other.imag; return *this;&#125;complex complex::operator+(complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real + other.real; temp.imag = this-&gt;imag + other.imag; return temp;&#125;complex complex::operator - (complex&amp; other)&#123; complex temp(0, 0); temp.real = this-&gt;real - other.real; temp.imag = this-&gt;imag - other.imag; return temp;&#125;void complex::display() const&#123; if(!real &amp;&amp; !imag ) cout &lt;&lt; 0 &lt;&lt; endl; else if(!real) cout &lt;&lt; noshowpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; else if( !imag) cout&lt;&lt; noshowpos&lt;&lt; real; else cout &lt;&lt; noshowpos&lt;&lt; real &lt;&lt;showpos &lt;&lt; imag &lt;&lt; &#x27;i&#x27;; cout &lt;&lt; noshowpos;&#125;double complex::getModuli() const&#123; return sqrt(real * real + imag * imag);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(äºŒåäº”)--static function","slug":"ç¨‹è®¾/static member","date":"2022-05-08T07:13:58.769Z","updated":"2022-05-08T07:27:12.881Z","comments":true,"path":"2022/05/08/ç¨‹è®¾/static member/","link":"","permalink":"http://example.com/2022/05/08/%E7%A8%8B%E8%AE%BE/static%20member/","excerpt":"","text":"Description å®Œæˆç±»Intï¼Œå¯ä»¥åŠ å…¥ä½ è§‰å¾—éœ€è¦çš„member value or function. 123456class Int&#123; int data;public: Int(int n); //å°†nçš„å€¼èµ‹ç»™data&#125;; ä½¿å¾—å‡½æ•°f()è¾“å‡ºä¸º 12345678910111213141516num 1 is odd? 1num 2 is odd? 01 objects of Int has been constructed.2 objects of Int has been constructed.3 objects of Int has been constructed.2 objects of Int has been constructed.void f()&#123; int i1=1, i2=2; cout &lt;&lt; &quot;num &quot; &lt;&lt; i1 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(1) &lt;&lt; endl; cout &lt;&lt; &quot;num &quot; &lt;&lt; i2 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(2) &lt;&lt; endl; Int ii1; &#123; Int ii1(i1); &#125; Int ii2(i2);&#125; framework.cpp 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;#include&quot;1001.cpp&quot;int Int::num=0;void f()&#123; int i1=1, i2=2; cout &lt;&lt; &quot;num &quot; &lt;&lt; i1 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(1) &lt;&lt; endl; cout &lt;&lt; &quot;num &quot; &lt;&lt; i2 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(2) &lt;&lt; endl; Int ii1; &#123; Int ii1(i1); Int ii2; &#125; Int ii2(i2);&#125;int main()&#123; f(); return 0;&#125; answer.cpp 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class Int&#123; int data; static int num;public: Int(int n):data(n)&#123; num++; cout &lt;&lt; num &lt;&lt; &quot; objects of Int has been constructed.&quot; &lt;&lt; endl; &#125; Int()&#123; num++; cout &lt;&lt; num &lt;&lt; &quot; objects of Int has been constructed.&quot; &lt;&lt; endl; &#125;; ~Int()&#123; num--; &#125; static int isodd(int n)&#123; return n % 2; &#125;&#125;; å‡ ä¸ªç‚¹ 12cout &lt;&lt; &quot;num &quot; &lt;&lt; i1 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(1) &lt;&lt; endl;cout &lt;&lt; &quot;num &quot; &lt;&lt; i2 &lt;&lt; &quot; is odd? &quot; &lt;&lt; Int::isodd(2) &lt;&lt; endl; 123static int isodd(int n)&#123; return n % 2;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"æœŸä¸­è€ƒå·åˆ†æ","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æœŸä¸­è€ƒå·æ€»ç»“","date":"2022-04-25T08:34:12.724Z","updated":"2022-04-25T11:52:10.470Z","comments":true,"path":"2022/04/25/æ•°å­—ç”µè·¯æ±‡æ€»/æœŸä¸­è€ƒå·æ€»ç»“/","link":"","permalink":"http://example.com/2022/04/25/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%9C%9F%E4%B8%AD%E8%80%83%E5%8D%B7%E6%80%BB%E7%BB%93/","excerpt":"","text":"å¡«ç©ºé¢˜ å®ç°é€»è¾‘é—¨ç”µè·¯çš„ä¸¤ç§ä¸»è¦åŠå¯¼ä½“æŠ€æœ¯: TTLå’ŒCOMS ICåŒ…æ‹¬å›ºå®šåŠŸèƒ½å’Œå¯ç¼–ç¨‹ä¸¤å¤§ç±»,åè€…æŒ‰ç»“æ„å’Œå¤æ‚åº¦å¯ç»†åˆ†ä¸ºä¸¤å¤§ç±»:(PLD)å’Œ(FPGA) 8ä½æœ‰ç¬¦å·æ•°,-85çš„åç å’Œè¡¥ç  74HC00å­—æ®µå«ä¹‰,HCå’Œ00çš„å«ä¹‰ ä¸éè¿ç®—è¡¨ç¤º\\(AB+CD\\),æˆ–éè¿ç®—è¡¨ç¤º\\((A+B)(C+D)\\) èŠ¯ç‰‡åŠŸèƒ½å®šä¹‰,æ•°æ®é€‰æ‹©å™¨,ç¼–ç å™¨ å¸¸ç”¨Dè§¦å‘å™¨å’ŒJKè§¦å‘å™¨çš„è§¦å‘æ–¹å¼æœ‰ä¸¤ç§,ç”µå¹³è§¦å‘,è¾¹æ²¿è§¦å‘ ç”Ÿæˆå•ä¸ªæˆ–å‘¨æœŸè„‰å†²çš„ç”µè·¯åˆ†åˆ«ä¸º,å•ç¨³æ€è§¦å‘å™¨,å¤šè°æŒ¯è¡å™¨ æ ¹æ®å›¾,çœ‹è®¡æ•°åºåˆ—çš„æ¨¡,å’Œè®¡æ•°æ–¹å¼(æˆ–æ–¹å‘) çœ‹å›¾,é›†æˆç”µè·¯çš„ä¸¤ç§å°è£…æ–¹å¼,DIP,å°ä»€ä¹ˆçš„å°è£… é€‰æ‹©é¢˜ äºŒè¿›åˆ¶è¡¨ç¤º53ä¸ªæ•°éœ€è¦å¤šå°‘ä½,è‡³å°‘éœ€è¦6ä½ æˆ–è¿ç®—,å¯ä»¥é€šè¿‡ä¸¤ä¸ªæˆ–éé—¨æˆ–ä¸‰ä¸ªä¸éé—¨ -36çš„è¡¥ç è¡¨ç¤ºå½¢å¼ æ•°æ®é€‰æ‹©å™¨,ä¸‰ä¸ªåœ°å€æ•°æ®è¾“å…¥ç«¯,æœ€å¤šæœ‰å‡ ä¸ªæ•°æ®ä¿¡å·è¾“å…¥,8ä¸ª ç»„åˆé€»è¾‘ç”µè·¯äº§ç”Ÿç«äº‰å†’é™©,æ˜¯ç”±äºä¿¡å·çš„å»¶è¿Ÿ å¼‚æˆ–é—¨å½“ä½œåç›¸å™¨æ—¶,è¾“å…¥ç«¯Aå’ŒBå¼•è„šçš„æ¥æ³•æ˜¯,Aæˆ–Bä¸­æœ‰ä¸€ä¸ªè¦æ¥1 åœ¨ä¸å½±å“é€»è¾‘åŠŸèƒ½çš„æƒ…å†µä¸‹,COMSä¸éé—¨çš„å¤šä½™è¾“å…¥ç«¯å¯ä»¥æ¥é«˜ç”µå¹³ è¾“å‡ºä½ä½ç”µå¹³æœ‰æ•ˆçš„16é€‰1è¯‘ç å™¨,13å¯¹åº”çš„å¼•è„šå‡ºç°ä¸€ä¸ªä½ç”µå¹³,æ±‚è¯‘ç å™¨è¾“å…¥æ˜¯ä»€ä¹ˆ,1101 16è¿›åˆ¶-äºŒè¿›åˆ¶ä¼˜å…ˆç¼–ç å™¨ ä¸€ä½å…¨åŠ å™¨æœ‰ä»€ä¹ˆç‰¹æ€§,ä¸‰ä¸ªè¾“å…¥ä¸¤ä¸ªè¾“å‡º åˆ¤æ–­é¢˜ è„‰å†²å¯èƒ½è€ƒå®½åº¦,ä¸‹é™æ—¶é—´,å ç©ºæ¯” è¡¥ç è¡¨ç¤ºå½¢å¼çš„å–å€¼èŒƒå›´ æ‰€æœ‰æ•°å­—ç”µè·¯å¯ä»¥ç”¨ä¸æˆ–éé€»è¾‘ç”µè·¯å‡ºç° è„‰å†²ä¸Šå‡æ—¶é—´çš„å®šä¹‰ äºŒè¿›åˆ¶å‡æ³•å¯ä»¥å–è¡¥ç åšåŠ æ³•è¿›è¡Œ æ— æ•ˆç å¯ä»¥åœ¨å¡è¯ºå›¾ä½œä¸ºæ— å…³é¡¹å‡ºç° é€»è¾‘ä¸å’Œå¸ƒå°”ä¹˜æ³•ç­‰ä»· æ¨¡äºŒåŠ æ³•æ—¶,1+1=1 åŠåŠ å™¨åŒ…æ‹¬ä¸¤ä¸ªè¾“å…¥ä½å’Œä¸€ä¸ªè¿›ä½è¾“å…¥ä½,äº§ç”Ÿä¸€ä¸ªå’Œçš„è¾“å‡ºä½å’Œä¸€ä¸ªè¿›ä½è¾“å‡ºä½ 6å’Œ3éƒ½æ˜¯æœ‰æ•ˆè¾“å‡º,é«˜ç”µå¹³æœ‰æ•ˆBCDç¼–ç å™¨ä¼šè¾“å‡º0110 å¥‡å¶æ ¡éªŒå™¨çº§è”,å¯å°†ä¸Šä¸€ä½çš„å¶æ•°è¾“å‡ºä½æ¥ä¸‹ä¸€ä½çš„ä»»æ„è¾“å…¥ä½(é”™è¯¯) é€»è¾‘å‡½æ•°åŒ–ç®€é¢˜ å¡è¯ºå›¾åŒ–ç®€ä¸ºsopè¡¨è¾¾å¼ \\[ A\\bar{B}CD+\\bar{B}\\bar{C}D+(A+C)B\\bar{D} \\] ç»„åˆé€»è¾‘ç”µè·¯åˆ†æ è€ƒäº†å…¨åŠ å™¨çš„å†…éƒ¨ç»“æ„,æœ€åè¦è¯´æ˜ç”µè·¯çš„é€»è¾‘åŠŸèƒ½ è®¾è®¡åŠåŠ åŠå‡å™¨ 74HC151ä¸‰è¾“å…¥(é€‰æ‹©),8ä¸ªæ•°æ®è¾“å…¥,ä¸€ä¸ªè¾“å‡º,å®ç°å››è¾“å…¥çš„é€»è¾‘è¡¨è¾¾å¼ å®ç°å¤šæ•°è¡¨å†³ç”µè·¯","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"ç¨‹è®¾è®°å½•--matrix(è¿ç®—ç»ƒä¹ )","slug":"ç¨‹è®¾/matrixç»ƒä¹ ","date":"2022-04-19T16:20:08.292Z","updated":"2022-04-19T16:21:47.250Z","comments":true,"path":"2022/04/20/ç¨‹è®¾/matrixç»ƒä¹ /","link":"","permalink":"http://example.com/2022/04/20/%E7%A8%8B%E8%AE%BE/matrix%E7%BB%83%E4%B9%A0/","excerpt":"","text":"Description Task å®Œå–„ Matrix ç±»çš„å®šä¹‰ï¼Œå®ç°ç®€å•çš„Matrixè¿ç®—ï¼Œç±»çš„å®šä¹‰ï¼Œmainå‡½æ•°å·²ç»™å‡ºï¼Œä½ éœ€è¦ç¼–å†™Matrix.cppæ–‡ä»¶å®ç°å…·ä½“å‡½æ•°ï¼Œè®°å¾—åŒ…å«ç±»çš„å®šä¹‰ã€‚ Input m n represent the row and col of matrix a and b(They have the same shape) For next m rows, input the elements in matrix a For next m+1~2m rows, input the elements in matrix b Output Print Matrix a, b Print Matrix a+b Print Matrix d(The transpose of a) Sample Input 1 123452 31 2 31 2 31 2 31 2 3 Sample Output 1 12345678910111213141516Matrix a:1 2 31 2 3Matrix b:1 2 31 2 3Matrix c = Matrix a + Matrix b :2 4 62 4 6Matrix a transpose to Matrix d:1 12 23 3 Sample Input 2 123452 21 23 44 32 1 Sample Ouput 2 123456789101112131415Matrix a:1 23 4Matrix b:4 32 1Matrix c = Matrix a + Matrix b :5 55 5Matrix a transpose to Matrix d:1 32 4 Hint ç±»çš„æ„é€ å‡½æ•°ä¸ææ„å‡½æ•°ï¼Œè¿ç®—ç¬¦é‡è½½ï¼Œnewä¸delete main.cpp(lock) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&quot;Matrix.h&quot;using namespace std;int main()&#123; int row, col; cout &lt;&lt; &quot;input the row and the col for Matrix a, b&quot; &lt;&lt; endl; cin &gt;&gt; row &gt;&gt; col; int **mat_a_arr = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; mat_a_arr[i] = new int[col]; for (int j = 0; j &lt; col; j++) &#123; cin &gt;&gt; mat_a_arr[i][j]; &#125; &#125; int **mat_b_arr = new int*[row]; for (int i = 0; i &lt; row; i++) &#123; mat_b_arr[i] = new int[col]; for (int j = 0; j &lt; col; j++) &#123; cin &gt;&gt; mat_b_arr[i][j]; &#125; &#125; Matrix a(row, col, mat_a_arr), b(row, col, mat_b_arr), c(a), d; cout &lt;&lt; endl &lt;&lt; &quot;Matrix a:&quot; &lt;&lt; endl; a.display(); cout &lt;&lt; endl &lt;&lt; &quot;Matrix b:&quot; &lt;&lt; endl; b.display(); c = a + b;//ç”¨é‡è½½è¿ç®—ç¬¦â€œ+â€å®ç°ä¸¤ä¸ªçŸ©é˜µç›¸åŠ  cout &lt;&lt; endl &lt;&lt; &quot;Matrix c = Matrix a + Matrix b :&quot; &lt;&lt; endl; c.display(); cout &lt;&lt; endl &lt;&lt; &quot;Matrix a transpose to Matrix d:&quot; &lt;&lt; endl; d = a.transpose(); d.display(); for (int i = 0; i &lt; row; i++) &#123; delete[]mat_a_arr[i]; &#125; delete[]mat_a_arr; for (int i = 0; i &lt; row; i++) &#123; delete[]mat_b_arr[i]; &#125; delete[]mat_b_arr; return 0;&#125; matrix.h 123456789101112131415161718192021#ifndef MATRIX_H#define MATRIX_Hclass Matrix&#123;public: Matrix(); //é»˜è®¤æ„é€ å‡½æ•° ~Matrix(); //ææ„å‡½æ•° Matrix(const Matrix &amp;); //æ‹·è´æ„é€ å‡½æ•° Matrix(int row, int col, int** elements); //æ™®é€šæ„é€ å‡½æ•° Matrix operator+(const Matrix &amp;)const; //é‡è½½è¿ç®—ç¬¦â€œ+â€ Matrix operator=(const Matrix &amp;); //é‡è½½è¿ç®—ç¬¦â€œ=â€ Matrix transpose()const; //çŸ©é˜µçš„è½¬ç½® void display()const; //è¾“å‡ºæ•°æ®å‡½æ•° private: int row; //çŸ©é˜µçš„è¡Œ int col; //çŸ©é˜µçš„åˆ— int** mat; //ç”¨äºå‚¨å­˜çŸ©é˜µ&#125;;#endif matrix.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstring&gt;#include&lt;iostream&gt;#include&quot;Matrix.h&quot;using namespace std;Matrix::Matrix()&#123; mat = NULL;&#125; //æ„é€ å‡½æ•°Matrix::~Matrix()&#123; int i; for(i = 0; i &lt; row; i++)&#123; delete[] mat[i]; &#125; delete [] mat;&#125; //ææ„å‡½æ•°Matrix::Matrix(const Matrix &amp; other)&#123; row = other.row; col = other.col; mat = new int*[row]; int i; for(i = 0; i &lt; row; i++)&#123; mat[i] = new int[col + 1]; memcpy(mat[i], other.mat[i], col); &#125;&#125; //æ‹·è´æ„é€ å‡½æ•°Matrix::Matrix(int row, int col, int** elements)&#123; this-&gt;row = row; this-&gt;col = col; mat = new int*[row]; int j, i; for(i = 0; i &lt; row; i++)&#123; mat[i] = new int[col]; for(j = 0; j &lt; col; j++)&#123; mat[i][j] = elements[i][j]; &#125; &#125;&#125; //é»˜è®¤æ„é€ å‡½æ•° Matrix Matrix::operator+(const Matrix &amp; other)const&#123; Matrix temp; temp.row = this-&gt;row; temp.col = this-&gt;col; temp.mat = new int*[row]; int i, j; for(i = 0; i &lt; row; i++)&#123; temp.mat[i] = new int[col]; for(j = 0; j &lt; col; j++)&#123; temp.mat[i][j] = this-&gt;mat[i][j] + other.mat[i][j]; &#125; &#125; return temp;&#125; //é‡è½½è¿ç®—ç¬¦â€œ+â€Matrix Matrix::operator=(const Matrix &amp; other)&#123; if(this-&gt; mat != NULL)&#123; int i; for(i = 0; i &lt; row; i++)&#123; delete[] mat[i]; &#125; delete [] mat; &#125; this-&gt; row = other.row; this-&gt; col = other.col; this-&gt; mat = new int*[row]; int i, j; for(i = 0; i &lt; row; i++)&#123; this-&gt;mat[i] = new int[col]; for(j = 0; j &lt; col; j++)&#123; this-&gt;mat[i][j] = other.mat[i][j]; //cout &lt;&lt; other.mat[i][j] &lt;&lt; &#x27; &#x27;; &#125; &#125; return *this;&#125; //é‡è½½è¿ç®—ç¬¦â€œ=â€Matrix Matrix::transpose()const&#123; Matrix temp; temp.row = this-&gt;col; temp.col = this-&gt;row; temp.mat = new int*[col]; int i, j; for(i = 0; i &lt; temp.row; i++)&#123; temp.mat[i] = new int[row]; for(j = 0; j &lt; temp.col; j++)&#123; temp.mat[i][j] = this-&gt;mat[j][i]; &#125; &#125; return temp;&#125; //çŸ©é˜µçš„è½¬ç½®void Matrix::display()const&#123; int i, j; for(i = 0; i &lt; row; i++)&#123; for(j = 0; j &lt; col - 1; j++)&#123; cout &lt;&lt; this-&gt;mat[i][j] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; this-&gt;mat[i][j] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•--[Static Member] Seminar Logger2","slug":"ç¨‹è®¾/static member2","date":"2022-04-19T11:36:03.752Z","updated":"2022-04-19T12:04:10.967Z","comments":true,"path":"2022/04/19/ç¨‹è®¾/static member2/","link":"","permalink":"http://example.com/2022/04/19/%E7%A8%8B%E8%AE%BE/static%20member2/","excerpt":"","text":"Description SDCS will organize students to participate in the seminarã€‚curr_ people off campus mysterious guests and organizers have confirmed their participation. Meanwhile, they have been waiting in the venue. There are student_ num students participated, and each student has to introduce himself. At the end of the event, the students will leave in the order of admission, and the guests and the organizer will leave after the final discussion. Use the Student class to record the students. Please complete the Student.cpp so as to make the program achieve the corresponding record results. SDCSå°†ç»„ç»‡å­¦ç”Ÿå‚åŠ è®¨è®ºä¼šï¼Œå·²ç»æœ‰curr_peopleä¸ªæ ¡å¤–ç¥ç§˜å˜‰å®¾ä»¥åŠä¸¾åŠæ–¹ç¡®å®šå‚ä¸ï¼ŒåŒæ—¶ä»–ä»¬å·²ç»åœ¨ä¼šåœºä¸­ç­‰å¾…ã€‚å…±æœ‰student_numä¸ªå­¦ç”Ÿå‚åŠ ï¼Œæ¯ä¸€ä¸ªå­¦ç”Ÿåˆ°åœºåéƒ½è¦è¿›è¡Œä¸€æ¬¡è‡ªæˆ‘ä»‹ç»ã€‚æ´»åŠ¨ç»“æŸåï¼Œå­¦ç”ŸæŒ‰ç…§å…¥åœºçš„é¡ºåºä¾æ¬¡é€€åœºï¼Œå˜‰å®¾ä»¥åŠä¸¾åŠæ–¹åœ¨æœ€ç»ˆå•†è®¨åæœ€åç¦»åœºã€‚ ç”¨Studentç±»æ¥è®°å½•å‚åŠ çš„å­¦ç”Ÿï¼Œè¯·å®ŒæˆStudent.cppæ–‡ä»¶çš„ç¼–å†™ï¼Œä½¿å¾—ç¨‹åºèƒ½å¤Ÿè¾¾æˆå¯¹åº”çš„è®°å½•ç»“æœã€‚ Sample Input In the first line, there are two numeric inputs, which are the number of organizers and guests (curr_ people), and the number of students in SDCS(student_ num). In next student_num lines, each line has two inputs. The first input is indicate the gender of the student: if the student is a boy, it will be 1, otherwise, it's 0. The second input is a string, which indicates the name of the student ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ•°å­—è¾“å…¥ï¼Œåˆ†åˆ«ä¸ºä¸¾åŠæ–¹ä¸å˜‰å®¾çš„æ•°ç›®curr_peopleï¼Œä»¥åŠSDCSä¸­å­¦ç”Ÿçš„æ•°é‡student_numã€‚ æ­¤åçš„person_numè¡Œä¸­ï¼Œæ¯è¡Œéƒ½æœ‰2ä¸ªè¾“å…¥ï¼Œç¬¬ä¸€ä¸ªintè¾“å…¥è¡¨ç¤ºå‚ä¸è€…çš„æ€§åˆ«ï¼Œå¦‚æœæ˜¯ç”·ç”Ÿåˆ™ä¸º1ï¼Œå¦åˆ™ä¸º0ï¼›ç¬¬äºŒä¸ªstringè¾“å…¥è¡¨ç¤ºå‚ä¸è€…çš„å§“åã€‚ 123456787 71 Jack0 Lisa1 Jackson0 Rose0 Jisoo1 Jack0 Jennie Sample Output 12345678910111213Hi! My name is Jack. I have no classmates here.Hi! My name is Lisa. I have only 1 classmate here.Hi! My name is Jackson. I have 2 classmates here.Hi! My name is Rose. I have 3 classmates here.Hi! My name is Jisoo. I have 4 classmates here.Hi! My name is Jack. I have 5 classmates here.Hi! My name is Jennie. I have 6 classmates here.The number of people is 14. The number of students is 7. The number of girls is 4. The number of boys is 3.The number of people is 13. The number of students is 6. The number of girls is 4. The number of boys is 2.The number of people is 12. The number of students is 5. The number of girls is 3. The number of boys is 2.The number of people is 11. The number of students is 4. The number of girls is 3. The number of boys is 1.The number of people is 10. The number of students is 3. The number of girls is 2. main.cpp(lock) 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &quot;Student.h&quot;using namespace std;void clear()&#123; Student::person_num = 0; total();&#125;int main()&#123; int curr_people = 0, student_num = 0; cin &gt;&gt; curr_people &gt;&gt; student_num; Student* student_list[student_num]; Student::person_num += curr_people; for(int i = 0; i &lt; student_num; ++i)&#123; string name = &quot;&quot;; int isBoy = 0; cin &gt;&gt; isBoy &gt;&gt; name; student_list[i] = new Student(isBoy, name); student_list[i]-&gt;sayHi(); &#125; total(); // å­¦ç”Ÿé€€åœº cout &lt;&lt; endl; for(int i = 0; i &lt; student_num; ++i)&#123; delete student_list[i]; total(); &#125; clear(); // å˜‰å®¾ä»¥åŠä¸¾åŠæ–¹ç¦»åœº return 0;&#125; student.h(lock) 12345678910111213141516171819202122#ifndef STUDENT_H#define STUDENT_H#include &lt;iostream&gt;using namespace std;class Student&#123; public: static int girl_num; static int boy_num; static int person_num; Student(int gender, string name); ~Student(); void sayHi(); private: string name; int gender;&#125;;void total();#endif student.cpp 12345678910111213141516171819202122232425262728293031323334int Student:: girl_num=0;int Student:: boy_num=0;int Student:: person_num=0;Student::Student(int g,string n):gender(g),name(n)&#123; if(g ==1)&#123; boy_num++; &#125;else&#123; girl_num++; &#125; person_num++;&#125;Student::~Student()&#123; if(gender ==1)&#123; boy_num--; &#125;else&#123; girl_num--; &#125; person_num--;&#125;void Student:: sayHi()&#123; cout&lt;&lt;&quot;Hi! My name is &quot;&lt;&lt;name&lt;&lt;&quot;. I have &quot;; if(boy_num+girl_num==2) cout&lt;&lt;&quot;only 1 classmate here.&quot;&lt;&lt;endl; if(boy_num+girl_num==1) cout&lt;&lt;&quot;no classmates here.&quot;&lt;&lt;endl; if(boy_num+girl_num&gt;2) cout&lt;&lt;boy_num+girl_num-1&lt;&lt;&quot; classmates here.&quot;&lt;&lt;endl;&#125;void total()&#123; if(Student::person_num==0) cout&lt;&lt;&quot;There is nobody here.&quot;&lt;&lt;endl; cout&lt;&lt;&quot;The number of people is &quot;&lt;&lt;Student::person_num&lt;&lt;&quot;. The number of students is &quot;&lt;&lt;Student::boy_num+Student::girl_num&lt;&lt;&quot;. The number of girls is &quot;&lt;&lt;Student::girl_num&lt;&lt;&quot;. The number of boys is &quot;&lt;&lt;Student::boy_num&lt;&lt;&quot;.&quot;&lt;&lt;endl;&#125; æ³¨æ„ å…¨å±€å‡½æ•°åœ¨ä½¿ç”¨é™æ€å˜é‡æ—¶,éœ€è¦åœ¨å‰é¢åŠ ä¸€ä¸ªStudent:: å¦‚ä½•åˆå§‹åŒ–é™æ€å˜é‡ int student:: girl_num=0;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•--inservice(è™šç»§æ‰¿)","slug":"ç¨‹è®¾/inservice","date":"2022-04-16T10:53:12.353Z","updated":"2022-05-09T14:50:58.092Z","comments":true,"path":"2022/04/16/ç¨‹è®¾/inservice/","link":"","permalink":"http://example.com/2022/04/16/%E7%A8%8B%E8%AE%BE/inservice/","excerpt":"","text":"Description Please complete the following 4 classes: Person, Student, Worker, Inservice. Note: Person owns data member name and sex, the output format is (For more detail, see the sample output): 1234// you should add this ouput statement in the constructorcout &lt;&lt; &quot;Construct Person&quot; &lt;&lt; endl;// you should add this ouput statement in the destructorcout &lt;&lt; &quot;Destruct Person&quot; &lt;&lt; endl; Student is a derived class of Person, its data member is a string sno (å­¦å·), its constructor has to print Construct Student and its destructor has to print Destruct Student. Worker is a derived class of Person, its data member is a string wno (èŒå‘˜å·), its constructor has to print Construct Worker and its destructor has to print Destruct Worker. Please think the relationship between InService and Student/Worker, and implement InService class by yourself. with its constructor prints Construct InService and its destructor prints Destruct InService. Sample Input 1234amblpo11315467110814061 Sample Output 12345678910111213141516Construct PersonConstruct StudentConstruct WorkerConstruct InServiceamblpo1amblpo113154671amblpo110814061Destruct InServiceDestruct WorkerDestruct StudentDestruct Person Hints è™šç»§æ‰¿ main.cpp(lock) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &quot;inservice.h&quot;using namespace std; int main() &#123; string name, sno, wno; int sex; cin &gt;&gt; name; cin &gt;&gt; sex; cin &gt;&gt; sno; cin &gt;&gt; wno; InService is(name, sex, sno, wno); Person* p = &amp;is; Student* s = &amp;is; Worker* w = &amp;is; cout &lt;&lt; p-&gt;getName() &lt;&lt; endl; cout &lt;&lt; p-&gt;getSex() &lt;&lt; endl; cout &lt;&lt; s-&gt;getName() &lt;&lt; endl; cout &lt;&lt; s-&gt;getSex() &lt;&lt; endl; cout &lt;&lt; s-&gt;getSno() &lt;&lt; endl; cout &lt;&lt; w-&gt;getName() &lt;&lt; endl; cout &lt;&lt; w-&gt;getSex() &lt;&lt; endl; cout &lt;&lt; w-&gt;getWno() &lt;&lt; endl; return 0;&#125; inservice.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Person&#123; string name; int sex;public:Person(string n,int s):name(n),sex(s)&#123; cout &lt;&lt; &quot;Construct Person&quot; &lt;&lt; endl;&#125;string getName() &#123; return name;&#125;~Person()&#123; cout&lt;&lt; &quot;Destruct Person&quot; &lt;&lt;endl;&#125;int getSex() &#123; return sex;&#125;&#125;;class Student: virtual public Person&#123; string sno;public:Student(string n,int s,string o): Person(n,s),sno(o)&#123; cout &lt;&lt; &quot;Construct Student&quot; &lt;&lt; endl;&#125;string getSno() &#123; return sno;&#125;~Student()&#123; cout&lt;&lt; &quot;Destruct Student&quot; &lt;&lt; endl;&#125;&#125;;class Worker: virtual public Person&#123; string wno;public: Worker(string n,int s,string o):Person(n,s),wno(o)&#123; cout&lt;&lt; &quot;Construct Worker&quot; &lt;&lt;endl; &#125; string getWno() &#123; return wno; &#125; ~Worker()&#123; cout&lt;&lt; &quot;Destruct Worker&quot; &lt;&lt;endl; &#125;&#125;;class InService: public Student, public Worker&#123;public: InService(string n, int se, string sn, string wn):Person(n, se), Student(n, se, sn), Worker(n, se, wn)&#123; cout &lt;&lt; &quot;Construct InService&quot; &lt;&lt; endl; &#125; ~InService()&#123; cout&lt;&lt; &quot;Destruct InService&quot; &lt;&lt;endl; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•--matrix and vector","slug":"ç¨‹è®¾/matrix and vector","date":"2022-04-16T09:17:05.200Z","updated":"2022-04-19T11:37:13.800Z","comments":true,"path":"2022/04/16/ç¨‹è®¾/matrix and vector/","link":"","permalink":"http://example.com/2022/04/16/%E7%A8%8B%E8%AE%BE/matrix%20and%20vector/","excerpt":"","text":"Problem Description Matrix can be stored in a one-dimensional vector in a row-first way, inheriting from the Vector class. According to Vector.h and Matrix.h, complete the implementation of Vector class and Matrix class. Function description: Vector::getModule() gets the modulus length of the vector, Matrix::Symmetric() judges whether the matrix is a symmetric matrix. çŸ©é˜µå¯ä»¥ä»¥è¡Œä¼˜å…ˆçš„æ–¹å¼å­˜å‚¨åœ¨ä¸€ç»´å‘é‡ä¸­, ç»§æ‰¿äºVectorç±»ã€‚æ ¹æ®Vector.hå’ŒMatrix.hå®ŒæˆVectorç±»å’ŒMatrixç±»çš„å®ç°ã€‚ å‡½æ•°è¯´æ˜ï¼šVector::getModule()æ±‚å¾—å‘é‡çš„æ¨¡é•¿ï¼Œ Matrix::Symmetric()åˆ¤æ–­çŸ©é˜µæ˜¯ä¸æ˜¯å¯¹ç§°çŸ©é˜µã€‚ HINT å‘é‡çš„æ¨¡é•¿å°±æ˜¯å‘é‡çš„é•¿åº¦ï¼ˆæˆ–ç§°æ¨¡ï¼‰ã€‚ è¾“å…¥ å‘é‡é•¿åº¦n å‘é‡nä¸ªå…ƒç´ çš„å€¼ çŸ©é˜µè¡Œrow çŸ©é˜µåˆ—col çŸ©é˜µå…ƒç´  è¾“å‡º å‘é‡æ¨¡é•¿ çŸ©é˜µå…ƒç´ ä¸ªæ•° çŸ©é˜µæ˜¯å¦ä¸ºå¯¹ç§°çŸ©é˜µ [Sample Input1] 3 0 0 0 3 3 1 0 0 0 1 0 0 0 1 [Sample Output1] Vector Module: 0 Total Elements in Matrix: 9 Symmetric matrix: 1 [Sample Input2] 3 3 4 0 3 3 3 0 1 0 4 0 1 0 5 [Sample Output2] Vector Module: 5 Total Elements in Matrix: 9 Symmetric matrix: 1 framwork.cpp(lock) 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&quot;vector_matrix.h&quot;using namespace std;int main()&#123; int vector_dimension; cin &gt;&gt; vector_dimension; int* vector_elements = new int[vector_dimension]; for(int i=0;i&lt;vector_dimension;i++) cin &gt;&gt; vector_elements[i]; int row, col; cin &gt;&gt; row &gt;&gt; col; int* matrix_elements = new int[row*col]; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) cin &gt;&gt; matrix_elements[i*row+j]; &#125; Vector v(row,vector_elements); cout&lt;&lt;&quot;Vector Module: &quot;&lt;&lt;v.getModule()&lt;&lt;endl; Matrix m(row,col,matrix_elements); cout&lt;&lt; &quot;Total Elements in Matrix: &quot; &lt;&lt; m.getDimension()&lt;&lt;endl; cout&lt;&lt; &quot;Symmetric matrix: &quot;&lt;&lt;m.Symmetric()&lt;&lt;endl; return 0;&#125; vector_matrix.h(lock) 123456789101112131415161718192021222324252627#ifndef VECTOR_MATRIX_H#define VECTOR_MATRIX_H#include&lt;iostream&gt;using namespace std;class Vector&#123;public: Vector(); Vector(int dim, const int* elements_); ~Vector(); int getDimension() const; int *getElements() const; double getModule() const; //æ±‚å‘é‡çš„æ¨¡é•¿ private: int dimension; //å‘é‡çš„ç»´åº¦ int *elements; //å­˜å‚¨å‘é‡å…ƒç´ çš„æ•°ç»„&#125;;class Matrix: public Vector&#123;public: Matrix(); Matrix(int row, int col, const int* elements_); //çŸ©é˜µçš„è¡Œåˆ—ä»¥åŠçŸ©é˜µå…ƒç´ ï¼ˆè¡Œä¼˜å…ˆæ–¹å¼å­˜å‚¨åœ¨ä¸€ç»´æ•°ç»„ä¸­ï¼‰ bool Symmetric() const; //åˆ¤æ–­æ˜¯å¦ä¸ºå¯¹ç§°çŸ©é˜µprivate: int row; //çŸ©é˜µçš„è¡Œ&#125;;#endif vector_matrix.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Vector:: Vector()&#123; dimension=0; elements=NULL;&#125;Vector:: Vector(int dim, const int* elements_)&#123; dimension=dim; elements=new int [dim]; for(int i=0;i&lt;dim;i++)&#123; elements[i]=elements_[i]; &#125;&#125;Vector:: ~Vector()&#123; if(elements!=NULL)&#123; delete [] elements; &#125;&#125; int Vector:: getDimension() const&#123; return dimension;&#125;int* Vector:: getElements() const&#123; return elements;&#125;double Vector:: getModule() const&#123; double sum=0; for(int i=0;i&lt;dimension;i++)&#123; sum+=elements[i]*elements[i]; &#125; sum= sqrt(sum); return sum;&#125;Matrix:: Matrix()&#123; row=0;&#125;Matrix:: Matrix(int row, int col, const int* elements_):Vector(row*col,elements_)&#123; this-&gt;row=row;&#125; //çŸ©é˜µçš„è¡Œåˆ—ä»¥åŠçŸ©é˜µå…ƒç´ ï¼ˆè¡Œä¼˜å…ˆæ–¹å¼å­˜å‚¨åœ¨ä¸€ç»´æ•°ç»„ä¸­ï¼‰bool Matrix:: Symmetric() const&#123; int col=getDimension()/row; if(col!=row) return false; //int temp [row][col]; int **temp=new int* [row]; for(int i=0;i&lt;row;i++)&#123; temp[i]=new int [col]; &#125; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; temp[i][j]=getElements()[col*i+j]; &#125; &#125; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;col;j++)&#123; if(temp[i][j]!=temp[j][i]) return false; &#125; &#125; for(int i=0;i&lt;row;i++)&#123; delete [] temp[i]; &#125; delete [] temp; return true;&#125; //åˆ¤æ–­æ˜¯å¦ä¸ºå¯¹ç§°çŸ©é˜µ","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"setçš„ä½¿ç”¨","slug":"ç¨‹è®¾/set çš„ä½¿ç”¨","date":"2022-04-12T07:29:07.770Z","updated":"2022-04-13T07:38:48.067Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/set çš„ä½¿ç”¨/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/set%20%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"C++ STL setå®¹å™¨å®Œå…¨æ”»ç•¥ï¼ˆè¶…çº§è¯¦ç»†ï¼‰ (biancheng.net) 1234567891011121314//å¤´æ–‡ä»¶#include&lt;set&gt;using namespace std;//template &lt; class T, // é”® key å’Œå€¼ value çš„ç±»å‹ class Compare = less&lt;T&gt;, // æŒ‡å®š set å®¹å™¨å†…éƒ¨çš„æ’åºè§„åˆ™ class Alloc = allocator&lt;T&gt; // æŒ‡å®šåˆ†é…å™¨å¯¹è±¡çš„ç±»å‹ &gt; class set;set&lt;int&gt; myset; ç›¸å…³å‡½æ•° 1234567891011121314151617set&lt;int&gt; a;//å‘setä¸­æ’å…¥å…ƒç´ a.insert(1);a.insert(2);a.insert(2);//setä¸­å…ƒç´ çš„ä¸ªæ•°a.size();//è¿”å›setå®¹å™¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€a.begin();//è¿”å›setå®¹å™¨çš„æœ€åä¸€ä¸ªå…ƒç´ çš„åœ°å€a.end();//åˆ é™¤setå®¹å™¨ä¸­çš„æ‰€æœ‰å…ƒç´ a.clear();//åˆ¤æ–­setå®¹å™¨æ˜¯å¦ä¸ºç©ºa.empty();//è¿”å›setå®¹å™¨ä¸­å¯èƒ½åŒ…å«çš„å…ƒç´ çš„æœ€å¤§ä¸ªæ•°a.max_size(); å¦‚ä½•ä¿®æ”¹seté‡Œé¢çš„é»˜è®¤æ’åºé¡ºåº 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;/*setä¸listå®¹å™¨æ’åºåŒºåˆ«ï¼šlistå®¹å™¨çš„æ’åºæ˜¯ä¸€ä¸ªè‡ªå¸¦çš„sortæˆå‘˜å‡½æ•°ï¼Œéœ€è¦åœ¨sortä¸­ä¼ ä¸€ä¸ªå‡½æ•°åæ¥æŒ‡å®šæ’åºè§„åˆ™ï¼›setæ˜¯é»˜è®¤æ’å…¥æ•°æ®å°±è‡ªåŠ¨æ’åºçš„ï¼Œæ‰€ä»¥éœ€è¦åœ¨æ’æ•°æ®ä¹‹å‰ç”¨ä»¿å‡½æ•°æŒ‡å®šæ’åºè§„åˆ™*//*************************************setå®¹å™¨å†…ç½®æ•°æ®ç±»å‹æ’åº***************************/void printfIntSet(set&lt;int&gt;&amp; s)//æ‰“å°å†…ç½®æ•°æ®ç±»å‹intæ•°ç»„çš„å‡½æ•°&#123; for (set&lt;int&gt;::iterator it = s.begin();it != s.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;/*ä»¿å‡½æ•°*/class myCompare//intæ•°ç»„æ¯”è¾ƒå¤§å°çš„ç±»ï¼Œä¹Ÿå¯ç§°ä¸ºæ•°æ®ç±»å‹&#123;public: bool operator()(int v1, int v2)//ä»¿å‡½æ•°çš„è¿”å›å€¼æ˜¯boolç±»å‹ï¼Œé‡è½½äº†() è¿ç®—ç¬¦ &#123; return v1 &gt; v2; &#125;&#125;;void test01()//setå®¹å™¨å†…ç½®æ•°æ®ç±»å‹æ’åº&#123; set&lt;int&gt; s; s.insert(10); s.insert(100); s.insert(1); s.insert(5); s.insert(80); printfIntSet(s);//é»˜è®¤æ˜¯ä»å°åˆ°å¤§ set&lt;int, myCompare&gt; s1;//åœ¨å®šä¹‰æ•°ç»„çš„æ—¶å€™æŒ‡å®šæ’åºè§„åˆ™ s1.insert(10); s1.insert(100); s1.insert(1); s1.insert(5); s1.insert(80); for (set&lt;int,myCompare&gt;::iterator it = s1.begin();it != s1.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;;//æ•°æ®è¾“å‡ºå˜æˆé™åºäº† &#125;&#125;/*************************************setå®¹å™¨è‡ªå®šä¹‰æ•°æ®ç±»å‹æ’åº***************************///è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹æ’å…¥setå®¹å™¨å¦‚æœä¸æŒ‡å®šæ’åºè§„åˆ™ï¼Œç¼–è¯‘å™¨ä¸çŸ¥é“è¯¥æ€ä¹ˆæ’åºï¼Œæ‰€ä»¥å¿…é¡»æŒ‡å®šæ’åºè§„åˆ™class Person//è‡ªå®šä¹‰æ•°æ®ç±»å‹&#123;public: Person(string name, int age) &#123; this-&gt;m_name = name; this-&gt;m_age = age; &#125; string m_name; int m_age;&#125;;class Compare//æŒ‡å®šæ’åºè§„åˆ™çš„ä»¿å‡½æ•°&#123;public: bool operator()(const Person &amp;p1, Person &amp;p2)//åŠ consté™å®šä¸èƒ½ä¿®æ”¹ä¼ å…¥çš„æ•°æ® &#123; return p1.m_age &gt; p2.m_age;//é™åº &#125;&#125;;void test02()//setå®¹å™¨è‡ªå®šä¹‰æ•°æ®æ’åº&#123; set&lt;Person,Compare&gt; s; Person p1(&quot;å¼ ä¸‰&quot;, 18); Person p2(&quot;æå››&quot;, 20); Person p3(&quot;ç‹äº”&quot;, 19); Person p4(&quot;èµµå…­&quot;, 27); Person p5(&quot;ç‹å…«&quot;, 15); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); s.insert(p5); for (set&lt;Person, Compare&gt;::iterator it = s.begin();it != s.end();it++) &#123; cout &lt;&lt; it-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125;&#125;int main()&#123; //test01();//å†…ç½®æ•°æ®ç±»å‹æ’åº test02();//è‡ªå®šä¹‰æ•°æ®ç±»å‹æ’åº return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•--unique friend(map)","slug":"ç¨‹è®¾/unique friend","date":"2022-04-12T06:47:54.011Z","updated":"2022-04-19T11:36:58.230Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/unique friend/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/unique%20friend/","excerpt":"","text":"Unique friend Given information about the friend of each person. Print friends that are unique to exactly one person ordered by their name. In the given friend list, each line starts with a person name, followed by the names of the friends of the person. There are 10 persons, and each person has 10 friends. In this problem, you need to write a class FriendsFinder3. Exmaple input Collins Smith Perez Allen Brown Carter Jackson Rodriguez Young Evans Lopez Wilson Martin Williams Hall Lee Thompson Baker Campbell Evans Brown King Jones Jackson Lee Martinez Williams Thomas Moore Carter Thompson Hernandez Lopez Turner Roberts Miller Robinson Taylor Anderson Rodriguez Hernandez Wright Adams Phillips Lewis Hall Young Garcia Jackson Lopez Williams Miller Taylor White Johnson Evans Allen Miller White Smith Parker Phillips Brown Carter Collins Mitchell Adams King Smith Davis Gonzalez Clark Miller Martin Jones Martinez Walker Scott Nelson Garcia Collins Anderson Hall Adams Walker Hill Allen Moore Baker Harris Collins Miller Mitchell Hill Lee Rodriguez Nelson Lewis Wilson Miller Anderson Hall Clark Evans Wright Young Lee Walker Allen Johnson Exmaple output Baker Campbell Davis Gonzalez Harris Jones Lewis Parker Perez Roberts Robinson Thomas Wilson Hint è¾“å‡ºä»…ä¸ºæŸä¸€ä¸ªäººçš„æœ‹å‹çš„äººçš„åå­—ï¼Œæ³¨æ„åå­—æŒ‰å­—å…¸åºè¾“å‡ºã€‚ main.cpp(lock) 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;#include &quot;head.h&quot;int main() &#123; string persons[10]; // persons string friends[10][10]; // friends per person string name; // input persons and friends for (int i = 0; i &lt; 10; ++ i) &#123; // for each of the 10 person cin &gt;&gt; name; persons[i] = name; // input 10 friends per person for (int j = 0; j &lt; 10; ++ j) &#123; cin &gt;&gt; name; friends[i][j] = name; &#125; &#125; FriendsFinder3 ff(persons, friends); ff(); return 0;&#125; head.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;class FriendsFinder3&#123;private: string per[10]; string fri[10][10];public: FriendsFinder3(); FriendsFinder3( string a[10],string b[10][10])&#123; for(int i=0;i&lt;10;i++)&#123; per[i]=a[i]; &#125; for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++)&#123; fri[i][j]=b[i][j]; &#125; &#125; &#125; void operator()()&#123; map&lt; string, int &gt; p; for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++)&#123; p[ fri[i][j] ] +=1; &#125; &#125; map&lt;string,int&gt;::iterator it; for(it=p.begin();it!=p.end();it++)&#123; if(it-&gt;second==1) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;; &#125; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•--[Set & Map] Conference Room Manager","slug":"ç¨‹è®¾/[Set & Map] Conference Room Manager","date":"2022-04-12T06:30:26.161Z","updated":"2022-04-19T11:37:04.668Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/[Set & Map] Conference Room Manager/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/[Set%20&%20Map]%20Conference%20Room%20Manager/","excerpt":"","text":"Description å­¦æ ¡é‡Œæœ‰2ä¸ªä¼šè®®å®¤ï¼Œ1ä¸ªå°ä¼šè®®å®¤å’Œ1ä¸ªå¤§ä¼šè®®å®¤ã€‚æŒ‰ç…§è§„å®šï¼Œå°ä¼šè®®å®¤å’Œå¤§ä¼šè®®å®¤æ¯å¤©å„è‡ªåªæœ‰1ä¸ªç§Ÿå€Ÿåé¢ã€‚å¦‚æœè¦ç§Ÿå€Ÿå°ä¼šè®®å®¤ï¼Œåªéœ€è¦æä¾›ç§Ÿå€Ÿçš„æ—¥æœŸä¿¡æ¯ï¼ˆintç±»å‹ï¼‰å³å¯ï¼›å¦‚æœè¦ç§Ÿå€Ÿå¤§ä¼šè®®å®¤ï¼Œé‚£ä¹ˆä¸ä»…è¦æä¾›ç§Ÿå€Ÿçš„æ—¥æœŸä¿¡æ¯ï¼ˆintç±»å‹ï¼‰ï¼Œè€Œä¸”è¿˜è¦åŒæ—¶æä¾›ç§Ÿå€Ÿè¯¥ä¼šè®®å®¤çš„ç¼˜ç”±ï¼ˆstringç±»å‹ï¼‰ã€‚ ä¼šè®®å®¤çš„ç§Ÿå€Ÿè¿‡ç¨‹æ˜¯æ— ç›‘ç£çš„å’Œå…ˆåˆ°å…ˆå¾—çš„ã€‚â€œæ— ç›‘ç£â€ æ„å‘³ç€åªè¦æŸå¤©æŸä¸ªä¼šè®®å®¤è¿˜æ²¡æœ‰äººç§Ÿå€Ÿï¼Œé‚£ä¹ˆä»»ä½•äººéƒ½å¯ä»¥ç”³è¯·æ­¤ä¼šè®®å®¤è¯¥æ—¥æœŸçš„ä½¿ç”¨æƒï¼›â€œå…ˆåˆ°å…ˆå¾—â€ æ„å‘³ç€å¦‚æœä¼šè®®å®¤æŸå¤©çš„ä½¿ç”¨æƒå·²ç»è¢«å…¶å®ƒäººç§Ÿå€Ÿäº†ï¼Œé‚£ä¹ˆåç»­å¯¹äºåŒä¸€å¤©åŒä¸€ä¸ªä¼šè®®å®¤çš„ç§Ÿå€Ÿç”³è¯·éƒ½ä¼šå¤±è´¥ï¼Œé™¤éåŸæ¥çš„æ‹¥æœ‰è€…ä¸»åŠ¨å–æ¶ˆäº†è¿™ä¸€æ¬¡ç§Ÿå€Ÿã€‚ è¯·æ ¹æ®æç¤ºå®ŒæˆRoomManagerç±»ï¼Œå®ç°è¯¥å­¦æ ¡é‡Œ1å¤§1å°2ä¸ªä¼šè®®å®¤çš„ç§Ÿå€Ÿç®¡ç†ã€‚å…¶ä¸­ï¼ŒRoomManagerç±»åº”è¯¥åŒ…æ‹¬å¦‚ä¸‹çš„åŠŸèƒ½ï¼š set _room1ï¼šç”¨äºå­˜å‚¨æ‰€æœ‰å°ä¼šè®®å®¤ç§Ÿå€Ÿçš„ã€æ—¥æœŸã€‘ä¿¡æ¯ã€‚ map&lt;int, string&gt; _room2ï¼šç”¨äºå­˜å‚¨æ‰€æœ‰å¤§ä¼šè®®å®¤ç§Ÿå€Ÿçš„ã€æ—¥æœŸï¼Œç¼˜ç”±ã€‘ä¿¡æ¯ã€‚ bool InsertAppointment(const int&amp; date)ï¼šå°è¯•ç§Ÿå€Ÿå°ä¼šè®®å®¤ï¼Œå¦‚æœç§Ÿå€ŸæˆåŠŸè¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚ bool InsertAppointment(const int&amp; date, const string&amp; event)ï¼šå°è¯•ç§Ÿå€Ÿå¤§ä¼šè®®å®¤ï¼Œå¦‚æœç§Ÿå€ŸæˆåŠŸè¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚ bool CancelAppointment(const int&amp; room_id, const int&amp; date)ï¼šå–æ¶ˆä¼šè®®å®¤çš„æŸæ¬¡ç§Ÿå€Ÿã€‚å¦‚æœè¯¥ä¼šè®®å®¤å¯¹åº”çš„æ—¥æœŸç¡®å®å·²ç»æœ‰ç§Ÿå€Ÿè®°å½•ï¼Œåˆ™å°†å…¶åˆ é™¤å¹¶è¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚ void PrintAppointments(const int&amp; room_id)ï¼šæŒ‰ç…§æ—¥æœŸçš„å‡åºæ‰“å°æŸä¸ªä¼šè®®å®¤ç›®å‰å·²æœ‰çš„æ‰€æœ‰ç§Ÿå€Ÿè®°å½•ã€‚ Guiding RoomManagerç±»çš„å£°æ˜å¦‚ä¸‹ä»£ç æ®µæ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031class RoomManager &#123; private: // Conference Room 1, the smaller one. // Only require the date information for appointment. set&lt;int&gt; _room1; // Conference Room 2, the bigger one. // Require both date and event information for appointment. map&lt;int, string&gt; _room2; public: // Insert an appointment to the smaller Conference Room (1). bool InsertAppointment(const int&amp; date); // Insert an appointment to the bigger Conference Room (2). bool InsertAppointment(const int&amp; date, const string&amp; event); // Cancel an appointment on designated date. // If room_id == 1, cancel the corresponding appointment of _room1. // If room_id == 2, cancel the corresponding appointment of _room2. bool CancelAppointment(const int&amp; room_id, const int&amp; date); // Print all existing appointments in chronological order. // If room_id == 1, just print the date information. Each piece of information is separated by &#x27; &#x27;. // If room_id == 2, print the information in form of &quot;date(event)&quot;. Each piece of information is separated by &#x27; &#x27;. // If there is no even one existing appointment yet, print &quot;No Appointment&quot;. void PrintAppointments(const int&amp; room_id) const;&#125;; è¯·æ ¹æ®æç¤ºæ‰‹åŠ¨å®ç°RoomManagerç±»é‡Œå£°æ˜çš„4ä¸ªæ–¹æ³•ã€‚ Sample Input 1 123456789101110InsertRoom1 20220601InsertRoom2 20220601 MeetingInsertRoom1 20220602InsertRoom2 20220602 Play LOLInsertRoom1 20220601InsertRoom2 20220601 Keep fit with exerciseCancelRoom2 20220602CancelRoom2 20220603PrintRoom1PrintRoom2 Sample Output 1 12345678910Succeed?: trueSucceed?: trueSucceed?: trueSucceed?: trueSucceed?: falseSucceed?: falseSucceed?: trueSucceed?: false20220601 2022060220220601(Meeting) Sample Input 2 1234567891011121314151615InsertRoom1 20220610CancelRoom2 20220610InsertRoom2 20220611 Academic researchCancelRoom1 20220611InsertRoom1 20220611InsertRoom2 20220610 Quantum reaction experimentPrintRoom1PrintRoom2InsertRoom2 20220611 Satellite launch testCancelRoom2 20220611InsertRoom2 20220611 Satellite launch testInsertRoom2 20220611 Geological surveyInsertRoom2 20220612 Geological surveyInsertRoom2 20220609 Czar nuclear power testPrintRoom2 Sample Output 2 123456789101112131415Succeed?: trueSucceed?: falseSucceed?: trueSucceed?: falseSucceed?: trueSucceed?: true20220610 2022061120220610(Quantum reaction experiment) 20220611(Academic research)Succeed?: falseSucceed?: trueSucceed?: trueSucceed?: falseSucceed?: trueSucceed?: true20220609(Czar nuclear power test) 20220610(Quantum reaction experiment) 20220611(Satellite launch test) 20220612(Geological survey) main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;manager.h&quot;int main() &#123; RoomManager manager; int num_operations; string operation; cin &gt;&gt; num_operations; // How many operations in total. cout &lt;&lt; endl; for(int i=1; i&lt;=num_operations; ++i) &#123; cin &gt;&gt; operation; if(operation == &quot;InsertRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date) &lt;&lt; endl; &#125; else if(operation == &quot;InsertRoom2&quot;) &#123; int date; string event; cin &gt;&gt; date; getline(cin, event); event.erase(0, 1); cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date, event) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(1, date) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom2&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(2, date) &lt;&lt; endl; &#125; else if(operation == &quot;PrintRoom1&quot;) &#123; manager.PrintAppointments(1); cout &lt;&lt; endl; &#125; else &#123; manager.PrintAppointments(2); cout &lt;&lt; endl; &#125; &#125; return 0;&#125; manager.h(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;manager.h&quot;int main() &#123; RoomManager manager; int num_operations; string operation; cin &gt;&gt; num_operations; // How many operations in total. cout &lt;&lt; endl; for(int i=1; i&lt;=num_operations; ++i) &#123; cin &gt;&gt; operation; if(operation == &quot;InsertRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date) &lt;&lt; endl; &#125; else if(operation == &quot;InsertRoom2&quot;) &#123; int date; string event; cin &gt;&gt; date; getline(cin, event); event.erase(0, 1); cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.InsertAppointment(date, event) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom1&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(1, date) &lt;&lt; endl; &#125; else if(operation == &quot;CancelRoom2&quot;) &#123; int date; cin &gt;&gt; date; cout &lt;&lt; &quot;Succeed?: &quot; &lt;&lt; boolalpha &lt;&lt; manager.CancelAppointment(2, date) &lt;&lt; endl; &#125; else if(operation == &quot;PrintRoom1&quot;) &#123; manager.PrintAppointments(1); cout &lt;&lt; endl; &#125; else &#123; manager.PrintAppointments(2); cout &lt;&lt; endl; &#125; &#125; return 0;&#125; manager.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&quot;manager.h&quot;bool RoomManager::InsertAppointment(const int&amp; date)&#123; if(_room1.find(date) != _room1.end())&#123; return false; &#125; else&#123; _room1.insert(date); return true; &#125;&#125;// Insert an appointment to the bigger Conference Room (2).bool RoomManager::InsertAppointment(const int&amp; date, const string&amp; event)&#123; if(_room2.find(date) != _room2.end())&#123; return false; &#125; else&#123; _room2.insert(pair&lt;int,string&gt;(date, event)); return true; &#125;&#125;// Cancel an appointment on designated date.// If room_id == 1, cancel the corresponding appointment of _room1.// If room_id == 2, cancel the corresponding appointment of _room2.bool RoomManager::CancelAppointment(const int&amp; room_id, const int&amp; date)&#123; if(room_id == 1)&#123; set&lt;int&gt;::iterator it; it = _room1.find(date); if(it == _room1.end())&#123; return false; &#125; else&#123; _room1.erase(it); return true; &#125; &#125; else&#123; map&lt;int, string&gt;::iterator it; it = _room2.find(date); if(it == _room2.end())&#123; return false; &#125; else&#123; _room2.erase(it); return true; &#125; &#125;&#125;// Print all existing appointments in chronological order.// If room_id == 1, just print the date information. Each piece of information is separated by &#x27; &#x27;.// If room_id == 2, print the information in form of &quot;date(event)&quot;. Each piece of information is separated by &#x27; &#x27;.// If there is no even one existing appointment yet, print &quot;No Appointment&quot;.void RoomManager::PrintAppointments(const int&amp; room_id) const&#123; if(room_id == 1)&#123; set&lt;int&gt;::iterator it = _room1.begin(); while(it != _room1.end())&#123; cout &lt;&lt;*it&lt;&lt; &#x27; &#x27;; it++; &#125; cout &lt;&lt; endl; &#125; else&#123; map&lt;int, string&gt;::const_iterator it; it = _room2.begin(); while(it != _room2.end())&#123; cout &lt;&lt; it-&gt;first &lt;&lt; &#x27;(&#x27; &lt;&lt;it-&gt;second&lt;&lt; &#x27;)&#x27; &lt;&lt;&#x27; &#x27;; it++; &#125; cout &lt;&lt; endl; &#125;&#125; å‚è€ƒç­”æ¡ˆ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &quot;manager.h&quot;// Implements.bool RoomManager::InsertAppointment(const int&amp; date) &#123; if(_room1.find(date) != _room1.end()) &#123; return false; &#125; else &#123; _room1.insert(date); return true; &#125;&#125;bool RoomManager::InsertAppointment(const int&amp; date, const string&amp; event) &#123; if(_room2.find(date) != _room2.end()) &#123; return false; &#125; else &#123; _room2[date] = event; return true; &#125;&#125;bool RoomManager::CancelAppointment(const int&amp; room_id, const int&amp; date) &#123; if(room_id == 1) &#123; set&lt;int&gt;::iterator sit = _room1.find(date); if(sit == _room1.end()) &#123; return false; &#125; else &#123; _room1.erase(sit); return true; &#125; &#125; else &#123; map&lt;int, string&gt;::iterator mit = _room2.find(date); if(mit == _room2.end()) &#123; return false; &#125; else &#123; _room2.erase(mit); return true; &#125; &#125;&#125;void RoomManager::PrintAppointments(const int&amp; room_id) const &#123; if(room_id == 1) &#123; if(_room1.empty()) &#123; cout &lt;&lt; &quot;No Appointment&quot;; &#125; else &#123; for(auto sit=_room1.begin(); sit!=_room1.end(); ++sit) &#123; cout &lt;&lt; *sit &lt;&lt; &#x27; &#x27;; &#125; &#125; &#125; else &#123; if(_room2.empty()) &#123; cout &lt;&lt; &quot;No Appointment&quot;; &#125; else &#123; for(auto mit=_room2.begin(); mit!=_room2.end(); ++mit) &#123; cout &lt;&lt; mit-&gt;first &lt;&lt; &#x27;(&#x27; &lt;&lt; mit-&gt;second &lt;&lt; &#x27;)&#x27; &lt;&lt; &#x27; &#x27;; &#125; &#125; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(äºŒåä¸€)--account and vip","slug":"ç¨‹è®¾/account","date":"2022-04-12T06:24:09.492Z","updated":"2022-04-12T06:27:47.082Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/account/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/account/","excerpt":"","text":"Description Account æ˜¯ä¸€ä¸ªé“¶è¡Œè´¦æˆ·çš„å®ä½“æ¨¡å‹ï¼Œå®ƒæœ‰ä¸€ä¸ªå±æ€§ balance è¡¨ç¤ºå½“å‰çš„å­˜æ¬¾ä½™é¢ï¼Œæœ‰ä¸€ä¸ªå±æ€§ name è¡¨ç¤ºè´¦æˆ·åï¼ˆä¸åŒçš„è´¦æˆ· name æ˜¯ä¸åŒçš„ï¼‰ï¼Œå¦æœ‰ä¸¤ä¸ªè¡Œä¸ºåˆ†åˆ«è¡¨ç¤ºæŸ¥è¯¢ä½™é¢ getBalance å’ŒæŸ¥è¯¢ç”¨æˆ·å getName æ“ä½œã€‚ ç”±äºç¨‹åºä¸ä»…éœ€è¦ç®¡ç†æŸä¸€ä½é¡¾å®¢çš„è´¦æˆ·ï¼Œè€Œä¸”è¿˜å¯èƒ½æ¶‰åŠå¤§é‡çš„é“¶è¡Œè´¦æˆ·éœ€è¦å¤„ç†ï¼Œæ‰€ä»¥è¿˜åº”å»ºç«‹ä¸€ä¸ªåä¸ºâ€œè´¦æˆ·ç®¡ç†å‘˜â€çš„å®ä½“æ¨¡å‹ï¼Œå®ƒè´Ÿè´£æ‰§è¡Œæ¯ä¸€è´¦æˆ·çš„å¼€è®¾ã€æ’¤é”€å’Œè®¿é—®ç­‰æ“ä½œã€‚æ¯ä¸ªè´¦æˆ·ç®¡ç†å‘˜ç®¡ç†è‹¥å¹²ä¸ªè´¦æˆ·ï¼Œè´¦æˆ·å¯èƒ½ç”±å¤šä¸ªè´¦æˆ·ç®¡ç†å‘˜åŒæ—¶ç®¡ç†ã€‚ è´¦æˆ·ç®¡ç†å‘˜ AccountManager æœ‰ä¸€å±æ€§ accountlist è®°å½•å½“å‰å·²å¼€è®¾çš„æ‰€æœ‰è´¦æˆ·ï¼ŒaccountNumber ä¸ºæŒ‡é’ˆï¼Œå…¶æŒ‡å‘çš„å€¼è®°å½•å½“å‰å·²å¼€è®¾çš„è´¦æˆ·ä¸ªæ•°ï¼ŒSuperVipAccount ä¸ºå¯¹è±¡æŒ‡é’ˆï¼Œå…¶æŒ‡å‘çš„å€¼ä¸ºè¶…çº§ Vip è´¦æˆ·ï¼Œå½“ç®¡ç†å‘˜ç®¡ç†çš„è´¦æˆ·é‡Œæ²¡æœ‰å¼€è®¾è¶…çº§ Vip è´¦æˆ·æ—¶ï¼ŒæŒ‡é’ˆæŒ‡å‘ NULLã€‚è´¦æˆ·å¯ä»¥åœ¨ä¸åŒé“¶è¡Œå¼€è®¾ï¼Œæ‰€ä»¥éœ€è¦æ‹·è´æ„é€ å‡½æ•° AccountManager(const AccountManager&amp;)ï¼Œå°†æ‰€æœ‰ä¿¡æ¯ç§»æ¤ç»™å¦å¤–çš„ç®¡ç†å‘˜ï¼Œæ³¨æ„æ·±å¤åˆ¶ä¸æµ…å¤åˆ¶çš„é—®é¢˜ã€‚ç®¡ç†å‘˜è¿˜æœ‰å¼€è®¾è´¦æˆ· openã€å¼€è®¾è¶…çº§ Vip è´¦æˆ· openSuperVipAccountã€å…³é—­è¶…çº§ Vip è´¦æˆ·closeSuperVipAccountã€è·å–è¶…çº§ Vip è´¦æˆ·ä½™é¢ getBalanceOfSuperVipã€è·å–è´¦æˆ·æ€»æ•° getAccountNumberã€è·å–ç®¡ç†å‘˜æ€»æ•° getManagerNumber è¿™äº›è¡Œä¸ºã€‚ ç‰¹åˆ«çš„ï¼ŒgetBalanceOfSuperVip æœ‰ä¸ª double ç±»å‹çš„å¼•ç”¨å‚æ•°ï¼Œå¦‚æœå·²ç»å¼€è®¾è¶…çº§ Vip åˆ™å°†å…¶ä½™é¢èµ‹å€¼ç»™æ­¤å‚æ•°ï¼Œå¹¶ä¸”å‡½æ•°è¿”å› trueï¼›å¦åˆ™å‚æ•°çš„å€¼ä¸æ”¹å˜ï¼Œå‡½æ•°è¿”å› falseã€‚ è¶…çº§ Vip æ˜¯ç‹¬ç«‹å­˜åœ¨çš„ï¼Œå¼€è®¾å’Œå…³é—­è¶…çº§ Vip çš„æ—¶å€™ä¸éœ€è¦æ”¹å˜ Manager é‡Œçš„ accountlist å’Œ accountNumberã€‚ è¯·å®ç°å¦‚ä¸‹ Account å’Œ AccountManager ç±»çš„å®šä¹‰ï¼Œä»¥å®Œæˆè¯¥è´¦æˆ·ç®¡ç†ç¨‹åº: 123456789101112131415161718192021222324252627282930class Account&#123; private: string name; double balance; public: Account(); Account(string,double); void deposit(double); //å­˜æ¬¾ bool withdraw(double); //å–æ¬¾ string getName() const; //constæˆå‘˜å‡½æ•°ï¼Œè·å–è´¦æˆ·å double getBalance() const; //constæˆå‘˜å‡½æ•°ï¼Œè·å–è´¦æˆ·ä½™é¢ &#125;;class AccountManager&#123; private: Account accountlist[100]; int *accountNumber; //è®°å½•å½“å‰å¼€è®¾çš„è´¦æˆ·æ€»æ•° Account* SuperVipAccount; //è®°å½•è¶…çº§Vipè´¦æˆ· static int ManagerNumber; //staticæˆå‘˜ï¼Œè®°å½•æ‰€æœ‰ç®¡ç†å‘˜æ€»æ•° public: AccountManager(); AccountManager(const AccountManager&amp;); //æ‹·è´æ„é€ å‡½æ•° void open(string); void close(string); void depositByName(string,double); bool withdrawByName(string,double); double getBalanceByName(string); Account getAccountByName(string); main.cpp(lock) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;AccountManager.hpp&quot;#include &lt;iostream&gt;using namespace std;int main() &#123; AccountManager* am = new AccountManager(); string name; double num; string command; while (cin &gt;&gt; command) &#123; if (command == &quot;open&quot;) &#123; cin &gt;&gt; name; am -&gt; open(name); cout &lt;&lt; &quot;Account &quot; &lt;&lt; name &lt;&lt; &quot; opened.&quot; &lt;&lt; endl; &#125; else if (command == &quot;deposit&quot;) &#123; cin &gt;&gt; name &gt;&gt; num; am -&gt; depositByName(name, num); cout &lt;&lt; name &lt;&lt; &quot; deposited &quot; &lt;&lt; num &lt;&lt; endl; num = am -&gt; getBalanceByName(name); cout &lt;&lt; name &lt;&lt; &quot; has &quot; &lt;&lt; num &lt;&lt; endl; &#125; else if (command == &quot;withdraw&quot;) &#123; cin &gt;&gt; name &gt;&gt; num; if (am -&gt; withdrawByName(name, num)) &#123; cout &lt;&lt; name &lt;&lt; &quot; withdrawed &quot; &lt;&lt; num &lt;&lt; endl; num = am -&gt; getBalanceByName(name); cout &lt;&lt; name &lt;&lt; &quot; has &quot; &lt;&lt; num &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Withdraw failed, check the balance.&quot; &lt;&lt; endl; &#125; &#125; else if (command == &quot;check&quot;) &#123; cin &gt;&gt; name; num = am -&gt; getBalanceByName(name); cout &lt;&lt; name &lt;&lt; &quot; has &quot; &lt;&lt; num &lt;&lt; endl; &#125; else if (command == &quot;openvip&quot;) &#123; cin &gt;&gt; name; Account ac = am -&gt; getAccountByName(name); if (ac.getName() == name) &#123; am -&gt; openSuperVipAccount(ac); cout &lt;&lt; &quot;set &quot; &lt;&lt; name &lt;&lt; &quot; as super vip&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;no such Account&quot; &lt;&lt; endl; &#125; &#125; else if (command == &quot;closevip&quot;) &#123; am -&gt; closeSuperVipAccount(); cout &lt;&lt; &quot;super vip closed&quot; &lt;&lt; endl; &#125; else if (command == &quot;quit&quot;) &#123; delete am; return 0; &#125; else &#123; cout &lt;&lt; &quot;No such command.&quot; &lt;&lt; endl; &#125; &#125; delete am; return 0;&#125; account.hpp(lock) 1234567891011121314151617181920#ifndef _ACCOUNT_HPP_#define _ACCOUNT_HPP_#include &lt;string&gt;using std::string;class Account &#123;public: Account(); Account(string, double); void deposit(double); bool withdraw(double); string getName() const; double getBalance() const;private: string name; double balance;&#125;;#endif accountmanager.hpp(lock) 12345678910111213141516171819202122232425262728293031#ifndef _ACCOUNT_MANAGER_HPP_#define _ACCOUNT_MANAGER_HPP_#include &quot;Account.hpp&quot;#include &lt;string&gt;using std::string;class AccountManager &#123;public: AccountManager(); AccountManager(const AccountManager&amp;); //æ‹·è´æ„é€ å‡½æ•° void open(string); void close(string); void depositByName(string,double); bool withdrawByName(string,double); double getBalanceByName(string); Account getAccountByName(string); void openSuperVipAccount(Account&amp;); //å¼€è®¾è¶…çº§Vipè´¦æˆ· void closeSuperVipAccount(); //å…³é—­è¶…çº§Vipè´¦æˆ· bool getBalanceOfSuperVipAccount(double&amp;) const; int getAccountNumber() const; int getManagerNumber() const; ~AccountManager(); //ææ„å‡½æ•° private: Account accountlist[100]; int *accountNumber; //è®°å½•å½“å‰å¼€è®¾çš„è´¦æˆ·æ€»æ•° Account* SuperVipAccount; //è®°å½•è¶…çº§Vipè´¦æˆ· static int ManagerNumber; //staticæˆå‘˜ï¼Œè®°å½•æ‰€æœ‰ç®¡ç†å‘˜æ€»æ•° &#125;;#endif account.cpp 123456789101112131415161718192021222324252627282930#include&lt;Account.hpp&gt;#include&lt;AccountManager.hpp&gt;Account:: Account()&#123; balance=0;&#125;Account:: Account(string a, double b):name(a),balance(b)&#123;&#125;void Account:: deposit(double a)&#123; balance+=a;&#125;bool Account:: withdraw(double a)&#123; if(a&gt;=balance)&#123; return false; &#125;else&#123; balance-=a; return true; &#125;&#125;string Account:: getName() const&#123; return name;&#125;double Account:: getBalance() const&#123; return balance;&#125; accountmanger.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;Account.hpp&gt;#include&lt;AccountManager.hpp&gt;int AccountManager:: ManagerNumber=0;AccountManager:: AccountManager()&#123; accountNumber=new int (0); ManagerNumber++; SuperVipAccount=NULL;&#125;AccountManager:: AccountManager(const AccountManager&amp; a)&#123; accountNumber=new int (a.getAccountNumber()); *accountNumber = *a.accountNumber; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; accountlist[i]=a.accountlist[i]; &#125; if(a.SuperVipAccount != NULL)&#123; SuperVipAccount = new Account(*a.SuperVipAccount); &#125; ManagerNumber++;&#125;void AccountManager:: open(string a)&#123; accountlist[this-&gt;getAccountNumber()] = Account(a,0); (*accountNumber)++;&#125;void AccountManager:: close(string a)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; for(int j=i;j&lt;this-&gt;getAccountNumber()-1;j++)&#123; accountlist[j]=accountlist[j+1]; &#125; &#125; &#125; (*accountNumber)--;&#125;void AccountManager:: depositByName(string a,double b)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; accountlist[i].deposit(b); &#125; &#125;&#125;bool AccountManager:: withdrawByName(string a,double b)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; return accountlist[i].withdraw(b); &#125; &#125;&#125;double AccountManager:: getBalanceByName(string a)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; return accountlist[i].getBalance(); &#125; &#125;&#125;Account AccountManager:: getAccountByName(string a)&#123; for(int i=0;i&lt;this-&gt;getAccountNumber();i++)&#123; if(accountlist[i].getName()==a)&#123; return accountlist[i]; &#125; &#125;&#125;void AccountManager:: openSuperVipAccount(Account&amp; a)&#123; SuperVipAccount=new Account (a);&#125; //å¼€è®¾è¶…çº§Vipè´¦æˆ· void AccountManager:: closeSuperVipAccount()&#123; if(SuperVipAccount != NULL)&#123; delete SuperVipAccount; &#125;&#125; //å…³é—­è¶…çº§Vipè´¦æˆ· bool AccountManager:: getBalanceOfSuperVipAccount(double&amp; a) const&#123; if(SuperVipAccount!=NULL)&#123; a=SuperVipAccount-&gt;getBalance(); return true; &#125; return false;&#125;int AccountManager:: getAccountNumber() const&#123; return *accountNumber;&#125;int AccountManager:: getManagerNumber() const&#123; return ManagerNumber;&#125;AccountManager:: ~AccountManager()&#123; delete accountNumber; accountNumber = nullptr; if(SuperVipAccount != nullptr)&#123; delete SuperVipAccount; SuperVipAccount = nullptr; &#125;&#125; //ææ„å‡½æ•°","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(äºŒå)--songlist(æ‹·è´)","slug":"ç¨‹è®¾/songlist","date":"2022-04-12T06:17:55.001Z","updated":"2022-04-12T06:20:28.725Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/songlist/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/songlist/","excerpt":"","text":"Description Recently, Xiao Ming is developing a music player, which requires model the SongList. He want to implement a simple SongList object. But in the versions he implemented before, the double free or memory leak mistake always show up. As you are excellent C++ developer, he try to ask help from you. He has already written down the declaration of the functions in songList.h. You only need to accomplish the songList.cpp. å°æ˜æœ€è¿‘åœ¨å¼€å‘ä¸€ä¸ªéŸ³ä¹æ’­æ”¾å™¨ï¼Œéœ€è¦å¯¹æ­Œå•è¿›è¡Œå»ºæ¨¡ã€‚ä»–å¸Œæœ›å®ç°ä¸€ä¸ªç®€å•çš„æ­Œå•ç±»ï¼Œä½†æ˜¯åœ¨ä¹‹å‰ä»–è‡ªå·±å®ç°çš„ç‰ˆæœ¬ä¸­ï¼Œæ€»æ˜¯å‡ºç°double freeæˆ–è€…memory leakçš„é”™è¯¯ï¼Œä»–å¬é—»ä½ C++å­¦å¾—ä¸é”™ï¼Œå‘ä½ æ±‚åŠ©æ¥äº†ã€‚ä»–åœ¨songList.hå¤´æ–‡ä»¶ä¸­å·²ç»å†™å¥½äº†å‡½æ•°çš„å£°æ˜ï¼Œå¸Œæœ›ä½ èƒ½åœ¨songList.cppä¸­å°†å®šä¹‰å®Œå–„ã€‚ Sample Input The first line is an int variable numSongs, which indicates the number of songList1. And the next numSongs line are the songs' name. ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´å‹å˜é‡numSongsï¼Œè®°å½•ç¬¬ä¸€ä¸ªæ­Œå•çš„ä¸ªæ•°ï¼Œæ¥ä¸‹æ¥çš„numSongsè¡Œåˆ†åˆ«æ˜¯æ­Œæ›²åå­—ã€‚ 1232We Choose To Go To The MoonA Lovely Wedding - Snowand Sky Sample Output The output will show songList1ã€songList2ã€songList3, the songList1will be initiated by the songs in the input and add toAddAndRemoved twice, but the songList should do the elimination so it should be store once. songList2 is copied from songList1 and will remove toAddAndRemoved, songList3 is initiated from songList2 but clear it songs after that, so it shoule be empty. è¾“å‡ºä¼šæ˜¾ç¤ºä¸‰ä¸ªæ­Œå•ï¼ŒsongList1é€šè¿‡è¾“å‡ºçš„æ­Œæ›²åˆå§‹åŒ–ï¼Œå¹¶æ·»åŠ ä¸¤æ¬¡æ­Œæ›²toAddAndRemovedï¼ˆLights Frightened The Captainï¼‰ï¼Œä½†å› ä¸ºå»é‡çš„åŸå› å®é™…åªæ·»åŠ ä¸€æ¬¡ã€‚songList2é€šè¿‡songList1æ‹·è´å¾—åˆ°ï¼Œå¹¶åˆ é™¤toAddAndRemovedã€‚songList3é€šè¿‡songList2åˆå§‹åŒ–ï¼Œå¹¶æ¸…ç©ºæ­Œå•ã€‚ 123456789101112owner:MakaBakaSongs:We Choose To Go To The MoonA Lovely Wedding - Snowand SkyLights Frightened The Captainowner:MakaBakaSongs:We Choose To Go To The MoonA Lovely Wedding - Snowand SkyMakaBaka&#x27;s SongList is Empty. Note è¾“å‡ºè¿ç®—ç¬¦é‡è½½ï¼š å¦‚æœæ­Œå•ä¸ºç©ºï¼Œåˆ™è¾“å‡º&lt;owner&gt;'s SongList is Empty.ï¼Œå…¶ä¸­owneræ˜¯æ­Œå•ç±»çš„æˆå‘˜å˜é‡ã€‚ å¦‚æœæ­Œå•ä¸ä¸ºç©ºï¼Œåˆ™è¾“å‡º 12345owner:&lt;owner&gt;Songs:&lt;song1&gt;&lt;song2&gt;... Hint æ¸…ç©ºæ­Œæ›²æ˜¯å¦éœ€è¦çœŸçš„æŠŠæ­Œæ›²åˆ é™¤ï¼Ÿ æ‹·è´å‡½æ•°éœ€è¦è€ƒè™‘ä»€ä¹ˆï¼Ÿ èµ‹å€¼æ‹·è´å‡½æ•°éœ€è¦è€ƒè™‘å“ªä¸‰ä»¶äº‹ï¼Ÿ songlist.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;string&gt;#include &lt;iostream&gt;#include&lt;songList.h&gt;using namespace std;SongList:: SongList(const std::string _owner, unsigned int _size, unsigned int _capacity, std::string *_songs)&#123; owner=_owner; size=_size; capacity=_capacity; songs=new string[capacity]; for(int i=0;i&lt;size;i++)&#123; songs[i]=_songs[i]; &#125;&#125;SongList:: SongList(const SongList &amp;a)&#123; owner=a.owner; size=a.size; capacity=a.capacity; songs=new string[capacity]; for(int i=0;i&lt;size;i++)&#123; songs[i]=a.songs[i]; &#125;&#125;void SongList:: addSong(const std::string &amp;song)&#123; for(int i=0;i&lt;size;i++)&#123; if(song==songs[i]) return; &#125; if(size==capacity)&#123; string *newsongs=new string [capacity+1]; int i; for(i=0;i&lt;size;i++)&#123; newsongs[i]=songs[i]; &#125; newsongs[i]=song; delete [] songs; songs=new string [capacity+1]; for(i=0;i&lt;size+1;i++)&#123; songs[i]=newsongs[i]; &#125; delete [] newsongs; size++; capacity++; &#125;else&#123; songs[size]=song; size++; &#125;&#125; // åˆ é™¤æŒ‡å®šæ­Œæ›²ï¼Œæ­Œæ›²ä¸å­˜åœ¨åˆ™æ— åŠ¨ä½œvoid SongList:: removeSong(const std::string &amp;song)&#123; for(int i=0;i&lt;size;i++)&#123; if(songs[i]==song)&#123; for(int j=i;j&lt;size-1;j++)&#123; songs[j]=song[j+1]; &#125; size--; return; &#125; &#125;&#125; // æ¸…ç©ºæ­Œæ›²void SongList:: clearSong()&#123; size=0;&#125;SongList &amp; SongList::operator=(const SongList &amp;a)&#123; if (&amp;a != this) &#123; *this=SongList(a); &#125; return *this;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;os, const SongList &amp;a)&#123; if(a.size==0)&#123; os&lt;&lt;a.owner&lt;&lt;&quot;&#x27;s SongList is Empty.&quot;&lt;&lt;endl; return os; &#125;else&#123; os&lt;&lt;&quot;owner:&quot;&lt;&lt;a.owner&lt;&lt;endl; os&lt;&lt;&quot;Songs:&quot;&lt;&lt;endl; for(int i=0;i&lt;a.size;i++)&#123; os&lt;&lt;a.songs[i]&lt;&lt;endl; &#125; return os; &#125;&#125;SongList:: ~SongList()&#123; delete [] songs;&#125; songlist.h(lock) 12345678910111213141516171819202122232425262728293031323334353637383940#ifndef SONGLIST_H#define SONGLIST_H#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class SongList &#123; std::string owner; // æ­Œå•æ‹¥æœ‰è€… unsigned int size; // æ­Œå•ä¸­æœ‰æ•ˆæ­Œæ›²çš„æ•°é‡ unsigned int capacity; // æ­Œå•çš„æœ€å¤§å®¹é‡ std::string *songs; // æ­Œæ›²åˆ—è¡¨ï¼Œä¸€ä¸ªstringæ•°ç»„public: // åˆå§‹åŒ–çš„æ­Œæ›²åˆ—è¡¨ä¸­ä¼šä¿è¯æ²¡æœ‰é‡å¤æ­Œæ›² SongList(const std::string _owner, unsigned int _size, unsigned int _capacity, std::string *_songs); SongList(const SongList &amp;songList); // æ·»åŠ æ­Œæ›²ï¼Œè¯·è€ƒè™‘å»é‡çš„æƒ…å†µï¼ˆå¦‚æœæ­Œæ›²å·²ç»å­˜åœ¨åˆ™ä¸æ·»åŠ ï¼‰ã€æ­Œå•å·²ç»æ»¡äº†éœ€è¦æ‰©å®¹çš„æƒ…å†µï¼Œæ‰©å®¹æ–¹æ¡ˆè‡ªé€‰ // æ‰©å®¹æ–¹æ¡ˆ1ï¼šåŸåœ°æ‰©å®¹ï¼ŒCè¯­è¨€ä¸­æœ‰ä¸ªreallocå‡½æ•°å¯ä»¥å®ç° // æ‰©å®¹æ–¹æ¡ˆ2ï¼šé‡æ–°å¼€è¾Ÿä¸€ä¸ªæ›´å¤§å®¹é‡songsæ­Œæ›²åˆ—è¡¨ï¼Œå¹¶å°†å½“å‰çš„æ•°æ®è¿ç§»è¿‡å» void addSong(const std::string &amp;song); // åˆ é™¤æŒ‡å®šæ­Œæ›²ï¼Œæ­Œæ›²ä¸å­˜åœ¨åˆ™æ— åŠ¨ä½œ void removeSong(const std::string &amp;song); // æ¸…ç©ºæ­Œæ›² void clearSong(); SongList &amp;operator=(const SongList &amp;songList); friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const SongList &amp;songList); ~SongList();&#125;;#endif //SONGLIST_H framework.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;songList.h&quot;using namespace std;int main() &#123; int numSongs; cin &gt;&gt; numSongs; getchar(); //è¯»å–æ¢è¡Œç¬¦ string name2 = &quot;MakaBaka&quot;; string *songs = new string[numSongs]; for (int i = 0; i &lt; numSongs; ++i) &#123; getline(cin, songs[i]); &#125; string toAddAndRemoved = &quot;Lights Frightened The Captain&quot;; SongList songList1(name2, numSongs, numSongs, songs); songList1.addSong(toAddAndRemoved); songList1.addSong(toAddAndRemoved); delete []songs; SongList songList2(songList1); songList2 = songList2; songList2.removeSong(toAddAndRemoved); SongList songList3 = songList2; songList3.clearSong(); cout &lt;&lt; songList1 &lt;&lt; endl; cout &lt;&lt; songList2 &lt;&lt; endl; cout &lt;&lt; songList3 &lt;&lt; endl; return 0;&#125;/* * ç¤ºä¾‹è¾“å…¥ï¼š * 2 * We Choose To Go To The Moon * A Lovely Wedding - Snowand Sky * * ç¤ºä¾‹è¾“å‡ºï¼š * owner:MakaBaka * Songs: * We Choose To Go To The Moon * A Lovely Wedding - Snowand Sky * Lights Frightened The Captain * * owner:MakaBaka * Songs: * We Choose To Go To The Moon * A Lovely Wedding - Snowand Sky * * MakaBaka&#x27;s SongList is Empty. */","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(åä¹)--make list","slug":"ç¨‹è®¾/make list","date":"2022-04-12T06:14:03.981Z","updated":"2022-05-08T08:25:22.000Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/make list/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/make%20list/","excerpt":"","text":"Description Input multiple lines of numbers from the console, please to allocate arrays of double variable to store these lines. Then, use a pointer array to store the addresses of these double arrays. You need to implement the two functions: double** make_list(double data[], int sizes[]) and void free_lists(double* lists[]) . Input format There are N lines input and each line contains no more than M double number( 1&lt;=N&lt;=20, 1&lt;=M&lt;=10). Output format The same numbers as input. Example input 1234560.288 0.919 0.130 0.610 0.696 0.616 0.7790.949 0.982 0.861 0.608 0.156 0.6170.294 0.384 0.980 0.203 0.5020.286 0.157 0.866 0.329 0.7330.269 0.370 0.6690.473 0.829 0.509 0.714 Example output 1234560.288 0.919 0.130 0.610 0.696 0.616 0.7790.949 0.982 0.861 0.608 0.156 0.6170.294 0.384 0.980 0.203 0.5020.286 0.157 0.866 0.329 0.7330.269 0.370 0.6690.473 0.829 0.509 0.714 source.h 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;double** make_list(double data[], int sizes[])&#123; double** a=NULL; int i=0,num=0; for(i=0;sizes[i]!=0;i++)&#123;&#125; a=new double*[i+1]; a[i]=NULL; for(int j=0;sizes[j]!=0;j++)&#123; a[j]= new double[sizes[j]]; &#125; for(int m=0;m&lt;i;m++)&#123; for(int n=0;n&lt;sizes[m];n++)&#123; a[m][n]=data[num++]; &#125; &#125; return a; &#125;void free_lists(double* lists[])&#123; for(int i=0;lists[i]!=NULL;i++)&#123; delete [] lists[i]; &#125; delete [] lists;&#125; main.cpp 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &quot;source.h&quot;void print_list(double list[], int size) &#123; for (int i = 0; i &lt; size; ++ i) printf(&quot;%.3lf &quot;, list[i]); putchar(&#x27;\\n&#x27;);&#125;void print_lists(double * lists[], int sizes[]) &#123; for (int i = 0; ; ++ i) &#123; if (lists[i] == NULL) break; print_list(lists[i], sizes[i]); &#125;&#125;// read a number of double data in a signle line, returns the number of data redint read_data_line(double data[]) &#123; char line[1000]; if (fgets(line, 1000, stdin) == NULL) return 0; return sscanf(line, &quot;%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf&quot;, data, data+1, data+2, data+3, data+4, data+5, data+6, data+7, data+8, data+9);&#125;int main() &#123; double data[1000]; int num_data_per_line[20] = &#123;0&#125;; int total = 0; for (int i = 0; i &lt; 20; ++ i) &#123; int num_data = read_data_line(data + total); if (num_data &lt;= 0) num_data = 0; total += num_data; num_data_per_line[i] = num_data; if (num_data == 0) break; &#125; // TODO: allocate a list of pointers to allocated lists of doubles double ** lists = make_list(data, num_data_per_line); print_lists(lists, num_data_per_line); free_lists(lists);&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(åå…«)--cat and catfamily","slug":"ç¨‹è®¾/cat and catfamily","date":"2022-04-12T06:11:15.041Z","updated":"2022-04-12T06:13:18.428Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/cat and catfamily/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/cat%20and%20catfamily/","excerpt":"","text":"é¢˜ç›® ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ä¿¡æ¯ç³»ç»Ÿçš„ä¾‹å­ã€‚è¿™ä¸ªä¾‹å­ä¸­ç¼ºå°‘Catç±»å’ŒCatFamilyç±»ï¼ˆå‡è®¾CatFamilyä¸­è‡³å¤šæœ‰100åªçŒ«ï¼‰ã€‚ è¯·é˜…è¯»C++ä¸»ç¨‹åºï¼Œå¹¶äº†è§£ç±»ä½ éœ€è¦å®ç°ä¸€äº›ä»€ä¹ˆã€‚ EXAMPLE INPUT 2 CWIGAKZPB 4 4 3 PAUGOCDWM 4 1 XLAQWFT 10 2 ZINYSVEH 4 2 ZTYMHJGO 3 YITJLASK 4 2 CIXSDKMZ 4 2 XLAQWFT 2 KLPMURWX 4 2 USFTVBJMK 4 1 HAFGM 2 1 NVUIH 4 0 EXAMPLE OUTPUT Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: CWIGAKZPB Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game No such cat: PAUGOCDWM Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully added cat: XLAQWFT Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: ZINYSVEH Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: XLAQWFT of 10years old Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: ZTYMHJGO Add a cat Remove a cat Find a cat Print all cats Exit this game No such cat: YITJLASK Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: XLAQWFT of 10years old Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: CIXSDKMZ Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: XLAQWFT of 10years old Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully removed cat: XLAQWFT Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: KLPMURWX Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game Fail to remove cat: USFTVBJMK Add a cat Remove a cat Find a cat Print all cats Exit this game We have these cats: Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully added cat: HAFGM Add a cat Remove a cat Find a cat Print all cats Exit this game Successfully added cat: NVUIH Add a cat Remove a cat Find a cat Print all cats Exit this game See you Hint ä¸ºäº†å®ç°è®¿é—®cat_family[i]ï¼Œä½ éœ€è¦åœ¨ç±»é‡Œé¢å®ç°ä¸‹é¢è¿™ä¸ªæˆå‘˜å‡½æ•° 123string operator[] (int num) const &#123;//return ä¸€ç‚¹ä»€ä¹ˆä¸œè¥¿å‘¢ &#125; source.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std;class Cat&#123; public: int cat_age; string cat_name;&#125;;class CatFamily&#123; public: CatFamily() &#123; numofcat = 0; &#125; int remove_a_cat(string name)&#123; if(has_cat(name) ==1 )&#123; for(int i=0;i&lt;number_of_cats();i++)&#123; if( a[i].cat_name==name ) &#123; a[i] = a[number_of_cats() - 1]; numofcat--; return 1; &#125; &#125; &#125; return 0; &#125; int has_cat(string b)const&#123; for(int i=0;i&lt;number_of_cats();i++)&#123; if( a[i].cat_name==b ) return 1; &#125; return 0; &#125; Cat get_cat(string name)const&#123; for(int i=0;i&lt;number_of_cats();i++)&#123; if( a[i].cat_name==name ) return a[i]; &#125; return a[99]; &#125; int add_a_cat(string cat_name,int cat_age)&#123; if(number_of_cats()&lt;=100 &amp;&amp; has_cat(cat_name)==0 )&#123; a[number_of_cats()].cat_name=cat_name; a[number_of_cats()].cat_age=cat_age; numofcat++; return 1; &#125; return 0; &#125; int number_of_cats()const&#123; return numofcat; &#125; string operator[] (int num) const &#123; return a[num].cat_name; &#125;//return ä¸€ç‚¹ä»€ä¹ˆä¸œè¥¿å‘¢ public: Cat a[100]; int numofcat;&#125;; framework.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#include &quot;source.cpp&quot;int main_menu() &#123; cout &lt;&lt; &quot;1. Add a cat&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2. Remove a cat&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3. Find a cat&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4. Print all cats&quot; &lt;&lt; endl; cout &lt;&lt; &quot;0. Exit this game&quot; &lt;&lt; endl; int choice; cin &gt;&gt; choice; return choice;&#125;void add_a_cat(CatFamily &amp; cat_family) &#123; string cat_name; int cat_age; cin &gt;&gt; cat_name &gt;&gt; cat_age; if (cat_family.add_a_cat(cat_name, cat_age)) cout &lt;&lt; &quot;Successfully added cat: &quot; &lt;&lt; cat_name &lt;&lt; endl; else cout &lt;&lt; &quot;Fail to add cat: &quot; &lt;&lt; cat_name &lt;&lt; endl;&#125;void remove_a_cat(CatFamily &amp; cat_family) &#123; string cat_name; cin &gt;&gt; cat_name; if (cat_family.remove_a_cat(cat_name)) cout &lt;&lt; &quot;Successfully removed cat: &quot; &lt;&lt; cat_name &lt;&lt; endl; else cout &lt;&lt; &quot;Fail to remove cat: &quot; &lt;&lt; cat_name &lt;&lt; endl;&#125;void find_a_cat(CatFamily &amp; cat_family) &#123; string cat_name; cin &gt;&gt; cat_name; if (cat_family.has_cat(cat_name)) &#123; cout &lt;&lt; &quot;Here is your cat: &quot; &lt;&lt; cat_family.get_cat(cat_name).cat_name &lt;&lt; &quot; of &quot; &lt;&lt; cat_family.get_cat(cat_name).cat_age &lt;&lt; &quot;years old&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;No such cat: &quot; &lt;&lt; cat_name &lt;&lt; endl;&#125;void print_all_cats(CatFamily &amp; cat_family) &#123; cout &lt;&lt; &quot;We have these cats:&quot; &lt;&lt; endl; for (int i = 0; i &lt; cat_family.number_of_cats(); ++ i) &#123; string cat_name = cat_family[i]; cout &lt;&lt; &#x27;\\t&#x27; &lt;&lt; cat_family.get_cat(cat_name).cat_name &lt;&lt; &quot; of &quot; &lt;&lt; cat_family.get_cat(cat_name).cat_age &lt;&lt; &quot;years old&quot; &lt;&lt; endl; &#125; &#125;int main() &#123; CatFamily cat_family; while (true) &#123; int choice = main_menu(); switch (choice) &#123; case 0: cout &lt;&lt; &quot;See you&quot; &lt;&lt; endl; exit(0); case 1: add_a_cat(cat_family); break; case 2: remove_a_cat(cat_family); break; case 3: find_a_cat(cat_family); break; case 4: print_all_cats(cat_family); &#125; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(åä¸ƒ)--æ ¼å¼æ§åˆ¶(é‡è½½)","slug":"ç¨‹è®¾/æ ¼å¼æ§åˆ¶(é‡è½½)","date":"2022-04-12T06:08:54.657Z","updated":"2022-04-12T06:10:44.884Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/æ ¼å¼æ§åˆ¶(é‡è½½)/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6(%E9%87%8D%E8%BD%BD)/","excerpt":"","text":"Description My books want to have different kinds of formats of a booklist. To improve the reuseability of the code, we should use the object-oriented thought. I design the class Book as below: 123456789class Book&#123; string name; string code; double cost;public: Book(string s,string c,double co):name(s),code(c),cost(co)&#123;&#125;&#125;; The default output format of a Book object requires Each field being right-justified Each field having the same field width: 15 Each number (double) having a forced 6 digits after the decimal dot. The leftform output format of a Book object requires Each field being left-justified Each field having the same field width: 15 Each number (double) having a forced 2 digits after the decimal dot. The rightform output format of a Book object requires Each field being right-justified Each field having the same field width: 15 Each number (double) having a forced 2 digits after the decimal dot. The main function is : 12345678910111213141516171819202122int main() &#123; int N; string name; string code; double cost; cin &gt;&gt; N; int i = 0; Book *books[N]; for(i=0;i&lt;N;i++)&#123; cin &gt;&gt; name &gt;&gt; code &gt;&gt; cost; books[i] = new Book(name, code, cost); &#125; for(i=0;i&lt;N;i++)&#123; cout &lt;&lt; &quot;-----:&quot; &lt;&lt; *books[i]; &#125; for(i=0;i&lt;N;i++)&#123; cout &lt;&lt; leftform &lt;&lt; *books[i]; &#125; for(i=0;i&lt;N;i++)&#123; cout &lt;&lt; rightform &lt;&lt; *books[i]; &#125;&#125; Input First line is the integer N followed by N lines. Each line contains the name, code and cost. The input has been handled by the test framework. Output Please refer to the main function and the sample output. The output has been handled by the test framework. Sample Input 12343book1 123456 342.13book2 456789 23book3 789123 1.2321 Sample Output 123456789-----: book1 123456 342.130000-----: book2 456789 23.000000-----: book3 789123 1.232100left :book1 123456 342.13 left :book2 456789 23.00 left :book3 789123 1.23 right: book1 123456 342.13right: book2 456789 23.00right: book3 789123 1.23 Hint ä¸ºäº†å®ç°cout&lt;&lt;*book[i];ä½ éœ€è¦åœ¨ç±»å£°æ˜å¤„å®ç°è¿™æ ·ä¸€ä¸ªå‡½æ•° 123456789class Book&#123;//...å…¶ä»–æˆå‘˜public:friend ostream &amp; operator &lt;&lt; (ostream &amp; os, const Book &amp; b) &#123;//åƒä¸‹é¢è¿™ä¸ªè¯­å¥æ¥å†™//os&lt;&lt; &quot;something&quot;; return os; &#125;&#125; å¦å¤–ï¼Œä¸ºäº†å®ç°cout&lt;&lt;leftform;ä½ éœ€è¦å®ç°ä¸€ä¸ªè¿™æ ·çš„å‡½æ•°ï¼ˆåœ¨æœ€å¤–éƒ¨ï¼Œä¸åœ¨ç±»é‡Œé¢ï¼‰ 123456ostream &amp; leftform(ostream&amp; strm) &#123;//åƒä¸‹é¢è¿™æ ·å†™//strm &lt;&lt; &quot;right:&quot;;//strm &lt;&lt; setw(15);return strm;&#125; framwork.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;source.h&quot;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stdio.h&gt;using namespace std;int main() &#123; //freopen(&quot;2.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;2.out&quot;,&quot;w&quot;,stdout); int N, M; string name; string code; double cost; cin &gt;&gt; N; M = N; int i = 0; Book *books[N]; while (i++ &lt; N) &#123; cin &gt;&gt; name &gt;&gt; code &gt;&gt; cost; books[i] = new Book(name, code, cost); &#125; i = 0; while (i++ &lt; M) &#123; cout &lt;&lt; &quot;-----:&quot; &lt;&lt; *books[i]; &#125; i = 0; while (i++ &lt; M) &#123; cout &lt;&lt; leftform &lt;&lt; *books[i]; &#125; i = 0; while (i++ &lt; M) &#123; cout &lt;&lt; rightform &lt;&lt; *books[i]; &#125;&#125; source.h 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stdio.h&gt;using namespace std;class Book&#123; string name; string code; double cost;public: Book(string s,string c,double co):name(s),code(c),cost(co)&#123;&#125; friend ostream &amp; operator &lt;&lt; (ostream &amp; os, const Book &amp; b) &#123; //os&lt;&lt; &quot;something&quot;; return os&lt;&lt;setw(15)&lt;&lt;b.name&lt;&lt;setw(15)&lt;&lt;b.code&lt;&lt;setw(15)&lt;&lt;setiosflags(ios::fixed)&lt;&lt;b.cost&lt;&lt;endl; &#125;&#125;;ostream &amp; leftform(ostream&amp; strm) &#123;//åƒä¸‹é¢è¿™æ ·å†™//strm &lt;&lt; &quot;right:&quot;;//strm &lt;&lt; setw(15);strm &lt;&lt; &quot;left :&quot;;strm &lt;&lt; setw(15)&lt;&lt;left;strm &lt;&lt; fixed&lt;&lt;setprecision(2);return strm;&#125;ostream &amp; rightform(ostream&amp; strm) &#123;//åƒä¸‹é¢è¿™æ ·å†™//strm &lt;&lt; &quot;right:&quot;;//strm &lt;&lt; setw(15);strm &lt;&lt; &quot;right:&quot;;strm &lt;&lt; setw(15)&lt;&lt;right;strm &lt;&lt; fixed&lt;&lt;setprecision(2);return strm;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(åå…­)--æ ¼å¼æ§åˆ¶","slug":"ç¨‹è®¾/æ ¼å¼æ§åˆ¶2","date":"2022-04-12T06:06:39.078Z","updated":"2022-04-12T06:07:21.009Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/æ ¼å¼æ§åˆ¶2/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B62/","excerpt":"","text":"é¢˜ç›® Write a program to read a list containing item name (std::string), item code (std::string), and item cost (double) interactively and produce a three-column output satisfying: name and code are left-justified; cost is right-justified with a precision of two digits. Trailing zeros are shown; The field width for name, code and cost are 15, 15, 10, respectively. Input First line is an integer N to specify the number of books, followed with N lines. Each line contains the name, code and cost. Output For each item, output it in the aforementioned format. Sample Input 12343book1 2312123 342.13book2 342 123book3 342 1.2321 Sample Output 123book1 2312123 342.13book2 342 123.00book3 342 1.23 source.cpp 1234567891011121314151617181920#include&lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; string name,code; double cost; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;name&gt;&gt;code&gt;&gt;cost; cout&lt;&lt;setw(15)&lt;&lt;left&lt;&lt;name; cout&lt;&lt;setw(15)&lt;&lt;left&lt;&lt;code; cout&lt;&lt;setw(10)&lt;&lt;right&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;cost&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(åäº”)--æ ¼å¼æ§åˆ¶","slug":"ç¨‹è®¾/æ ¼å¼æ§åˆ¶","date":"2022-04-12T06:03:38.422Z","updated":"2022-04-12T06:05:51.155Z","comments":true,"path":"2022/04/12/ç¨‹è®¾/æ ¼å¼æ§åˆ¶/","link":"","permalink":"http://example.com/2022/04/12/%E7%A8%8B%E8%AE%BE/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/","excerpt":"","text":"é¢˜ç›® It is important to control the format of outputs. Now, an output is given. 1234567891011121314151617181920212223242526control the format of numeric value, 123456789.9876543Default:1.23457e+08Using fixed:123456789.987654With precision 7:123456789.9876543Scientific with precision 3:1.235e+08---------------------------control the base of numeric value, 16Hex:10Oct:20Dec:16---------------------------control the width and alignment, and the width is 6 spacesright aligned 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768left aligned1 2 4 816 32 64 128256 512 1024 20484096 8192 16384 32768---------------------------control the fillment of 123456Original: 123456 Filled:**123456 Your task is to write a program to print the output above. main.cpp 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; double x=123456789.9876543; cout&lt;&lt;&quot;control the format of numeric value, 123456789.9876543\\n&quot;; cout&lt;&lt;&quot;Default:&quot;&lt;&lt; scientific &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; endl; cout&lt;&lt;&quot;Using fixed:&quot; &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; x &lt;&lt; endl; cout&lt;&lt;&quot;With precision &quot;&lt;&lt;7&lt;&lt;&quot;:&quot; &lt;&lt;fixed &lt;&lt; setprecision(7) &lt;&lt; x&lt;&lt; endl; cout&lt;&lt;&quot;Scientific with precision &quot;&lt;&lt;3&lt;&lt;&quot;:&quot;&lt;&lt;scientific &lt;&lt; setprecision(3) &lt;&lt; x &lt;&lt; endl; cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;control the base of numeric value, 16&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Hex:&quot;&lt;&lt;hex&lt;&lt;16&lt;&lt;endl; cout&lt;&lt;&quot;Oct:&quot;&lt;&lt;oct&lt;&lt;16&lt;&lt;endl; cout&lt;&lt;&quot;Dec:&quot;&lt;&lt;dec&lt;&lt;16&lt;&lt;endl; cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;control the width and alignment, and the width is 6 spaces&quot;&lt;&lt;endl; cout&lt;&lt;&quot;right aligned&quot;&lt;&lt;endl; cout &lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 1&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 2&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 4&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 8&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 16&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 32&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 64&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 128&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 256&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 512&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 1024&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 2048&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 4096&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 8192&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 16384&lt;&lt; setw(6) &lt;&lt; right &lt;&lt; 32768&lt;&lt;endl; cout&lt;&lt;&quot;left aligned&quot;&lt;&lt;endl; cout &lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 1&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 2&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 4&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 8&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 16&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 32&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 64&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 128&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 256&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 512&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 1024&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 2048&lt;&lt;endl; cout&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 4096&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 8192&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 16384&lt;&lt; setw(6) &lt;&lt; left &lt;&lt; 32768&lt;&lt;endl; cout&lt;&lt;&quot;---------------------------&quot;&lt;&lt;endl; cout&lt;&lt;&quot;control the fillment of 123456&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Original: 123456&quot;&lt;&lt;endl; cout&lt;&lt;&quot; Filled:&quot;&lt;&lt;setw(8)&lt;&lt; setfill(&#x27;*&#x27;)&lt;&lt;right&lt;&lt;123456&lt;&lt;endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¬¬å…«ç« - COUNTER(è®¡æ•°å™¨)","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å…«ç« ","date":"2022-04-11T07:36:39.536Z","updated":"2022-07-21T07:27:26.818Z","comments":true,"path":"2022/04/11/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å…«ç« /","link":"","permalink":"http://example.com/2022/04/11/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%85%AB%E7%AB%A0/","excerpt":"","text":"å¼‚æ­¥è®¡æ•°å™¨è®¡ç®—(Asynchronous) 2ä½å¼‚æ­¥è®¡æ•°å™¨ 3ä½å¼‚æ­¥è®¡æ•°å™¨ ä¼ è¾“å»¶è¿Ÿ å¼‚æ­¥è®¡æ•°å™¨è¢«ç§°ä¸ºè¡Œæ³¢è®¡æ•°å™¨,å­˜åœ¨ä¼ è¾“å»¶è¿Ÿ ****å¼‚æ­¥è§¦å‘å¯èƒ½å¯¼è‡´å¤šçº§å»¶è¿Ÿï¼ˆæœ€é•¿å»¶è¿Ÿå¿…é¡»å°äº æ—¶é’Ÿå‘¨æœŸï¼‰ã€é”™è¯¯çš„æš‚æ€ å¼‚æ­¥è¯‘ç è®¡æ•°å™¨ è®¡æ•°å™¨å¯ä»¥æœ‰\\(2^{n}\\)ä¸ªçŠ¶æ€,næ˜¯è§¦å‘å™¨ä¸ªæ•° æ¨¡10æˆªæ–­ å¼‚æ­¥æ¸…0å¯¼è‡´æ¯›åˆº 74LS93 ï¼ˆCTR DIV nä»£è¡¨nä¸ªçŠ¶æ€çš„è®¡æ•°å™¨ï¼‰ 74LS93å¯ä»¥åšæ¨¡10æˆ–è€…æ¨¡16çš„è®¡æ•°å™¨ åŒæ­¥è®¡æ•°å™¨è®¡ç®—(Synchronous) 2ä½åŒæ­¥äºŒè¿›åˆ¶è®¡æ•°å™¨ ä¼ è¾“å»¶è¿Ÿ æ—¶åºå›¾ 3ä½åŒæ­¥äºŒè¿›åˆ¶è®¡æ•°å™¨ ä¿¡å·é‡ç”¨ 4ä½åŒæ­¥äºŒè¿›åˆ¶è®¡æ•°å™¨ å¦‚ä½•åšä¸€ä¸ªæ¨¡10çš„ éœ€è¦æ±‚å¾—æ¯ä¸ªJKè§¦å‘å™¨çš„é€»è¾‘è¾“å…¥å…¬å¼ 74HC163 4ä½åŒæ­¥äºŒè¿›åˆ¶è®¡æ•°å™¨ åŒæ­¥ç½®æ•°ï¼ŒåŒæ­¥æ¸…é›¶ è®¡æ•°ä½¿èƒ½æ¡ä»¶ï¼šENTå’ŒENPåŒä¸º1 æœ«ç«¯è®¡æ•°TC=15æ—¶è¿›ä½è¾“å‡ºRCO=1 åŠ å‡åŒæ­¥è®¡æ•°å™¨(åŒå‘è®¡æ•°å™¨) å¯¹äº\\(J_1\\)å’Œ\\(K_1\\) å¯¹äºåŠ ï¼ˆUPï¼‰æ—¶åºï¼Œ\\(Q_1\\)åœ¨\\(Q_0=1\\)çš„ä¸‹ä¸€ä¸ªæ—¶é’Ÿè„‰å†²åˆ°æ¥æ—¶æ”¹å˜çŠ¶æ€ã€‚å¯¹äºå‡ï¼ˆDOWNï¼‰æ—¶åºï¼Œ\\(Q_1\\)åœ¨\\(Q_0=0\\)çš„ä¸‹ä¸€ä¸ªæ—¶é’Ÿè„‰å†²åˆ°æ¥æ—¶æ”¹å˜çŠ¶æ€ã€‚ å¯¹äº\\(J_2\\)å’Œ\\(K_2\\) å¯¹äºåŠ æ—¶åºæ¥è¯´ï¼Œ\\(Q2\\)åœ¨\\(Q_0ï¼Q_1ï¼1\\)çš„ä¸‹ä¸€ä¸ªæ—¶é’Ÿè„‰å†²åˆ°æ¥æ—¶æ”¹å˜çŠ¶æ€ã€‚å¯¹äºå‡æ—¶åºæ¥è¯´ï¼Œ\\(Q_2\\)åœ¨\\(Q_0ï¼Q_1ï¼0\\)çš„ä¸‹ä¸€ä¸ªæ—¶é’Ÿè„‰å†²åˆ°æ¥æ—¶æ”¹å˜çŠ¶æ€ã€‚å› æ­¤ï¼Œåœ¨ä¸‹é¢çš„ç­‰å¼æ‰€è¡¨è¾¾çš„æ¡ä»¶ä¸‹ï¼ŒFF2çš„\\(J_2\\)å’Œ\\(K_2\\)è¾“å…¥å¿…é¡»ç­‰äº1ï¼š 74HC190 åŠ å‡åè¿›åˆ¶è®¡æ•°å™¨ \\(D/\\bar{U}\\)è¡¨ç¤ºDOWN/UP,åŠ å‡æ§åˆ¶è¾“å…¥ \\(\\overline{CTEN}\\)è¡¨ç¤ºè®¡æ•°ä½¿èƒ½ç«¯(count enable) åŒæ­¥è®¡æ•°å™¨çš„è®¾è®¡(é‡ç‚¹) æ—¶åºé€»è¾‘ç”µè·¯çš„ä¸€èˆ¬æ¨¡å‹ï¼šçŠ¶æ€æœº â€¢è¾“å…¥ï¼š\\((I_0,I_1,â€¦,I_m)ï¼›\\)è¾“å‡ºï¼š\\((O_0,O_1,â€¦,O_m)ï¼›\\) æ¿€åŠ±ï¼š\\((Y_0,Y_1,â€¦,Y_p)ï¼›\\)çŠ¶æ€ï¼š\\((Q_0,Q_1,â€¦,Q_x)\\) â€¢Mooreå‹ï¼šè¾“å‡ºä»…ä¸å½“å‰çŠ¶æ€ç›¸å…³ï¼Œ\\(O=F(Q)\\) â€¢Mealyå‹ï¼šè¾“å‡ºä¸å½“å‰çŠ¶æ€å’Œè¾“å…¥ç›¸å…³ï¼Œ\\(O=F(I,Q)\\) â€¢åŒæ­¥ï¼šæ‰€æœ‰è§¦å‘å™¨ç”¨åŒä¸€ä¸ªæ—¶é’Ÿä¿¡å·,çŠ¶æ€å˜åŒ–åŒæ—¶å‘ç”Ÿ â€¢å¼‚æ­¥ï¼šè§¦å‘å™¨æ²¡æœ‰ç»Ÿä¸€çš„æ—¶é’Ÿä¿¡å·,çŠ¶æ€å˜åŒ–æ—¶é—´æœ‰å…ˆå æ—¶åºé€»è¾‘ç”µè·¯è®¾è®¡æ­¥éª¤ å‡†å¤‡ï¼šç”»çŠ¶æ€å›¾ï¼Œä½œæ¬¡æ€è¡¨ã€è§¦å‘å™¨çš„è½¬æ¢è¡¨ã€‚ åŒ–ç®€ï¼šä½œå¡è¯ºå›¾ï¼Œæ±‚è§¦å‘å™¨çš„è¾“å…¥é€»è¾‘è¡¨è¾¾å¼ã€‚ è®¾è®¡ï¼šä½œç”µè·¯é€»è¾‘å›¾ã€‚ ä»¥è®¾è®¡æ ¼é›·ç ä¸ºä¾‹ ç”¨J-Kè§¦å‘å™¨è®¾è®¡åŒæ­¥3ä½åŒå‘æ ¼é›·ç è®¡æ•°å™¨ çº§è”è®¡æ•°å™¨Cascaded counters ç›®çš„ï¼šçº§è”å¤šä¸ªè®¡æ•°å™¨æ¥æ‰©å¤§è®¡æ•°å™¨çš„æ¨¡ å¼‚æ­¥çº§è” æ€»çš„æ¨¡ä¸º32;è¡¨ç°ä¸º32åˆ†é¢‘è®¡æ•°å™¨ åŒæ­¥çº§è” çº§è”ä¿¡å·ï¼šè®¡æ•°ä½¿èƒ½CTENï¼Œæœ«ç«¯è®¡æ•°TC ä½ä½ç‰‡çš„TCä½œä¸ºé«˜ä½ç‰‡çš„è®¡æ•°ä½¿èƒ½ä¿¡å· å¤šä¸ªçº§è”çš„åŒæ­¥è®¡æ•°å™¨æ„æˆé€’å‡è®¡æ•°é“¾ â€¢è®¡æ•°å™¨çš„æ¨¡ç­‰äºå„çº§è®¡æ•°å™¨çš„æ¨¡çš„ä¹˜ç§¯ â€¢ä»ä½ä½åˆ°é«˜ä½çš„TCä¿¡å·é¢‘ç‡ç­‰äºæ—¶é’Ÿé¢‘ç‡ä¾æ¬¡é™¤ä»¥å„çº§è®¡æ•°å™¨çš„æ¨¡ ç”¨4ç‰‡74HC161è®¾è®¡æ¨¡ä¸º40000çš„è®¡æ•°å™¨ (æˆªæ–­æ—¶åºçš„çº§è”è®¡æ•°å™¨) æ€è·¯ï¼šå…ˆæŠŠ4ç‰‡74HC161çº§è”ä¸ºä¸€ä¸ªæ¨¡65536çš„è®¡æ•°å™¨ï¼Œå†æ”¹é€ ä¸ºæ¨¡40000çš„è®¡æ•°å™¨ 65536-40000=25536ï¼ˆåå…­è¿›åˆ¶ä¸º\\(63C0_{16}\\)ï¼‰ï¼Œè®¡æ•°åºåˆ—ï¼š25536~65535 è®¡æ•°åˆ°è¾¾65535ï¼Œæœ€é«˜ä½ç‰‡RCO=1ï¼Œè®¡æ•°å™¨çŠ¶æ€è®¾ä¸º25536 è®¡æ•°å™¨çŠ¶æ€è¯‘ç  ç›®çš„ï¼šæ£€æµ‹è®¡æ•°å™¨çš„ç‰¹å®šçŠ¶æ€æ¥è¾“å‡ºæœ‰æ•ˆä¿¡å·ï¼Œä¾‹å­ï¼šTC è®¡æ•°å™¨åº”ç”¨ æ˜¾ç¤ºâ€œæ—¶ï¼šåˆ†ï¼šç§’â€çš„æ•°å­—é’Ÿç³»ç»Ÿ åœè½¦åœºå‡ºå…¥æ§åˆ¶ç³»ç»Ÿ å¹¶è¡Œâ€”ä¸²è¡Œæ•°æ®è½¬æ¢ç³»ç»Ÿ äº¤é€šä¿¡å·ç¯æ§åˆ¶ç³»ç»Ÿ å°ç»“ å¼‚æ­¥è®¡æ•°å™¨ä¸­çš„å¼‚æ­¥æŒ‡çš„æ˜¯ä»€ä¹ˆ? ä¸€ä¸ªæ¨¡14è®¡æ•°å™¨æœ‰å¤šå°‘çŠ¶æ€ï¼Ÿéœ€è¦è‡³å°‘å¤šå°‘ä¸ªè§¦å‘å™¨æ¥å®ç°å®ƒï¼Ÿ ä¸€ä¸ªåŒæ­¥è®¡æ•°å™¨å’Œä¸€ä¸ªå¼‚æ­¥è®¡æ—¶å™¨çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ è§£é‡Šè®¡æ•°å™¨çš„é¢„ç½®ä½åŠŸèƒ½ï¼Œä¾‹å¦‚74HC163ã€‚ 74HC163 è§£é‡Š74HC163è®¡æ•°å™¨çš„è¾“å…¥ENPã€ENTå’Œè¾“å‡ºRCOçš„ç”¨é€”ã€‚ ä¸€ä¸ª4ä½åŠ ï¼å‡è®¡æ•°å™¨å¤„äºå‡æ¨¡å¼ï¼Œå¹¶ä¸”ä¸º1010çŠ¶æ€ã€‚ä¸‹ä¸€ä¸ªæ—¶é’Ÿè„‰å†²åˆ°æ¥æ—¶ï¼Œè®¡æ•°å™¨çš„çŠ¶æ€æ˜¯ä»€ä¹ˆï¼Ÿ å¤„åœ¨åŠ æ¨¡å¼çš„4ä½åŠ ï¼å‡è®¡æ—¶å™¨çš„æœ€åä¸€ä¸ªçŠ¶æ€æ˜¯ä»€ä¹ˆï¼Ÿå½“å¤„äºå‡æ¨¡å¼æ—¶ï¼Œä¸‹ä¸€ä¸ªçŠ¶æ€æ˜¯ä»€ä¹ˆï¼Ÿ å®Œæˆä¸€ä¸ª1000åˆ†é¢‘çš„è®¡æ•°å™¨éœ€è¦å¤šå°‘ä¸ªåè¿›åˆ¶è®¡æ•°å™¨?10000åˆ†é¢‘çš„å‘¢? ç»™å‡ºå¦‚ä½•è·å–å¦‚ä¸‹åˆ†é¢‘çš„ä¸€èˆ¬æ¡†å›¾.ä½¿ç”¨è§¦å‘å™¨ã€åè¿›åˆ¶è®¡æ•°å™¨ã€4ä½äºŒè¿›åˆ¶è®¡æ•°å™¨æˆ–ä»–ä»¬çš„ç»„åˆï¼š ï¼ˆaï¼‰ 20åˆ†é¢‘ï¼ˆbï¼‰ 32åˆ†é¢‘ï¼ˆcï¼‰ 160åˆ†é¢‘ï¼ˆdï¼‰ 320åˆ†é¢‘ 4ä½äºŒè¿›åˆ¶å¼‚æ­¥è®¡æ•°å™¨çŠ¶æ€å˜åŒ–å¦‚ä¸‹,å¯èƒ½å‘ç”Ÿçš„ç¬é—´çŠ¶æ€æ˜¯ä»€ä¹ˆ? (a)2-3 (b)3-4 (c)10-11 (d)15-0 å…³è”æ ‡è®°,å­—æ¯Cã€Mã€Gè¡¨ç¤ºä»€ä¹ˆ å“ªä¸ªå­—æ¯è¡¨ç¤ºæ•°æ®å­˜å‚¨?","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"ç¨‹è®¾è®°å½•--å¤šæ€(è™šå‡½æ•°)","slug":"ç¨‹è®¾/figure(è™šå‡½æ•°)","date":"2022-04-06T12:24:16.277Z","updated":"2022-04-07T05:27:02.935Z","comments":true,"path":"2022/04/06/ç¨‹è®¾/figure(è™šå‡½æ•°)/","link":"","permalink":"http://example.com/2022/04/06/%E7%A8%8B%E8%AE%BE/figure(%E8%99%9A%E5%87%BD%E6%95%B0)/","excerpt":"","text":"There are 4 classes, Figure is the base class, both Triangle, Rectangle and Circle are all inherited from it. Figure class is like following: 1234567class FIGURE &#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()è¢«å£°æ˜ä¸ºçº¯è™šå‡½æ•°protected: double x_size, y_size;&#125;; You should implement Figure, Triangle, Rectange, Circle class. Sample Output 123Area of triangle is 60Area of rectangle is 120Area of circle is 706.858 figure.h 12345678class FIGURE&#123;public: void set_size(double x, double y = 0); virtual double get_area() = 0; // get_area()è¢«å£°æ˜ä¸ºçº¯è™šå‡½æ•°protected: double x_size, y_size;&#125;; main.cpp 123456789101112131415161718192021222324252627#include &quot;Figure.h&quot;#include &quot;Triangle.h&quot;#include &quot;Rectangel.h&quot;#include &quot;Circle.h&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; TRIANGLE triangle; RECTANGLE rectangle; CIRCLE circle; // å¤„ç†ä¸‰è§’å½¢ triangle.set_size(15, 8); // è®¾ç½®ä¸‰è§’å½¢çš„åº•å’Œé«˜ cout &lt;&lt; &quot;Area of triangle is &quot; &lt;&lt; triangle.get_area() &lt;&lt; &quot;\\n&quot;; // å¤„ç†çŸ©å½¢ rectangle.set_size(15, 8); // è®¾ç½®çŸ©å½¢çš„é•¿å’Œå®½ cout &lt;&lt; &quot;Area of rectangle is &quot; &lt;&lt; rectangle.get_area() &lt;&lt; &quot;\\n&quot;; // å¤„ç†åœ† circle.set_size(15); // è®¾ç½®åœ†çš„åŠå¾„ cout &lt;&lt; &quot;Area of circle is &quot; &lt;&lt; circle.get_area() &lt;&lt; &quot;\\n&quot;; return 0;&#125; åé¢æ˜¯éœ€è¦å®Œæˆçš„å†…å®¹ figure.cpp 12345678910111213#include&quot;Figure.h&quot;using namespace std; double FIGURE::get_area()&#123;&#125;void FIGURE::set_size(double x, double y)&#123; x_size = x; y_size = y;&#125; triangle.h 123456789101112#include&quot;Figure.h&quot;class TRIANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size / 2; &#125;&#125;; rectangle.h 123456789101112#include&quot;Figure.h&quot;class RECTANGLE:public FIGURE&#123;public: void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * y_size ; &#125;&#125;; circle.h 123456789101112#include&quot;Figure.h&quot;class CIRCLE:public FIGURE&#123;public:void set_size(double x, double y = 0)&#123; x_size = x; y_size = y; &#125; double get_area()&#123; return x_size * x_size * PI; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•--å®ç°æ ˆç±»","slug":"ç¨‹è®¾/ç”¨é“¾è¡¨å®ç°æ ˆç±»","date":"2022-04-06T08:59:06.541Z","updated":"2022-04-06T09:22:43.963Z","comments":true,"path":"2022/04/06/ç¨‹è®¾/ç”¨é“¾è¡¨å®ç°æ ˆç±»/","link":"","permalink":"http://example.com/2022/04/06/%E7%A8%8B%E8%AE%BE/%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%B1%BB/","excerpt":"","text":"æ ˆç±» 12345678910111213141516171819202122232425262728#ifndef STACK_HPP#define STACK_HPP#include &lt;stddef.h&gt;class Stack &#123; struct node &#123; int num; node* next; node() &#123; num = 0; next = NULL; &#125; node(int n, node* p = NULL) &#123; num = n; next = p; &#125; &#125;; node* data;public: Stack(); // æ„é€ ä¸€ä¸ªç©ºæ ˆ Stack(const Stack&amp;); // æ‹·è´æ„é€ å‡½æ•° ~Stack(); // æ³¨æ„å†…å­˜å›æ”¶ void push(int); // å…¥æ ˆ void pop(); // å‡ºæ ˆ int top() const; // æŸ¥çœ‹æ ˆé¡¶å…ƒç´ ï¼Œè‹¥æ ˆä¸ºç©ºï¼Œè¿”å›0 bool empty() const; // åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º void clear(); // æ¸…ç©ºæ ˆ&#125;;#endif è¡¥å…… 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;Stack.hpp&gt;#include&lt;iostream&gt;using namespace std;Stack::Stack()&#123; data=new node;&#125;Stack::Stack(const Stack&amp; a) &#123; Stack b; for(node *i=a.data;i-&gt;next!=NULL;i=i-&gt;next) b.push(i-&gt;num); data=new node; for(;!b.empty();b.pop()) push(b.top());&#125;Stack::~Stack()&#123; clear(); delete data;&#125;void Stack:: push(int n)&#123; data=new node(n,data);&#125;// å…¥æ ˆvoid Stack:: pop()&#123; if(empty()) return; node* temp=data; data=data-&gt;next; delete temp; &#125;// å‡ºæ ˆint Stack:: top() const&#123; return data-&gt;num;&#125;// æŸ¥çœ‹æ ˆé¡¶å…ƒç´ ï¼Œè‹¥æ ˆä¸ºç©ºï¼Œè¿”å›0bool Stack:: empty() const&#123; return data-&gt;next==NULL;&#125;// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºvoid Stack:: clear()&#123; while(!empty())&#123; pop(); &#125;&#125; æ‹·è´æ„é€ å‡½æ•°ä¹Ÿå¯ä»¥è¿™æ ·å­å†™ 123456789101112131415161718stack:: stack(const stack &amp; a)&#123; node* p=a.data; data=new node; data-&gt;num=p-&gt;num; data-&gt;next=NULL; p=p-&gt;next; while(p!=NULL) &#123; node *s=data; while(s-&gt;next!=NULL) s=s-&gt;next; node *k=new node; s-&gt;next=k; k-&gt;num=p-&gt;num; k-&gt;next=NULL; p=p-&gt;next; &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¬¬ä¸ƒç« - LATCHES,FLIP-FLOPS,TIMERS(é”å­˜å™¨\\è§¦å‘å™¨\\å®šæ—¶å™¨)","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸ƒç« (äºŒ)","date":"2022-04-06T07:46:41.576Z","updated":"2022-04-16T13:47:13.390Z","comments":true,"path":"2022/04/06/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸ƒç« (äºŒ)/","link":"","permalink":"http://example.com/2022/04/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0(%E4%BA%8C)/","excerpt":"","text":"Flip-Flop Operating Character(è¾¹æ²¿è§¦å‘å™¨çš„è¿ç®—ç‰¹æ€§) propagation delay timeä¼ è¾“å»¶è¿Ÿæ—¶é—´ set-up time and hold time å‰©ä½™æ¦‚å¿µ æœ€å¤§æ—¶é’Ÿé¢‘ç‡ï¼šè§¦å‘å™¨å¯é å·¥ä½œçš„æœ€é«˜æ—¶é’Ÿé¢‘ç‡ ï¼ˆæœ€å°ï¼‰è„‰å†²å®½åº¦ï¼šæ—¶é’Ÿï¼ˆé«˜ã€ä½æ—¶é•¿ï¼‰ï¼Œç½®ä¸€ï¼Œæ¸…é›¶ Flip-Flop applicationè§¦å‘å™¨åº”ç”¨ å¹¶è¡Œæ•°æ®å‚¨å­˜:å¯„å­˜å™¨(åŒæ­¥æ—¶åº) åˆ†é¢‘å™¨(å¼‚æ­¥æ—¶åº) å¯ä»¥å®ç°ä¸æ–­äºŒåˆ†é¢‘ è®¡æ•°å™¨ One-shot å•ç¨³æ€è§¦å‘å™¨ å¯é‡å¤è§¦å‘å’Œä¸å¯é‡å¤è§¦å‘æ³¢å½¢ 74121:ä¸å¯é‡å¤è§¦å‘å•ç¨³æ€è§¦å‘å™¨ \\(R_{INT}\\)è¿æ¥åœ¨ä¸€ä¸ª2KÎ©çš„ç”µé˜»ä¸Š è¾“å‡ºè„‰å†²å®½åº¦ç”±ç”µé˜»å€¼(\\(R_{INT}=2kÎ©å’ŒR_{EXT}\\)) \\[ t_{w}=0.7RC_{EXT} \\] æ³¨æ„å•ä½:\\(R(kÎ©)\\) \\(C_{EXT}(pF)\\) \\(t_{w}(ns)\\) 74LS122å¯é‡å¤è§¦å‘å•ç¨³æ€è§¦å‘å™¨ \\[ t_{w}=0.32RC_{EXT}(1+\\frac{0.7}{R}) \\] å•ç¨³æ€è§¦å‘å™¨èƒ½ä½œä¸ºå®šæ—¶å™¨ä½¿ç”¨ 555å®šæ—¶å™¨ \\[ è„‰å†²å®½åº¦t_{w}=1.1R_1C_1 \\] éç¨³æ€å¤šè°æŒ¯è¡å™¨ UTPå’ŒLTPä¸ç›¸åŒ 555å®šæ—¶å™¨æ„æˆå¤šè°æŒ¯è¡å™¨ \\[ æŒ¯è¡é¢‘ç‡f=\\frac{1.44}{(R_1+2R_2)C_1} \\] è¾“å‡ºä¸ºé«˜ç”µå¹³çš„æ—¶é—´\\(t_H\\)æ˜¯C1ä»ä¸‰åˆ†ä¹‹ä¸€å……ç”µåˆ°ä¸‰åˆ†ä¹‹äºŒæ‰€èŠ±çš„æ—¶é—´ è¾“å‡ºä¸ºä½ç”µå¹³çš„æ—¶é—´\\(t_L\\)æ˜¯C1ä»ä¸‰åˆ†ä¹‹äºŒæ”¾ç”µåˆ°ä¸‰åˆ†ä¹‹ä¸€æ‰€èŠ±çš„æ—¶é—´ \\[ t_{H}=0.7(R_1+R_2)C_1 \\] \\[ t_L=0.7R_2C_1 \\] å ç©ºæ¯” \\[ å ç©ºæ¯”=(\\frac{R_1+R_2}{R_1+2R_2}) \\] ä¸ºäº†è®©å ç©ºæ¯”å°äº50%,å¢åŠ ä¸€ä¸ªäºŒæç®¡å \\[ å ç©ºæ¯”=(\\frac{R_1}{R_1+R_2}) \\]","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"ç¬¬ä¸ƒç« - LATCHES,FLIP-FLOPS,TIMERS(é”å­˜å™¨\\è§¦å‘å™¨\\å®šæ—¶å™¨)","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸ƒç« ","date":"2022-03-28T12:47:15.450Z","updated":"2022-04-15T13:21:31.212Z","comments":true,"path":"2022/03/28/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸ƒç« /","link":"","permalink":"http://example.com/2022/03/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%83%E7%AB%A0/","excerpt":"","text":"Latches æŒæ¡çŸ¥è¯†ç‚¹ S-Ré”å­˜å™¨çš„æ“ä½œ é—¨æ§S-Ré”å­˜å™¨ Dé”å­˜å™¨çš„æ“ä½œ ç”¨é€»è¾‘é—¨è¡¥å……S-Rå’ŒRé”å­˜å™¨ 74LS297Aå’Œ74LS75 S-Ré”å­˜å™¨(S-R Latches) S--set R-reset é”å­˜å™¨çš„è¾“å‡ºæ€»æ˜¯åç›¸çš„ åŸºæœ¬ç»“æ„ çœŸå€¼è¡¨ æ³¢å½¢å›¾ application(è§¦ç‚¹æŠ–åŠ¨æ¶ˆé™¤å™¨) 74LS279 A The Gated S-R Latch æ³¢å½¢å›¾ The Gated D(Data) Latches 74LS75 D LATCH Edge-Triggered Flio-Flops æŒæ¡çŸ¥è¯†ç‚¹ è§£é‡Šæ—¶é’ˆ,è¾¹æ²¿è§¦å‘å™¨; é”å­˜å™¨å’Œè§¦å‘å™¨çš„åŒºåˆ« é€šè¿‡é€»è¾‘ç¬¦å·å®šä¹‰è¾¹æ²¿è§¦å‘çš„è§¦å‘å™¨ æ­£è¾¹æ²¿è§¦å‘å’Œè´Ÿè¾¹æ²¿è§¦å‘çš„è§¦å‘å™¨çš„åŒºåˆ« æ¯”è¾ƒS-R,D,J-Kè¾¹æ²¿è§¦å‘å™¨æ“ä½œä»¥åŠçœŸå€¼è¡¨çš„åŒºåˆ« 74AHC74å’Œ74HC112 S-R ä¸‰ç§æƒ…å†µ çœŸå€¼è¡¨ æ˜¯å¦‚ä½•äº§ç”Ÿè„‰å†²çš„ åˆ©ç”¨é—¨ç”µè·¯çš„å»¶è¿Ÿç‰¹æ€§ D J-K æ³¢å½¢å›¾ å¼‚æ­¥é¢„ç½®ä½è¾“å…¥å’Œæ¸…é›¶è¾“å…¥ S-R,D,K-Kéƒ½æ˜¯åŒæ­¥è¾“å…¥ PREå’ŒCLRçš„è¾“å…¥ä¼šç›´æ¥æ”¹å˜è¾“å‡º,è€Œä¸å—å‰é¢ç”µè·¯å½±å“ 74AHC74 åŒDè§¦å‘å™¨ 74HC112 åŒJ-Kè§¦å‘å™¨ å·©å›º","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"ç¨‹è®¾è®°å½•(åå››)--Overload simple clock","slug":"ç¨‹è®¾/Overload simple clock","date":"2022-03-23T12:40:55.114Z","updated":"2022-03-23T14:05:36.719Z","comments":true,"path":"2022/03/23/ç¨‹è®¾/Overload simple clock/","link":"","permalink":"http://example.com/2022/03/23/%E7%A8%8B%E8%AE%BE/Overload%20simple%20clock/","excerpt":"","text":"é¢˜ç›®æ‰€ç»™ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;SimpleClock.h&quot;int main() &#123; Clock clock1; cin &gt;&gt; clock1; cout &lt;&lt; &quot;cin &gt;&gt; clock1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl &lt;&lt; endl; Clock clock2(clock1); cout &lt;&lt; &quot;clock2(clock1)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock2 ---- &quot; &lt;&lt; clock2 &lt;&lt; endl &lt;&lt; endl; Clock clock3 = clock1 ++; Clock clock4 = ++ clock2; cout &lt;&lt; &quot;clock3 = clock1 ++&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock4 = ++ clock2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock2 ---- &quot; &lt;&lt; clock2 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock3 ---- &quot; &lt;&lt; clock3 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock4 ---- &quot; &lt;&lt; clock4 &lt;&lt; endl &lt;&lt; endl; Clock clock5(11, 45, 14); Clock clock6 = clock1 + clock5; cout &lt;&lt; &quot;clock5(11, 45, 14)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock6 = clock1 + clock5&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock1 ---- &quot; &lt;&lt; clock1 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock5 ---- &quot; &lt;&lt; clock5 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock6 ---- &quot; &lt;&lt; clock6 &lt;&lt; endl &lt;&lt; endl; Clock clock7; clock7 += clock5; clock7 += clock6; cout &lt;&lt; &quot;clock7()&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock7 += clock5&quot; &lt;&lt; endl; cout &lt;&lt; &quot;clock7 += clock6&quot; &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock5 ---- &quot; &lt;&lt; clock5 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock6 ---- &quot; &lt;&lt; clock6 &lt;&lt; endl; cout &lt;&lt; &quot;&gt;&gt; clock7 ---- &quot; &lt;&lt; clock7 &lt;&lt; endl; return 0;&#125; simpleclock.h 123456789101112131415161718192021222324252627282930313233#ifndef SIMPLECLOCK_H#define SIMPLECLOCK_H#include &lt;iostream&gt;using namespace std;class Clock &#123;private: int hour; int minute; int second; public: // Implemented. Clock(): hour(0), minute(0), second(0) &#123;&#125; Clock( int hour_, int minute_, int second_): hour(hour_), minute(minute_), second(second_) &#123;&#125; // Not implemented. Clock&amp; operator += (const Clock &amp;right); Clock operator + (const Clock &amp;right) const; Clock&amp; operator ++ (); Clock operator ++ (int) ; friend istream &amp; operator &gt;&gt; (istream &amp;is, Clock &amp;object); friend ostream &amp; operator &lt;&lt; (ostream &amp;os, const Clock &amp;object);&#125;;#endif æ‰€å†™ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Clock Clock::operator + (const Clock &amp;right) const &#123; Clock c; // Deal with hour. c.hour = (this-&gt;hour + right.hour) % 24; // Deal with minute. c.hour = (c.hour + (this-&gt;minute + right.minute) / 60) % 24; c.minute = (this-&gt;minute + right.minute) % 60; // Deal with second. c.hour = (c.hour + (c.minute + (this-&gt;second + right.second) / 60) / 60) % 24; c.minute = (c.minute + (this-&gt;second + right.second) / 60) % 60; c.second = (this-&gt;second + right.second) % 60; return c;&#125;Clock&amp; Clock::operator += (const Clock &amp;right) &#123; // Deal with hour. this-&gt;hour = (this-&gt;hour + right.hour) % 24; // Deal with minute. this-&gt;hour = (this-&gt;hour + (this-&gt;minute + right.minute) / 60) % 24; this-&gt;minute = (this-&gt;minute + right.minute) % 60; // Deal with second. this-&gt;hour = (this-&gt;hour + (this-&gt;minute + (this-&gt;second + right.second) / 60) / 60) % 24; this-&gt;minute = (this-&gt;minute + (this-&gt;second + right.second) / 60) % 60; this-&gt;second = (this-&gt;second + right.second) % 60; return *this;&#125;Clock &amp; Clock::operator ++ () &#123; Clock adder(0, 0, 1); *this += adder; return *this;&#125;Clock Clock::operator ++ (int) &#123; Clock c(*this); ++ *this; return c;&#125;istream &amp; operator &gt;&gt; (istream &amp;is, Clock &amp;object) &#123; int hour, minute, second; is &gt;&gt; hour &gt;&gt; minute &gt;&gt; second; hour %= 24; hour = (hour + minute / 60) % 24; minute %= 60; hour = (hour + (minute + second / 60) / 60) % 24; minute = (minute + second / 60) % 60; second %= 60; object.hour = hour; object.minute = minute; object.second = second; return is;&#125;ostream &amp; operator &lt;&lt; (ostream &amp;os, const Clock &amp;object) &#123; os &lt;&lt; object.hour &lt;&lt; &quot;:&quot; &lt;&lt; object.minute &lt;&lt; &quot;:&quot; &lt;&lt; object.second; return os;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(åä¸‰)--virtual class","slug":"ç¨‹è®¾/virtual class","date":"2022-03-23T12:18:35.991Z","updated":"2022-03-23T12:40:54.109Z","comments":true,"path":"2022/03/23/ç¨‹è®¾/virtual class/","link":"","permalink":"http://example.com/2022/03/23/%E7%A8%8B%E8%AE%BE/virtual%20class/","excerpt":"","text":"æœ€åè¿™äº›ç±»çš„å…³ç³»å˜æˆäº†ä¸€ä¸ªåœˆ vituralçš„åº”ç”¨ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;cstring&gt;#include &lt;fstream&gt;using namespace std;#include &quot;source.h&quot;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); int n; cin&gt;&gt;n; for (int i=0;i&lt;n;i++) &#123; char name[20],job[20],dep[20],major[20],prof[20]; int age; cin&gt;&gt;name&gt;&gt;age&gt;&gt;job&gt;&gt;dep&gt;&gt;major&gt;&gt;prof; chairman man; man.setname(name); man.setage(age); man.setjob(job); man.setdep(dep); man.setmajor(major); man.setprof(prof); cout&lt;&lt;&quot;name: &quot;&lt;&lt;man.getname()&lt;&lt;&quot; age: &quot;&lt;&lt;man.getage()&lt;&lt;&quot; dep: &quot;&lt;&lt;man.getdep() &lt;&lt;&quot; job: &quot;&lt;&lt;man.getjob()&lt;&lt;endl; cout&lt;&lt;&quot;prof: &quot;&lt;&lt;man.getprof()&lt;&lt;&quot; major: &quot;&lt;&lt;man.getmajor()&lt;&lt;endl; &#125; return 0;&#125;//æ‰€éœ€å®Œæˆçš„ä»£ç #include &lt;iostream&gt;#include &lt;cstring&gt;class base &#123; char name[20]; int age; public: base() &#123;&#125; void setname(char arr[]) &#123; strcpy(name, arr); &#125;; void setage(int age) &#123; this-&gt;age = age; &#125;; char* getname() &#123; return name; &#125;; int getage() &#123; return age; &#125;;&#125;;class leader: virtual public base &#123; private: char job[20]; char department[20]; public: void setjob(char arr[]) &#123; strcpy(job, arr); &#125;; void setdep(char arr[]) &#123; strcpy(department, arr); &#125;; char * getjob() &#123; return job; &#125; char * getdep() &#123; return department; &#125;&#125;;class engineer: virtual public base &#123; private: char major[20]; char profession[20]; public: void setmajor(char arr[]) &#123; strcpy(major, arr); &#125;; void setprof(char arr[]) &#123; strcpy(profession, arr); &#125;; char * getmajor() &#123; return major; &#125; char * getprof() &#123; return profession; &#125;&#125;;class chairman: public leader, public engineer &#123;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(åäºŒ)--å¤šç»§æ‰¿","slug":"ç¨‹è®¾/å¤šç»§æ‰¿","date":"2022-03-23T11:38:26.105Z","updated":"2022-05-08T08:31:55.408Z","comments":true,"path":"2022/03/23/ç¨‹è®¾/å¤šç»§æ‰¿/","link":"","permalink":"http://example.com/2022/03/23/%E7%A8%8B%E8%AE%BE/%E5%A4%9A%E7%BB%A7%E6%89%BF/","excerpt":"","text":"Description å†™ä½œå’Œèµ›è½¦æ˜¯éŸ©å°‘çš„ä¸¤å¤§æœ€çˆ±ï¼Œä½†åœ¨ç”Ÿæ´»çš„ä¸åŒæ—¶æœŸè¿˜æ˜¯è¦æœ‰æ‰€å–èˆã€‚ éŸ©å°‘çš„åŸåˆ™æ˜¯ï¼š å‘¨æœ«ï¼šå†™ä½œä¼˜å…ˆï¼› å‘¨å†…ï¼šèµ›è½¦ä¼˜å…ˆï¼› è¿™äº›å¯ä»¥æç°åœ¨Weekendå’ŒWorkdayçš„å¯¹è±¡æ„é€ ä¸­ï¼Œç±»ç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š 123Racing Writing \\ / Weekend/Workday å…¶ä¸­Racingå’ŒWritingå¦‚ä¸‹ï¼š 12345678910111213141516171819class Writing &#123;public: Writing() &#123; cout&lt;&lt;&quot;Writing constructor&quot;&lt;&lt;endl; &#125; ~Writing()&#123; cout&lt;&lt;&quot;~Writing&quot;&lt;&lt;endl; &#125;&#125;;class Racing &#123;public: Racing()&#123; cout&lt;&lt;&quot;Racing constructor&quot;&lt;&lt;endl; &#125; ~Racing()&#123; cout&lt;&lt;&quot;~Racing&quot;&lt;&lt;endl; &#125;&#125;; ä¸»å‡½æ•°å¦‚ä¸‹ï¼š 1234int main() &#123; Weekend end; Workday day;&#125; Sample Output 123456789101112Writing constructorRacing constructorWeekend constructorRacing constructorWriting constructorWorkday constructor~Workday~Writing~Racing~Weekend~Racing~Writing Hint æäº¤mainå‡½æ•°ä¹‹å¤–çš„æ‰€æœ‰ç±»ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;class Writing &#123;public: Writing() &#123; cout&lt;&lt;&quot;Writing constructor&quot;&lt;&lt;endl; &#125; ~Writing()&#123; cout&lt;&lt;&quot;~Writing&quot;&lt;&lt;endl; &#125;&#125;;class Racing &#123;public: Racing()&#123; cout&lt;&lt;&quot;Racing constructor&quot;&lt;&lt;endl; &#125; ~Racing()&#123; cout&lt;&lt;&quot;~Racing&quot;&lt;&lt;endl; &#125;&#125;;class Weekend:public Writing,public Racing&#123;public: Weekend()&#123; cout&lt;&lt;&quot;Weekend constructor&quot;&lt;&lt;endl; &#125; ~Weekend()&#123; cout&lt;&lt;&quot;~Weekend&quot;&lt;&lt;endl; &#125;&#125;; class Workday: public Racing,public Writing&#123; public: Workday()&#123; cout&lt;&lt;&quot;Workday constructor&quot; &lt;&lt; endl; &#125; ~Workday()&#123; cout&lt;&lt;&quot;~Workday&quot; &lt;&lt; endl; &#125;&#125;; main.cpp 123456int main() &#123; Weekend end; Workday day;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¬¬å…­ç« -Functions of Combinational Logic","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å…­ç« ","date":"2022-03-21T06:11:36.947Z","updated":"2022-04-14T12:53:42.440Z","comments":true,"path":"2022/03/21/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å…­ç« /","link":"","permalink":"http://example.com/2022/03/21/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"Basic Adders The Half-Adder (åŠåŠ å™¨) \\[ 0+0=0 \\] \\[ 0+1=1 \\] \\[ 1+0=1\\\\ \\] \\[ 1+1+0\\\\ \\] \\(C_{out}\\)æ˜¯è¾“å‡ºè¿›ä½,Sumæ˜¯å½“å‰ä½ Full-adder (å…¨åŠ å™¨) ä¸¤ä¸ªåŠåŠ å™¨ç»„æˆä¸€ä¸ªå…¨åŠ å™¨ å…¨åŠ å™¨å†…éƒ¨ç»“æ„ Parallel Binary Adders å®Œæˆå¤šä½ç›¸åŠ çš„æ“ä½œ ä¸¤ä½ç›¸åŠ  ä¸‰ä½æ•°å­—ç›¸åŠ (101å’Œ011) å…¨åŠ å™¨ç»„åˆ æŠ•ç¥¨ç³»ç»Ÿ Ripple Carry versus Look-Ahead Carry Adders(å¼‚æ­¥è¿›ä½å’Œè¶…å‰è¿›ä½) Ripple carry adder: the carry output of each fulladder is connected to the carry input of the next higher-order stage. â€“ Time delay The look-ahead carry adder: anticipates the output carry of each stage, and based on the inputs, produces the output carry by either carry generation or carry propagation (è¿›ä½ç”Ÿæˆæˆ–è¿›ä½ä¼ è¾“) The output carry for each full-adder stage is dependent only on the initial input carry (\\(C_{in1}\\)), the \\(C_g\\) and \\(C_p\\) functions of that stage, and the \\(C_g\\) and \\(C_p\\) functions of the preceding stages. ä¸‰çº§å»¶è¿Ÿ Comparators åŒæˆ–é—¨æˆ–è€…å¼‚æˆ–é—¨å®ç° ä¸¤ä½æ•°æ¯”è¾ƒ ä¸ç›¸ç­‰çš„æƒ…å†µ åˆ¤æ–­å¤§äºå°äº 74HC85 å››ä¸ªæ¯”ç‰¹çš„æ¯”è¾ƒå™¨ 74HC85 ä¹Ÿå¯ä»¥çº§è”æˆè¿›è¡Œå…«ä¸ªæ¯”ç‰¹ä½æ¯”è¾ƒ æœ€ä½ä½çš„è¾“å…¥ç­‰å·ä¸€å®šè¦ä¸ºé«˜ç”µå¹³,å¤§äºå’Œå°äºè¾“å…¥ä¸€å®šè¦ä¸ºä½ç”µå¹³ Decoders è¯‘ç å™¨å°±ç›¸å½“äºå°†è¾“å…¥å’Œè¾“å‡ºå»ºç«‹æ˜ å°„å…³ç³»,ä¸€ä¸€å¯¹åº” äºŒè¿›åˆ¶è¯‘ç é—¨ å¦‚æœè¦è¯‘å››ä½,é‚£ä¹ˆéœ€è¦16ä¸ªè¯‘ç é—¨ åå…­é€‰ä¸€ å››ä½è¯‘ç å™¨ 74HC154(åå…­é€‰ä¸€è¯‘ç å™¨) ä½¿ç”¨74HC154è¿›è¡Œ5ä½æ•°çš„è¯‘ç  BCDè¯‘ç é—¨ ä½ç”µå¹³ä¸ºæœ‰æ•ˆè¾“å‡º 74HC42(bcdè½¬æ¢ä½åè¿›åˆ¶) 74LS47(BCDåˆ°7æ®µ) Encoders åè¿›åˆ¶åˆ°BCD Logic symbol for a decimal-to-BCD encoder é€»è¾‘ç”µè·¯ 74HC147 decimal-to-BCD priority encoder 74LS148 8-line-to-3-line encoder EI Enable input (active LOW) EO Enable output (LOW when EI is LOW and none active inputs) GS Output for expansion (LOW when EI is LOW and any of the inputs is active) Multiplexers(Data Selectors) ä¸¾ä¾‹ 74LS151 8-input data selector/multiplexer Use 74LS151s and any other logic necessary to multiplex 16 data lines onto a single data-output line é‡è¦ä¾‹å­(è€ƒè¯•è­¦å‘Š) Demultiplexers(å¤šè·¯åˆ†é…å™¨) 74HC154å¤šè·¯åˆ†é…å™¨ Parity Generators/Checkers 74LS280(9ä½å¥‡å¶æ ¡éªŒå™¨/å‘ç”Ÿå™¨)","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"ç¬¬äº”ç« -combination logic analysis","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬äº”ç« ","date":"2022-03-21T06:11:22.472Z","updated":"2022-03-21T06:57:30.751Z","comments":true,"path":"2022/03/21/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬äº”ç« /","link":"","permalink":"http://example.com/2022/03/21/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"","text":"Basic combinational logic circuits ä¸æˆ–é€»è¾‘(AND-OR Logic) SOP expressions can be implemented with An AND gate for each product term One OR gate for summing all of the product terms X= AB+ BC +AC ä¸æˆ–éé€»è¾‘(AND-OR-Invert Logic ) SOP can be implemented with AND-OR logic directly POS expressions can be implemented with AND-OR-Invert logic å¼‚æˆ–é€»è¾‘(Exclusive -OR Logic) åŒæˆ–é€»è¾‘(Exclusive -NOR Logic) Implementing Combinational Logic å¸ƒå°”è¡¨è¾¾å¼è½¬æ¢ä¸ºé€»è¾‘ç”µè·¯ çœŸå€¼è¡¨è½¬æ¢ä¸ºé€»è¾‘ç”µè·¯ The Universal Property of NAND and NOR Gates The NAND Gate as a Universal Logic Element Be used to produce the NOT, the AND, the OR, and the NOR functions. The NOR gate as a universal logic element Be used to produce the NOT, the AND, the OR, and the NAND functions. Combinational Logic Using NAND and NOR Gates Logic Circuit Operation with Pulse Waveform å…ˆå†™å‡ºå¸ƒå°”é€»è¾‘è¡¨è¾¾å¼,ç„¶ååŒ–ç®€,æœ€åç”»æ³¢å½¢å›¾ æ€»ç»“ Basic Combinational Logic Circuits Implementing Combinational Logic From a Boolean expression to a Logic Circuit From a Truth Table to a Logic Circuit The Universal Property of NAND and NOR Gates Logic Circuit Operation with Pulse Waveform Inputs How to design a combinational Logic?","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"ç¦»æ•£æ•°å­¦--ä¸€é˜¶é€»è¾‘å…¬å¼çš„è¯­æ³•å’Œè¯­ä¹‰","slug":"ç¦»æ•£æ•°å­¦/ä¸€é˜¶é€»è¾‘å…¬å¼çš„è¯­æ³•å’Œè¯­ä¹‰","date":"2022-03-19T14:48:54.492Z","updated":"2022-03-20T03:23:23.383Z","comments":true,"path":"2022/03/19/ç¦»æ•£æ•°å­¦/ä¸€é˜¶é€»è¾‘å…¬å¼çš„è¯­æ³•å’Œè¯­ä¹‰/","link":"","permalink":"http://example.com/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E5%85%AC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89/","excerpt":"","text":"â€¢èƒ½è‡ªå·±ç»™å‡ºä¸€ç»„ä¸€é˜¶é€»è¾‘å…¬å¼çš„è§£é‡Šå’Œä¸ªä½“å˜é‡æŒ‡æ´¾å‡½æ•° â€¢èƒ½åœ¨ç»™å®šçš„è§£é‡Šå’Œä¸ªä½“å˜é‡æŒ‡æ´¾å‡½æ•°æ—¶ç¡®å®šä¸€ä¸ªå…¬å¼çš„çœŸå€¼ â€¢èƒ½åœ¨è®ºåŸŸæœ‰é™æ—¶ï¼Œæ­£ç¡®ä½¿ç”¨ç±»ä¼¼ç­‰å€¼æ¼”ç®—çš„å½¢å¼ç¡®å®šé‡è¯å…¬å¼çš„çœŸå€¼ â€¢èƒ½åˆ¤æ–­ä¸€ä¸ªä¸€é˜¶é€»è¾‘å…¬å¼æ˜¯å¦æ˜¯å‘½é¢˜é€»è¾‘å…¬å¼çš„æ›¿æ¢å®ä¾‹ â€¢èƒ½åˆ¤æ–­ä¸€ä¸ªä¸€é˜¶é€»è¾‘å…¬å¼æ˜¯å¦æ˜¯æ°¸çœŸå¼ã€çŸ›ç›¾å¼è¿˜æ˜¯éæ°¸çœŸçš„å¯æ»¡è¶³å¼ï¼Œå¹¶è¯´æ˜ç†ç”± å­¦ä¼šç”»è¯­æ³•æ ‘ æ‰¾å‡ºå­å…¬å¼ æ‰¾å‡ºé‡è¯çš„è¾–åŸŸ,ä»¥åŠæ¯ä¸ªä¸ªä½“å˜é‡ç¬¦å·æ˜¯æŒ‡ç¤ºå˜é‡,çº¦æŸå‡ºç°è¿˜æ˜¯è‡ªç”±å‡ºç°,å¹¶è¯´æ˜æ¯ä¸ªä¸ªä½“å˜é‡æ˜¯å…¬å¼çš„è‡ªç”±å˜é‡è¿˜æ˜¯çº¦æŸå˜é‡. å¯¹çº¦æŸå˜é‡æ”¹å å¦‚ä½•è§£é‡Š ç¡®å®šä¸€é˜¶é€»è¾‘å…¬å¼çš„çœŸå€¼ ç±»ä¼¼ç­‰å€¼æ¼”ç®—è¿‡ç¨‹! å‘½é¢˜é€»è¾‘å…¬å¼çš„æ›¿æ¢å®ä¾‹ åˆ¤æ–­ä¸€é˜¶é€»è¾‘å…¬å¼æ˜¯æ°¸çœŸå¼çŸ›ç›¾å¼è¿˜æ˜¯å¯æ»¡è¶³å¼","categories":[{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"ç¦»æ•£æ•°å­¦--å‘½é¢˜é€»è¾‘çš„åº”ç”¨","slug":"ç¦»æ•£æ•°å­¦/å‘½é¢˜é€»è¾‘çš„åº”ç”¨","date":"2022-03-19T14:40:23.367Z","updated":"2022-03-19T14:48:44.476Z","comments":true,"path":"2022/03/19/ç¦»æ•£æ•°å­¦/å‘½é¢˜é€»è¾‘çš„åº”ç”¨/","link":"","permalink":"http://example.com/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"è‡ªç„¶è¯­è¨€å‘½é¢˜çš„ç¬¦å·åŒ– åˆ¤æ–­åŸå­å‘½é¢˜å’Œå¤åˆå‘½é¢˜ åˆ¤æ–­å¤åˆå‘½é¢˜å’ŒåŸå­å‘½é¢˜ æ¡ä»¶å‘½é¢˜çš„ç¬¦å·åŒ– æ¡ä»¶å‘½é¢˜çš„ç¬¦å·åŒ– æ™®é€šé€»è¾‘é—®é¢˜çš„ç¬¦å·åŒ–åˆ†æ ç¬¦å·åŒ–ä¸‹é¢çš„æ¨ç†ï¼Œå¹¶æ„é€ è®ºè¯éªŒè¯å…¶æœ‰æ•ˆæ€§ å¦‚æœå°ç‹æ¥ï¼Œåˆ™å°å¼ å’Œå°æä¸­æ°å¥½æœ‰ä¸€äººæ¥ã€‚å¦‚æœå°å¼ æ¥ï¼Œåˆ™å°èµµå°±ä¸æ¥ã€‚æ‰€ä»¥ï¼Œå¦‚æœå°èµµæ¥äº†ï¼Œä½†å°ææ²¡æ¥ï¼Œåˆ™å°ç‹ä¹Ÿæ²¡æ¥ã€‚","categories":[{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"ç¦»æ•£æ•°å­¦--å‘½é¢˜é€»è¾‘çš„æ¨ç†ç†è®º","slug":"ç¦»æ•£æ•°å­¦/å‘½é¢˜é€»è¾‘çš„æ¨ç†ç†è®º","date":"2022-03-19T14:22:02.818Z","updated":"2022-03-19T14:38:34.458Z","comments":true,"path":"2022/03/19/ç¦»æ•£æ•°å­¦/å‘½é¢˜é€»è¾‘çš„æ¨ç†ç†è®º/","link":"","permalink":"http://example.com/2022/03/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E6%8E%A8%E7%90%86%E7%90%86%E8%AE%BA/","excerpt":"","text":"è‡ªç„¶æ¨ç†ç³»ç»Ÿçš„æ¨ç†è§„åˆ™ ä¾‹é¢˜ é™„åŠ å‰ææ³• éªŒè¯è¯¥å…¬å¼çš„æœ‰æ•ˆæ€§? \\[ p \\wedge q \\rightarrow s \\vee r, q \\rightarrow p, r \\rightarrow s \\Rightarrow q \\rightarrow s \\] éªŒè¯ç»“è®ºä¸ºè•´æ¶µå¼çš„æ¨ç†çš„æœ‰æ•ˆæ€§éœ€è¦ä½¿ç”¨é™„åŠ å‰ææ³• å°†ç»“è®ºä¸­çš„è•´æ¶µå¼çš„å‰ä»¶ä½œä¸ºé™„åŠ çš„å‰æä¸€èµ·æ¥æ¨å‡ºå®ƒçš„åä»¶ å³ å°†qä¹Ÿä½œä¸ºé™„åŠ å‰æ,ä¸å…¶ä»–æ¡ä»¶ç»“åˆ,å…±åŒæ¨å‡ºæ¡ä»¶s åè¯æ³• ä¾‹é¢˜","categories":[{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}]},{"title":"ç¨‹è®¾è®°å½•(åä¸€)--Virtual World","slug":"ç¨‹è®¾/Virtual World","date":"2022-03-16T11:44:43.454Z","updated":"2022-03-18T00:53:16.819Z","comments":true,"path":"2022/03/16/ç¨‹è®¾/Virtual World/","link":"","permalink":"http://example.com/2022/03/16/%E7%A8%8B%E8%AE%BE/Virtual%20World/","excerpt":"","text":"æ‰€ç»™çš„æµ‹è¯•ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116using namespace std; void test_1() &#123; person mike, jack, lily, carson, sucie; group school(0), family_1(1), family_2(1); // make group (act as a society) school.addMember(mike); school.addMember(jack); school.addMember(lily); family_1.addMember(mike); family_1.addMember(carson); family_2.addMember(jack); family_2.addMember(lily); family_2.addMember(sucie); // construct relationship in the society school.makeFriend(mike, jack); school.makeFriend(mike, lily); // display the society cout &lt;&lt; &quot;\\n------ SCHOOL -----\\n&quot;; school.displayGroup(); cout &lt;&lt; &quot;\\n------ FAMILY_1 -----\\n&quot;; family_1.displayGroup(); cout &lt;&lt; &quot;\\n------ FAMILY_2 -----\\n&quot;; family_2.displayGroup();&#125; void test_2() &#123; person Baidu, Alibaba, Tencent, NTES, Kingsoft_Antivirus, _360safe; group BAT(1), ECommerce(1), Security(1); // make group (act as a society) BAT.addMember(Baidu); BAT.addMember(Alibaba); BAT.addMember(Tencent); ECommerce.addMember(Baidu); ECommerce.addMember(Alibaba); ECommerce.addMember(Tencent); ECommerce.addMember(NTES); Security.addMember(Kingsoft_Antivirus); Security.addMember(_360safe); // display the society cout &lt;&lt; &quot;\\n------ BAT -----\\n&quot;; BAT.displayGroup(); cout &lt;&lt; &quot;\\n------ ECommerce -----\\n&quot;; ECommerce.displayGroup(); cout &lt;&lt; &quot;\\n------ Security -----\\n&quot;; Security.displayGroup();&#125; void test_3() &#123; person p0, p1, p2, p3, p4; group g0(0), g1(0), g2(1); // make group (act as a society) g0.addMember(p0); g0.addMember(p1); g0.addMember(p2); g1.addMember(p0); g1.addMember(p3); g2.addMember(p3); g2.addMember(p4); // construct relationship in the society g1.makeFriend(p0, p3); g2.breakRelation(p3, p4); g0.deleteMember(p2); // display the society cout &lt;&lt; &quot;\\n------ G0 -----\\n&quot;; g0.displayGroup(); cout &lt;&lt; &quot;\\n------ G1 -----\\n&quot;; g1.displayGroup(); cout &lt;&lt; &quot;\\n------ G2 -----\\n&quot;; g2.displayGroup();&#125; void test_4() &#123; person p[50]; group g0(0), g1(1); int p_count; cin &gt;&gt; p_count; // make group (act as a society) for (int i = 0; i &lt; p_count/2; i++) g0.addMember(p[i]); for (int i = p_count/2; i &lt; p_count; i++) g1.addMember(p[i]); // construct relationship in the society for (int i = 0; i &lt; p_count/5; i += 2) g0.makeFriend(p[i], p[i+1]); for (int i = p_count/2; i &lt; p_count*3/4-1; i += 2) g1.breakRelation(p[i], p[i+1]); for (int i = p_count/4; i &lt; p_count/2; i++) g0.deleteMember(p[i]); for (int i = p_count*3/4; i &lt; p_count; i++) g1.deleteMember(p[i]); // display the society cout &lt;&lt; &quot;\\n------ G0 -----\\n&quot;; g0.displayGroup(); cout &lt;&lt; &quot;\\n------ G1 -----\\n&quot;; g1.displayGroup();&#125; int main() &#123; int test_id; cin &gt;&gt; test_id; switch (test_id) &#123; case 1: test_1(); break; case 2: test_2(); break; case 3: test_3(); break; case 4: test_4(); break; default: cout &lt;&lt; &quot;wrong input\\n&quot;; &#125; return 0;&#125; æ‰€å®Œæˆçš„ç±» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;iostream&gt;using namespace std;class person&#123;public: person()&#123; id=total_person; total_person++; friend_num=0; &#125; friend class group; bool addFriend(int a)&#123; for(int i=0;i&lt;friend_num;i++)&#123; if(friends[i]==a) return false; &#125; friends[friend_num]=a; friend_num++; return true; &#125; bool deleteFriend(int a)&#123; for(int i=0;i&lt;friend_num;i++)&#123; if(friends[i]==a)&#123; int j; for(j=i;j&lt;friend_num-1;j++)&#123; friends[j]=friends[j+1]; &#125; friends[j]=-1; friend_num--; return true; &#125; &#125; return false; &#125;//private: int id; int friend_num; static int total_person; int friends[100];&#125;; int person:: total_person=0; class group&#123;public: person persons[100]; int group_number; int para;public: group(int a)&#123; para=a; group_number=0; &#125; void displayGroup()&#123; for(int i=0;i&lt;group_number;i++)&#123; cout&lt;&lt;&quot;Person_&quot;&lt;&lt;persons[i].id&lt;&lt;&quot;: &quot;; if(persons[i].friend_num!=0)&#123; for(int j=0;j&lt;persons[i].friend_num-1;j++)&#123; cout&lt;&lt;persons[i].friends[j]&lt;&lt;&quot;,&quot;; &#125; cout&lt;&lt;persons[i].friends[persons[i].friend_num-1]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;null&quot;&lt;&lt;endl; &#125; &#125; &#125; bool addMember(person &amp;p)&#123; if(para==1)&#123; persons[group_number++]=p; for(int i=0;i&lt;group_number-1;i++)&#123; makeFriend(persons[group_number-1],persons[i]); &#125; &#125;else&#123; persons[group_number++]=p; &#125; &#125; bool deleteMember(person &amp;p)&#123; for(int i=0;i&lt;group_number;i++)&#123; persons[i].deleteFriend(p.id); if(persons[i].id==p.id)&#123; for(int j=i;j&lt;group_number-1;j++)&#123; persons[j]=persons[j+1]; &#125; &#125; &#125; group_number--; return true; &#125; bool makeFriend(person &amp;p1, person &amp;p2)&#123; int m=-1,n=-1; for(int i=0;i&lt;group_number;i++)&#123; if(p1.id==persons[i].id) m=i; if(p2.id==persons[i].id) n=i; &#125; if(m==-1||n==-1)return false; persons[m].friends[persons[m].friend_num++]=p2.id; persons[n].friends[persons[n].friend_num++]=p1.id; return true; &#125; bool breakRelation(person &amp;p1, person &amp;p2)&#123; int m=-1,n=-1; for(int i=0;i&lt;group_number;i++)&#123; if(p1.id==persons[i].id) m=i; if(p2.id==persons[i].id) n=i; &#125; for(int i=0;i&lt;p1.friend_num;i++)&#123; if(persons[m].friends[i]==p2.id)&#123; int j; for(j=i;j&lt;p1.friend_num-1;j++)&#123; persons[m].friends[j]=persons[m].friends[j+1]; &#125; persons[m].friends[j]=-1; &#125; &#125; persons[m].friend_num--; for(int i=0;i&lt;p2.friend_num;i++)&#123; if(persons[n].friends[i]==p1.id)&#123; int j; for(j=i;j&lt;p2.friend_num-1;j++)&#123; persons[n].friends[j]=persons[n].friends[j+1]; &#125; persons[n].friends[j]=-1; return true; &#125; &#125; persons[n].friend_num--; return false; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(å)--Constructor and Inheritance","slug":"ç¨‹è®¾/ç»§æ‰¿çš„é¡ºåº","date":"2022-03-13T08:32:09.137Z","updated":"2022-04-12T06:01:45.785Z","comments":true,"path":"2022/03/13/ç¨‹è®¾/ç»§æ‰¿çš„é¡ºåº/","link":"","permalink":"http://example.com/2022/03/13/%E7%A8%8B%E8%AE%BE/%E7%BB%A7%E6%89%BF%E7%9A%84%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"å®Œæˆç±»B 12345678910111213class B: public A &#123; public: B(int x, int y): A(x), b(y) &#123;&#125;; void show() &#123; A::show(); cout&lt;&lt;&quot;b=&quot; &lt;&lt; b &lt;&lt; endl; &#125;; private: int b;&#125;; 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class A&#123;public: A(int a0):a(a0) &#123;&#125; void show() &#123; cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; &#125;private: int a;&#125;;#include &quot;source.h&quot;int main()&#123;// freopen(&quot;test01.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;test01.out&quot;, &quot;w&quot;, stdout); B b(10,15); b.show(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(ä¹)--animal and human","slug":"ç¨‹è®¾/animal and human","date":"2022-03-13T08:05:40.835Z","updated":"2022-03-13T08:32:33.247Z","comments":true,"path":"2022/03/13/ç¨‹è®¾/animal and human/","link":"","permalink":"http://example.com/2022/03/13/%E7%A8%8B%E8%AE%BE/animal%20and%20human/","excerpt":"","text":"é¢˜ç›®æ‰€ç»™ä»£ç  123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;animal.h&quot;#include &quot;human.h&quot;int main() &#123; std::string s, n; int e; std::cin &gt;&gt; s &gt;&gt; e &gt;&gt; n; animal * p = new animal(s, e); p-&gt;print_eyes(); delete p; human h(n); p = &amp;h; p-&gt;print_eyes(); const human &amp; q = h; q.greeting(); return 0;&#125; è‡ªå·±å®Œæˆçš„ä»£ç  123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; class animal&#123;private: string _species; int _eyes;public: animal(string a,int b):_species(a),_eyes(b)&#123;&#125; void print_eyes()&#123; cout&lt;&lt;_species&lt;&lt;&quot; has &quot;&lt;&lt;_eyes&lt;&lt;&quot; eyes.&quot;&lt;&lt;endl; &#125; &#125;;class human: public animal&#123;private: string _name;public: human(string a):animal(&quot;Human&quot;,2)&#123; _name=a; &#125; void greeting()const&#123; cout&lt;&lt;&quot;Hello, I&#x27;m &quot;&lt;&lt;_name&lt;&lt;endl; &#125;&#125;; æµ‹è¯• è¾“å…¥ 1234Spider8Citron è¾“å‡º 1234Spider has 8 eyes.Human has 2 eyes.Hello, I&#x27;m Citron.","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(å…«)--ç»§æ‰¿ red car","slug":"ç¨‹è®¾/ç»§æ‰¿car","date":"2022-03-13T06:42:18.853Z","updated":"2022-03-13T07:28:23.206Z","comments":true,"path":"2022/03/13/ç¨‹è®¾/ç»§æ‰¿car/","link":"","permalink":"http://example.com/2022/03/13/%E7%A8%8B%E8%AE%BE/%E7%BB%A7%E6%89%BFcar/","excerpt":"","text":"sample output 123456789101112131415//--- build car ---Construct a car//--- build wheel ---Construct a wheel//--- build red car ---Construct a carConstruct a wheelConstruct a wheelConstruct a wheelConstruct a wheelConstruct a red car Red Car 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class Car&#123;public: Car()&#123; cout&lt;&lt;&quot;Construct a car&quot;&lt;&lt;endl; &#125;&#125;; class Wheel&#123;public: Wheel()&#123; cout&lt;&lt;&quot;Construct a wheel&quot;&lt;&lt;endl; &#125;&#125;;class RedCar: public Car&#123; Wheel a,s,d,f;public: RedCar():Car()&#123; cout&lt;&lt;&quot;Construct a red car&quot;&lt;&lt;endl; &#125;&#125;;int main() &#123; cout &lt;&lt; &quot;--- build car ---&quot; &lt;&lt; endl; Car car; cout &lt;&lt; endl; cout &lt;&lt; &quot;--- build wheel ---&quot; &lt;&lt; endl; Wheel wheel; cout &lt;&lt; endl; cout &lt;&lt; &quot;--- build red car ---&quot; &lt;&lt; endl; RedCar redcar; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¬¬å››ç« -Boolean Algebra and Logic Simplification  (äºŒ)","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å››ç« (äºŒ)","date":"2022-03-13T06:10:42.920Z","updated":"2022-03-17T08:42:35.094Z","comments":true,"path":"2022/03/13/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å››ç« (äºŒ)/","link":"","permalink":"http://example.com/2022/03/13/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E4%BA%8C)/","excerpt":"","text":"å¡è¯ºå›¾åŒ–ç®€é‡ç‚¹ ä¼ ç»Ÿæ–¹æ³•åŒ–ç®€ è¿™ç§åŒ–ç®€æ–¹æ³•è¿˜æ˜¯æœ‰äº›å¤æ‚ å¡è¯ºå›¾åŒ–ç®€ Karnaugh Map A systematic method for simplifying Boolean expressions Produce the simplest SOP or POS expression Presents all of the possible values of input variables An array of cells Each cell represents a binary value of the input variables Adjacency in position equivalents to adjacency in Boolean algebra ç›¸é‚»å•å…ƒæ ¼ä¹‹é—´åªèƒ½æœ‰ä¸€ä¸ªä½æ˜¯ä¸åŒçš„(æ ¼é›·ç ) ä»¥sopä¸¾ä¾‹ åœˆ\\(2^n\\)æ•°ç›®çš„æ ¼å­,æ¯”å¦‚è¯´èƒ½åœˆ1ã€ï¼”ã€ï¼˜ä¸ªæ ¼å­,ç•™ä¸‹ç›¸åŒçš„é¡¹,æ¯”å¦‚Cå›¾çš„å·¦ä¸Šè§’é‚£ä¸ªå››ä¸ªæ ¼å­,å››ä¸ªé¡¹åˆ™åŒ–ç®€ä¸º\\(\\bar A\\bar C\\) Group the â€˜1â€™s Maximize the size of the groups Minimize the number of groups Rules A group must contain \\(2^n\\) cells Each cell must be adjacent to one or more cells in that group Include â€˜1â€™s as much as possible Each â€˜1â€™ on the map must be included at least one group Cell with â€˜1â€™ can be included into more than one group å…³äºä¸­é—´é‚£æ¡çº¿è½´å¯¹ç§°çš„å…ƒç´ ä¹Ÿæ˜¯ä½ç½®ç›¸é‚». 5ä¸ªå˜é‡çš„è¯ä¹Ÿå¯ä»¥ç”»ä¸¤ä¸ªå››ä¸ªå˜é‡çš„å¡è¯ºå›¾,ç„¶åå èµ·æ¥,ä¸Šä¸‹ç›¸é‚»çš„å…ƒç´ ä¹Ÿæ˜¯ä½ç½®ç›¸é‚»","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"ç¨‹è®¾è®°å½•(ä¸ƒ)--ç»§æ‰¿","slug":"ç¨‹è®¾/ç»§æ‰¿å„ç§ç±»çš„é¡ºåº","date":"2022-03-11T01:14:31.531Z","updated":"2022-03-13T06:43:21.958Z","comments":true,"path":"2022/03/11/ç¨‹è®¾/ç»§æ‰¿å„ç§ç±»çš„é¡ºåº/","link":"","permalink":"http://example.com/2022/03/11/%E7%A8%8B%E8%AE%BE/%E7%BB%A7%E6%89%BF%E5%90%84%E7%A7%8D%E7%B1%BB%E7%9A%84%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"è¿™é¢˜å…³äºç»§æ‰¿çš„æ—¶å€™å„ç§ç±»çš„åˆ›å»ºå’Œé”€æ¯é¡ºåº 1234567891011121314151617181920212223 #include &lt;iostream&gt;#include &quot;Inheritance.hpp&quot;using std::cin;using std::cout;using std::endl;using std::string;int main() &#123; int token; cin &gt;&gt; token; cout &lt;&lt; &quot;test token: &quot; &lt;&lt; token &lt;&lt; endl; cout &lt;&lt; &quot;\\ncreat base A&quot; &lt;&lt; endl; baseA ba; cout &lt;&lt; &quot;\\ncreat base B&quot; &lt;&lt; endl; baseB bb; cout &lt;&lt; &quot;\\ncreat derived A&quot; &lt;&lt; endl; derivedA da; cout &lt;&lt; &quot;\\ncreat derived B&quot; &lt;&lt; endl; derivedB db; cout &lt;&lt; &quot;\\ncreat C&quot; &lt;&lt; endl; C c; cout &lt;&lt; &quot;\\ndestructor&quot; &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132 #include &quot;Inheritance.hpp&quot; baseA::baseA() &#123; cout &lt;&lt; &quot;base A&quot; &lt;&lt; endl;&#125; baseA::~baseA() &#123; cout &lt;&lt; &quot;~ base A&quot; &lt;&lt; endl;&#125; baseB::baseB() &#123; cout &lt;&lt; &quot;base B&quot; &lt;&lt; endl;&#125; baseB::~baseB() &#123; cout &lt;&lt; &quot;~ base B&quot; &lt;&lt; endl;&#125; derivedA::derivedA() &#123; cout &lt;&lt; &quot;derived A&quot; &lt;&lt; endl;&#125; derivedA::~derivedA() &#123; cout &lt;&lt; &quot;~ derived A&quot; &lt;&lt; endl;&#125; derivedB::derivedB() &#123; cout &lt;&lt; &quot;derived B&quot; &lt;&lt; endl;&#125; derivedB::~derivedB() &#123; cout &lt;&lt; &quot;~ derived B&quot; &lt;&lt; endl;&#125; C::C() &#123; cout &lt;&lt; &quot;C&quot; &lt;&lt; endl;&#125; C::~C() &#123; cout &lt;&lt; &quot;~ C&quot; &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243\\\\æ‰€éœ€è¾“å‡ºtest token: 6590creat base Abase Acreat base Bbase Bcreat derived Abase Aderived Acreat derived Bbase Abase Bderived Bcreat Cbase Aderived Abase Abase Bderived BCdestructor~ C~ derived B~ base B~ base A~ derived A~ base A~ derived B~ base B~ base A~ derived A~ base A~ base B~ base A 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class baseA&#123;public: baseA(); ~baseA();&#125;;class baseB&#123;public: baseB(); ~baseB();&#125;;class derivedA:public baseA&#123;public: derivedA(); ~derivedA();&#125;;class derivedB:public baseA, public baseB&#123;public: derivedB(); ~derivedB();&#125;;class C:public derivedA, public derivedB&#123;public: C(); ~C();&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(å…­)--ä¸€é“å·¨å·¨é•¿çš„é¢˜ç›®","slug":"ç¨‹è®¾/åˆ†æ•°(è¾ƒéš¾)","date":"2022-03-09T12:25:22.126Z","updated":"2022-03-11T01:22:52.709Z","comments":true,"path":"2022/03/09/ç¨‹è®¾/åˆ†æ•°(è¾ƒéš¾)/","link":"","permalink":"http://example.com/2022/03/09/%E7%A8%8B%E8%AE%BE/%E5%88%86%E6%95%B0(%E8%BE%83%E9%9A%BE)/","excerpt":"","text":"ä¸¤ç™¾äº”åè¡Œä»£ç ç»™æˆ‘å†™éº»äº† é¢˜ç›®æ‰€ç»™ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#ifndef RATIONAL_H_#define RATIONAL_H_#include &lt;string&gt;using namespace std;class Rational &#123; public: Rational(); Rational(long numerator, long denominator); long getNumerator(); long getDenominator(); Rational add(Rational &amp;secondRational); Rational subtract(Rational &amp;secondRational); Rational multiply(Rational &amp;secondRational); Rational divide(Rational &amp;secondRational); int compareTo(Rational &amp;secondRational); bool equals(Rational &amp;secondRational); int intValue(); //Returns the numerator/denominator double doubleValue(); //Returns 1.0*numberator/denominator string toString(); bool operator&lt;(Rational &amp;secondRational); bool operator&lt;=(Rational &amp;secondRational); bool operator&gt;(Rational &amp;secondRational); bool operator&gt;=(Rational &amp;secondRational); bool operator!=(Rational &amp;secondRational); bool operator==(Rational &amp;secondRational); Rational operator+(Rational &amp;secondRational); Rational operator-(Rational &amp;secondRational); Rational operator*(Rational &amp;secondRational); Rational operator/(Rational &amp;secondRational); Rational operator+=(Rational &amp;secondRational); Rational operator-=(Rational &amp;secondRational); Rational operator*=(Rational &amp;secondRational); Rational operator/=(Rational &amp;secondRational); Rational operator++(); Rational operator--(); Rational operator++(int dummy); Rational operator--(int dummy); Rational operator+(); Rational operator-(); long&amp; operator[] (int ); friend ostream &amp;operator&lt;&lt;(ostream &amp;stream, Rational &amp;rational); friend istream &amp;operator&gt;&gt;(istream &amp;stream, Rational &amp;rational); operator double(); private: long numerator; //ï¹?â„…è»Š. long denominator; //ï¹???ã’?2??é‚¦?a0. static long gcd(long n, long d);&#125;;#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;string&gt;#include &quot;Rational.h&quot;using namespace std;int main()&#123; // Create and initialize two rational numbers r1 and r2. Rational r1(3, 2); Rational r2(2, 3); // Test relational operators cout &lt;&lt; r1 &lt;&lt; &quot; &gt; &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &gt; r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &gt;= r1) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; &lt; &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &lt; r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 &lt;= r1) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; == &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 == r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; == &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 == r1) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; != &quot; &lt;&lt; r2 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 != r2) &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; != &quot; &lt;&lt; r1 &lt;&lt; &quot; is &quot; &lt;&lt; (r1 != r1) &lt;&lt; endl; // Test toString, add, substract, multiply, and divide operators cout &lt;&lt; r1 &lt;&lt; &quot; + &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 + r2 &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; - &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 - r2 &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; * &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 * r2 &lt;&lt; endl; cout &lt;&lt; r1 &lt;&lt; &quot; / &quot; &lt;&lt; r2 &lt;&lt; &quot; = &quot; &lt;&lt; r1 / r2 &lt;&lt; endl; // Test shorthand operators Rational r3(1, 2); r3 += r1; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; r3 -= r1; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; // Test function operator [] Rational r4(1, 2); r4[0] = 3; r4[1] = 4; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; // Test function operators for // prefix ++ and -- // postfix ++ and -- r3 = r4++; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; r3 = r4--; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; r3 = ++r4; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; r3 = --r4; cout &lt;&lt; &quot;r3 is &quot; &lt;&lt; r3 &lt;&lt; endl; cout &lt;&lt; &quot;r4 is &quot; &lt;&lt; r4 &lt;&lt; endl; // Test function operator for conversion cout &lt;&lt; &quot;1 + &quot; &lt;&lt; r4 &lt;&lt; &quot; is &quot; &lt;&lt; (1 + r4) &lt;&lt; endl; return 0;&#125; å®Œæˆçš„ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179long Rational:: gcd(long n,long d)&#123; for(int i=min(n,d);i&gt;=2;i--)&#123; if(n%i==0&amp;&amp;d%i) return i; &#125; return 1;&#125;Rational:: Rational()&#123; numerator=0; denominator=1;&#125;Rational:: Rational(long a,long b):numerator(a),denominator(b)&#123;&#125;long Rational::getNumerator()&#123;return numerator;&#125;long Rational::getDenominator()&#123;return denominator;&#125;Rational Rational::add(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator+secondRational.numerator*denominator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;Rational Rational:: subtract(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator-secondRational.numerator*denominator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;Rational Rational::multiply(Rational &amp;secondRational)&#123; long a=numerator*secondRational.numerator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;Rational Rational:: divide(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator; long b=denominator*secondRational.numerator; a=a/gcd(a,b); b=b/gcd(a,b); return Rational(a,b);&#125;int Rational::compareTo(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator-secondRational.numerator*denominator; long b=denominator*secondRational.denominator; a=a/gcd(a,b); b=b/gcd(a,b); if(a&gt;0) return 1; if(a==0) return 0; if(a&lt;0) return -1;&#125;bool Rational:: equals(Rational &amp;secondRational)&#123; long a=numerator*secondRational.denominator-secondRational.numerator*denominator; if(a==0) return true; else return false;&#125;int Rational::intValue()&#123; return numerator/denominator;&#125;double Rational:: doubleValue()&#123; return 1.0*numerator/denominator;&#125;bool Rational:: operator==(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==0) return true; else return false;&#125;bool Rational:: operator!=(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==0) return false; else return true;&#125;bool Rational:: operator&gt;(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==1) return true; else return false;&#125;bool Rational:: operator&lt;(Rational &amp;secondRational)&#123; if(compareTo(secondRational) ==-1) return true; else return false;&#125;bool Rational:: operator&gt;=(Rational &amp;secondRational)&#123; if(compareTo(secondRational) &gt;=0) return true; else return false;&#125;bool Rational:: operator&lt;=(Rational &amp;secondRational)&#123; if(compareTo(secondRational) &lt;=0) return true; else return false;&#125;Rational Rational:: operator+(Rational &amp;secondRational)&#123; return add(secondRational);&#125;Rational Rational:: operator-(Rational &amp;secondRational)&#123; return subtract(secondRational);&#125;Rational Rational:: operator*(Rational &amp;secondRational)&#123; return multiply(secondRational);&#125;Rational Rational:: operator/(Rational &amp;secondRational)&#123; return divide(secondRational);&#125;Rational Rational:: operator+=(Rational &amp;secondRational)&#123; *this=add(secondRational); return *this;&#125;Rational Rational:: operator-=(Rational &amp;secondRational)&#123; *this=subtract(secondRational); return *this;&#125;Rational Rational:: operator*=(Rational &amp;secondRational)&#123; *this=multiply(secondRational); return *this;&#125;Rational Rational:: operator/=(Rational &amp;secondRational)&#123; *this=divide(secondRational); return *this;&#125;long&amp; Rational::operator[] (int a)&#123; if(a) return denominator; else return numerator;&#125;Rational Rational:: operator+()&#123; return Rational(numerator,denominator);&#125;Rational Rational:: operator-()&#123; return Rational(-1*numerator,-1*denominator);&#125;Rational:: operator double()&#123; return 1.0*numerator/denominator;&#125;Rational Rational:: operator++()&#123; numerator+=denominator; return *this;&#125;Rational Rational:: operator--()&#123; numerator-=denominator; return *this;&#125;Rational Rational:: operator++(int dummy)&#123; numerator+=denominator; return Rational(numerator-denominator,denominator);&#125;Rational Rational:: operator--(int dummy)&#123; numerator-=denominator; return Rational(numerator+denominator,denominator); &#125;string Rational::toString() &#123; char s[50]; if ( denominator == 1) &#123; sprintf(s,&quot;%ld&quot;,numerator); &#125; else &#123; sprintf(s,&quot;%ld/%ld&quot;,numerator,denominator); &#125; return string(s);&#125;ostream&amp; operator&lt;&lt;(ostream &amp;str, Rational &amp;rational)&#123; cout &lt;&lt; rational.toString(); return str;&#125;istream&amp; operator&gt;&gt;(istream &amp;input ,Rational &amp; k)&#123; string s; int i = 0; input &gt;&gt; s; while (s[i] != &#x27;/&#x27;) k.numerator = k.numerator * 10 + s[i] - &#x27;0&#x27;; ++i; while (i &lt; s.length()) k.denominator = 10 * k.denominator + s[i] - &#x27;0&#x27;; return input;&#125; é‡åˆ°çš„é—®é¢˜ ostreamåœ¨å®šä¹‰çš„æ—¶å€™ä¸ç”¨åŠ rational:: å› ä¸ºostreamæ˜¯å‹å…ƒå‡½æ•°,å‹å…ƒå‡½æ•°ä¸å±äºæˆå‘˜å‡½æ•° ostreamçš„æ ¼å¼ 123456ostream&amp; operator&lt;&lt;(ostream &amp;str, Rational &amp;rational)&#123; cout &lt;&lt; rational.toString(); return str;&#125; ç±»å‹è½¬æ¢å‡½æ•° 1234long&amp; Rational::operator[] (int a)&#123; if(a) return denominator; else return numerator;&#125; å‰ç½®å’Œåç½® 12345678Rational Rational:: operator--()&#123; numerator-=denominator; return *this;&#125;Rational Rational:: operator--(int dummy)&#123; numerator-=denominator; return Rational(numerator+denominator,denominator); &#125; æœ‰ç‚¹ç–‘æƒ‘ 1234Rational Rational:: operator/=(Rational &amp;secondRational)&#123; *this=divide(secondRational); return *this;&#125; è¿™ä¹Ÿèƒ½å°†*thisèµ‹å€¼,æ˜æ˜æ²¡æœ‰é‡è½½=å·,éš¾é“è·Ÿæ˜¨å¤©åšçš„æ˜¯ä¸€ä¸ªç±»å‹çš„å—.ä¹Ÿæ˜¯å› ä¸ºlei","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(äº”)--complex operator(ä¸€é“å¹³å¹³æ— å¥‡çš„é‡è½½è¿ç®—ç¬¦)","slug":"ç¨‹è®¾/complex operator","date":"2022-03-09T08:28:42.451Z","updated":"2022-05-08T07:52:42.333Z","comments":true,"path":"2022/03/09/ç¨‹è®¾/complex operator/","link":"","permalink":"http://example.com/2022/03/09/%E7%A8%8B%E8%AE%BE/complex%20operator/","excerpt":"","text":"Description å®ç°å¤æ•°çš„æ“ä½œç¬¦é‡è½½ï¼Œä½ éœ€è¦åšçš„æ˜¯ï¼Œå°†complex.hæ–‡ä»¶çš„å‡½æ•°å£°æ˜ï¼Œå…¨éƒ¨åœ¨complex.cppä¸­å®ç°ã€‚ ç±»çš„å£°æ˜å¦‚ä¸‹ï¼š 1234567891011121314151617181920class COMPLEX&#123;public: COMPLEX(double r = 0, double i = 0); // æ„é€ å‡½æ•° COMPLEX(const COMPLEX &amp;other); // æ‹·è´æ„é€ å‡½æ•° void print(); // æ‰“å°å¤æ•° // é‡è½½åŠ æ³•è¿ç®—ç¬¦ï¼ˆäºŒå…ƒï¼‰ COMPLEX operator+(const COMPLEX &amp;other); // é‡è½½å‡æ³•è¿ç®—ç¬¦ï¼ˆäºŒå…ƒï¼‰ COMPLEX operator-(const COMPLEX &amp;other); COMPLEX operator-(); // é‡è½½æ±‚è´Ÿè¿ç®—ç¬¦ï¼ˆä¸€å…ƒï¼‰ // é‡è½½èµ‹å€¼è¿ç®—ç¬¦ï¼ˆäºŒå…ƒï¼‰ COMPLEX operator=(const COMPLEX &amp;other); COMPLEX &amp; operator++(); //é‡è½½å‰ç½®++ COMPLEX operator++(int); //é‡è½½åç½®++ COMPLEX &amp; operator--(); //é‡è½½å‰ç½®-- COMPLEX operator--(int); //é‡è½½åç½®--protected: double real, image; // å¤æ•°çš„å®éƒ¨ä¸è™šéƒ¨&#125;; Sample Output 123456789101+2i-5-6i-5-6i-4-5i-4-5i-5-6i-6-7i-6-7i-5-6i-5-6i æ„Ÿè§‰æ²¡å•¥éœ€è¦æ³¨æ„çš„,å¤§å®¶è‡ªå·±çœ‹å§(à¹‘â€¢Ì€ã…‚â€¢Ì)Ùˆâœ§ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;#ifndef COMPLEX_H#define COMPLEX_Hclass COMPLEX&#123;public: COMPLEX(double r = 0, double i = 0); // æ„é€ å‡½æ•° COMPLEX(const COMPLEX &amp;other); // æ‹·è´æ„é€ å‡½æ•° void print(); // æ‰“å°å¤æ•° // é‡è½½åŠ æ³•è¿ç®—ç¬¦ï¼ˆäºŒå…ƒï¼‰ COMPLEX operator+(const COMPLEX &amp;other); // é‡è½½å‡æ³•è¿ç®—ç¬¦ï¼ˆäºŒå…ƒï¼‰ COMPLEX operator-(const COMPLEX &amp;other); COMPLEX operator-(); // é‡è½½æ±‚è´Ÿè¿ç®—ç¬¦ï¼ˆä¸€å…ƒï¼‰ // é‡è½½èµ‹å€¼è¿ç®—ç¬¦ï¼ˆäºŒå…ƒï¼‰ COMPLEX operator=(const COMPLEX &amp;other); COMPLEX &amp;operator++(); //é‡è½½å‰ç½®++ COMPLEX operator++(int); //é‡è½½åç½®++ COMPLEX &amp;operator--(); //é‡è½½å‰ç½®-- COMPLEX operator--(int); //é‡è½½åç½®--protected: double real, image; // å¤æ•°çš„å®éƒ¨ä¸è™šéƒ¨&#125;;#endifCOMPLEX::COMPLEX(double r,double i):real(r),image(i)&#123;&#125;COMPLEX::COMPLEX(const COMPLEX &amp;other)&#123; real=other.real; image=other.image;&#125;void COMPLEX::print()&#123; if(!real &amp;&amp; !image ) cout &lt;&lt; 0 &lt;&lt; endl; else if(!real) cout &lt;&lt; noshowpos &lt;&lt; image &lt;&lt; &#x27;i&#x27;; else if(!image) cout&lt;&lt; noshowpos&lt;&lt; real; else cout &lt;&lt; noshowpos&lt;&lt; real &lt;&lt;showpos &lt;&lt; image &lt;&lt; &#x27;i&#x27;; cout &lt;&lt; endl &lt;&lt; noshowpos;&#125;COMPLEX COMPLEX::operator+(const COMPLEX &amp;other)&#123; return COMPLEX(other.real+real,other.image+image);&#125;COMPLEX COMPLEX::operator-(const COMPLEX &amp;other)&#123; return COMPLEX(real-other.real,image-other.image);&#125; COMPLEX COMPLEX::operator-()&#123; return COMPLEX(-1*real,-1*image);&#125; COMPLEX COMPLEX::operator=(const COMPLEX &amp;other)&#123; real=other.real; image=other.image; return *this;&#125;COMPLEX &amp;COMPLEX::operator++()&#123; real++; return *this;&#125;COMPLEX COMPLEX::operator++(int)&#123; COMPLEX temp (*this); real++; return temp;&#125;COMPLEX &amp;COMPLEX::operator--()&#123; real--; return *this;&#125;COMPLEX COMPLEX::operator--(int)&#123; COMPLEX temp(*this); real--; return temp; &#125;int main()&#123; COMPLEX c1(1, 2); // å®šä¹‰ä¸€ä¸ªå€¼ä¸º1 + 2içš„å¤æ•°c1 COMPLEX c2(2); // å®šä¹‰ä¸€ä¸ªå€¼ä¸º2çš„å¤æ•°c2 COMPLEX c3(c1); // ç”¨æ‹·è´æ„é€ å‡½æ•°åˆ›å»ºä¸€ä¸ªå€¼åŒc1çš„æ–°å¤æ•° c3.print(); // æ‰“å°c3çš„å€¼ c1 = c1 + c2 + c3; // å°†c1åŠ ä¸Šc2å†åŠ ä¸Šc3èµ‹å€¼ç»™c1 c2 = -c3; // c2ç­‰äºc3æ±‚è´Ÿ c3 = c2 - c1; // c3ç­‰äºc2å‡å»c1 c3.print(); // å†æ‰“å°è¿ç®—åc3çš„å€¼ COMPLEX temp= c3++; temp.print(); c3.print(); temp=c3--; temp.print(); c3.print(); temp=--c3; temp.print(); c3.print(); temp=++c3; temp.print(); c3.print(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(å››)--simple String","slug":"ç¨‹è®¾/simple string(å¤ä¹ )","date":"2022-03-08T11:17:18.765Z","updated":"2022-05-08T08:02:27.198Z","comments":true,"path":"2022/03/08/ç¨‹è®¾/simple string(å¤ä¹ )/","link":"","permalink":"http://example.com/2022/03/08/%E7%A8%8B%E8%AE%BE/simple%20string(%E5%A4%8D%E4%B9%A0)/","excerpt":"","text":"ä¸€é“æ¯”è¾ƒç»¼åˆçš„é¢˜ç›® Description å®ç°ä¸€ä¸ªåä¸ºCSimpleStringçš„ç±»ï¼Œè¯¥ç±»å¯ä»¥å®Œæˆç®€å•çš„å­—ç¬¦ä¸²æ“ä½œã€‚ä½ éœ€è¦å®ç°ç±»ä¸­çš„è¿™ç±»æˆå‘˜å‡½æ•°ï¼š CSimpleString();æ„é€ å‡½æ•°ï¼Œäº§ç”Ÿä¸€ä¸ªç©ºå­—ç¬¦ä¸²ã€‚ CSimpleString(char*);æ„é€ å‡½æ•°ï¼Œäº§ç”Ÿä¸€ä¸ªä¸²ï¼Œå¹¶ç”¨ä¸€ä¸ªchar å‹å­—ç¬¦ä¸²åˆå§‹åŒ–å®ƒã€‚ ~CSimpleString();ææ„å‡½æ•°ã€‚ const char&amp; operator[](unsigned int pos);é‡è½½[]è¿ç®—ç¬¦ï¼Œè¿”å›ä¸²ä¸­ç¬¬poså·å­—ç¬¦ï¼Œä¸‹æ ‡ä» 0 å¼€å§‹ã€‚ CSimpleString&amp; operator=(const CSimpleString &amp;other);é‡è½½=è¿ç®—ç¬¦ï¼Œå°†ä¸€ä¸ªCSimpleStringå¯¹è±¡ä¸­çš„å†…å®¹copyåˆ°å¦ä¸€ä¸ªCSimpleStringå¯¹è±¡ä¸­ã€‚ CSimpleString operator+(const CSimpleString &amp;other);é‡è½½+è¿ç®—ç¬¦ï¼Œå°†ä¸¤ä¸ªCSimpleStringå¯¹è±¡ä¸­çš„ä¸²æ‹¼æ¥èµ·æ¥å¹¶äº§ç”Ÿæ–°ä¸²ã€‚ unsigned int length();è¿”å›ä¸²é•¿åº¦ã€‚ é¢˜ç›®æ‰€ç»™ä»£ç  12345678910111213class CSimpleString &#123; char *str; unsigned int len;public: CSimpleString(); CSimpleString(char*); CSimpleString(const CSimpleString&amp; other); ~CSimpleString(); const char&amp; operator[](unsigned int pos); CSimpleString&amp; operator=(const CSimpleString &amp;other); CSimpleString operator+(const CSimpleString &amp;other); unsigned int length();&#125;; 12345678910111213141516171819202122#include &lt;iostream&gt;#include &quot;SimpleString.hpp&quot;using std::cin;using std::cout;using std::endl;int main() &#123; char str[100]; cin &gt;&gt; str; CSimpleString s1(str); cin &gt;&gt; str; CSimpleString s2(str); CSimpleString s3; s1 = s1 + s3; s2 = s3 + s2; s3 = s1 + s2; s1 = s1; s1 = s3 + s2; for(unsigned int i = 0; i &lt; s1.length(); ++i) cout &lt;&lt; s1[i]; cout &lt;&lt; endl; return 0;&#125; é™æ€æˆå‘˜å‡½æ•°æ²¡æœ‰thisæŒ‡é’ˆ æˆ‘çš„ç­”æ¡ˆ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include&lt;string.h&gt;using std::cin;using std::cout;using std::endl;class CSimpleString &#123; char *str; unsigned int len;public: CSimpleString(); CSimpleString(char*); CSimpleString(const CSimpleString&amp; other); ~CSimpleString(); const char&amp; operator[](unsigned int pos); CSimpleString&amp; operator=(const CSimpleString &amp;other); CSimpleString operator+(const CSimpleString &amp;other); unsigned int length();&#125;;CSimpleString::CSimpleString()&#123; str=NULL; str=new char[100]; str[0]=&#x27;\\0&#x27;; len=0;&#125;CSimpleString::CSimpleString(char* a)&#123; str=NULL; str=new char[100]; str[0]=&#x27;\\0&#x27;; strcpy(str,a); len=strlen(a);&#125;CSimpleString::~CSimpleString()&#123; delete []str; &#125;CSimpleString::CSimpleString(const CSimpleString&amp; other)&#123; len=other.len; strcpy(str,other.str); str[len]=&#x27;\\0&#x27;;&#125;CSimpleString &amp; CSimpleString:: operator=(const CSimpleString &amp;other)&#123; len=other.len; strcpy(str,other.str); str[len]=&#x27;\\0&#x27;; return *this;&#125;CSimpleString CSimpleString:: operator+(const CSimpleString &amp;other)&#123; CSimpleString temp; temp.len=this-&gt;len+other.len; strcpy(temp.str,this-&gt;str); strcat(temp.str,other.str); return temp;&#125;unsigned int CSimpleString::length()&#123; return len;&#125; const char&amp; CSimpleString::operator[](unsigned int pos)&#123; return this-&gt;str[pos];&#125; å‚è€ƒç­”æ¡ˆ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstring&gt;#include &quot;SimpleString.hpp&quot;#include &lt;new&gt;CSimpleString::CSimpleString() &#123; new(this) CSimpleString(&quot;&quot;);&#125;CSimpleString::CSimpleString(char *s) &#123; len = strlen(s); str = new char[len + 1]; strcpy(str, s);&#125;CSimpleString::CSimpleString(const CSimpleString&amp; other)&#123; new(this) CSimpleString(other.str); //return *this;&#125;CSimpleString::~CSimpleString() &#123; delete [] str;&#125;const char&amp; CSimpleString::operator[](unsigned int pos) &#123; return str[pos];&#125;CSimpleString&amp; CSimpleString::operator=(const CSimpleString&amp; other) &#123; if(this != &amp;other) &#123; delete [] str; new(this) CSimpleString(other.str); &#125; return *this;&#125;CSimpleString CSimpleString::operator+(const CSimpleString&amp; other) &#123; CSimpleString ans; delete [] (ans.str); ans.len = len + other.len; ans.str = new char[ans.len + 1]; strcpy(ans.str, str); strcat(ans.str, other.str); return ans;&#125;unsigned int CSimpleString::length() &#123; return len;&#125; ä»»å°ç‹—ä»£ç (â—†ã‚œâˆ€ã‚œï¼‰b 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&quot;SimpleString.hpp&quot;#include&lt;stddef.h&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;CSimpleString::CSimpleString():str(NULL), len(0)&#123; str = new char[1]; str[0] = &#x27;\\0&#x27;;&#125;CSimpleString::CSimpleString(char*aa)&#123; len = strlen(aa); str = new char[len + 1]; strcpy(str, aa); str[len] = &#x27;\\0&#x27;;&#125;unsigned int CSimpleString::length()&#123; return len;&#125;CSimpleString::~CSimpleString()&#123; if(str) delete [] str;&#125;const char&amp; CSimpleString::operator[](unsigned int pos)&#123; return str[pos];&#125;CSimpleString&amp; CSimpleString::operator=(const CSimpleString &amp;other)&#123; if(str) delete [] str; len = other.len; str = new char[len + 1]; unsigned int i; for(i = 0; i &lt; len; i++)&#123; str[i] = other.str[i]; &#125; str[i] = &#x27;\\0&#x27;; return *this; &#125;CSimpleString CSimpleString::operator+(const CSimpleString &amp;other)&#123; char* aa = NULL; aa = new char [len + other.len + 1]; unsigned int i = 0; while(i &lt; len)&#123; aa[i] = str[i]; i++; &#125; int j = 0; while(i &lt; len + other.len)&#123; aa[i] = other.str[j]; j++; i++; &#125; aa[i] = &#x27;\\0&#x27;; CSimpleString temp(aa); delete [ ] aa; return temp;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(ä¸‰)--éšä¾¿è®°è®°ç®€å•é¢˜","slug":"ç¨‹è®¾/é‡è½½æ“ä½œç¬¦()","date":"2022-03-08T11:07:02.430Z","updated":"2022-03-08T11:13:31.881Z","comments":true,"path":"2022/03/08/ç¨‹è®¾/é‡è½½æ“ä½œç¬¦()/","link":"","permalink":"http://example.com/2022/03/08/%E7%A8%8B%E8%AE%BE/%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6()/","excerpt":"","text":"é‡è½½æ“ä½œç¬¦() é‡è½½æ“ä½œç¬¦ ()ï¼Œä½¿å¾—èƒ½å¤Ÿå¯¹è±¡èƒ½å¤Ÿåƒå‡½æ•°ä¸€æ ·è°ƒç”¨ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdlib&gt;#ifndef Matrix_H#define Matrix_Hclass Exchange&#123; public: void operator()(int&amp;, int&amp;);&#125;;#endifvoid Exchange:: operator()(int &amp;i,int &amp;j)&#123; int t = i; i = j; j = t;&#125; using namespace std;int main()&#123; Exchange swap; int i = 20; int j = 30; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; swap(i, j); cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(äºŒ)--ä¸€é“å¾ˆå…¨é¢çš„é‡è½½é¢˜ç›®","slug":"ç¨‹è®¾/é‡è½½è¿ç®—ç¬¦","date":"2022-03-08T05:54:37.232Z","updated":"2022-03-23T11:38:17.397Z","comments":true,"path":"2022/03/08/ç¨‹è®¾/é‡è½½è¿ç®—ç¬¦/","link":"","permalink":"http://example.com/2022/03/08/%E7%A8%8B%E8%AE%BE/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"è®°å½•ä¸€é“åˆå­¦å¾ˆå¤´ç–¼çš„é¢˜ é¢˜ç›®æ‰€ç»™ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void g()&#123; Int a=0; Int b(1); Int c(2.5); Int d = 99.5; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; b.getI() &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; d += 1; d += 1.5; cout &lt;&lt; c+d &lt;&lt; endl; cout &lt;&lt; 1+c &lt;&lt; endl; cout &lt;&lt; c+1 &lt;&lt; endl; cout &lt;&lt; 1.5+c &lt;&lt; endl; cout &lt;&lt; c+1.5 &lt;&lt; endl; cout &lt;&lt; a + b + c + d &lt;&lt; endl; d -= 1; d -= 1.5; cout &lt;&lt; c-d &lt;&lt; endl; cout &lt;&lt; 1-c &lt;&lt; endl; cout &lt;&lt; c-1 &lt;&lt; endl; cout &lt;&lt; 1.5-c &lt;&lt; endl; cout &lt;&lt; c-1.5 &lt;&lt; endl; d *= 1; d *= 1.5; cout &lt;&lt; c*d &lt;&lt; endl; cout &lt;&lt; 9*c &lt;&lt; endl; cout &lt;&lt; c*9 &lt;&lt; endl; cout &lt;&lt; 19.4*c &lt;&lt; endl; cout &lt;&lt; c*19.4 &lt;&lt; endl; d /= 2; d /= 2.5; cout &lt;&lt; d/c &lt;&lt; endl; cout &lt;&lt; 2/c &lt;&lt; endl; cout &lt;&lt; c/2 &lt;&lt; endl; cout &lt;&lt; 2.5/c &lt;&lt; endl; cout &lt;&lt; c/2.5 &lt;&lt; endl; cout &lt;&lt; b%c &lt;&lt; endl; cout &lt;&lt; 5%c &lt;&lt; endl; cout &lt;&lt; c%2 &lt;&lt; endl; cout &lt;&lt; c++ &lt;&lt; endl; cout &lt;&lt; ++c &lt;&lt; endl; cout &lt;&lt; c-- &lt;&lt; endl; cout &lt;&lt; --c &lt;&lt; endl; cout &lt;&lt; -c &lt;&lt; endl; int c1 = c; cout &lt;&lt; c1 &lt;&lt; endl; c1 = c; cout &lt;&lt; c1 &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl;&#125; ä»»å°ç‹—çš„ä»£ç (:) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;class Int&#123;private: int i;public: int getI() const&#123; return i; &#125; Int(const int ii):i(ii)&#123;&#125; Int(const Int&amp; ii):i(ii.getI())&#123;&#125; Int operator+=(const double ii)&#123; i +=ii; return *this; &#125; Int operator-=(const double ii)&#123; i -=ii; return *this; &#125; Int operator*=(const double ii)&#123; i *=ii; return *this; &#125; Int operator/=(const double ii)&#123; i /=ii; return *this; &#125; operator int()&#123; return (int) i; &#125; int operator+(const int ii)&#123; return i + ii; &#125; int operator+(const Int ii)&#123; return i + ii.getI(); &#125; double operator+(const double ii)&#123; return double(i) + ii; &#125; int operator-(const int ii)&#123; return i - ii; &#125; int operator-(const Int ii)&#123; return i - ii.getI(); &#125; double operator-(const double ii)&#123; return double(i) - ii; &#125; int operator*(const int ii)&#123; return i * ii; &#125; int operator*(const Int ii)&#123; return i * ii.getI(); &#125; double operator*(const double ii)&#123; return double(i) * ii; &#125; int operator/(const int ii)&#123; return i / ii; &#125; int operator/(const Int ii)&#123; return i / ii.getI(); &#125; double operator/(const double ii)&#123; return double(i) / ii; &#125; int operator%(const int ii)&#123; return i % ii; &#125; int operator%(const Int ii)&#123; return i % ii.getI(); &#125; int operator++()&#123; i++; return i; &#125; int operator++(int)&#123; i++; return i - 1; &#125; int operator--()&#123; i--; return i; &#125; int operator--(int)&#123; i--; return i + 1; &#125; friend ostream&amp; operator&lt;&lt;( ostream&amp; output, const Int &amp; number)&#123; output &lt;&lt; number.getI(); return output; &#125; friend istream&amp; operator&gt;&gt;( istream&amp; input,Int &amp; number)&#123; input &gt;&gt; number.i; return input; &#125; friend int operator+(const int ii, const Int&amp; num )&#123; return ii + num.getI(); &#125; friend double operator+(const double ii, const Int&amp; num )&#123; return ii + (double)num.getI(); &#125; friend int operator-(const int ii, const Int&amp; num )&#123; return ii -num.getI(); &#125; friend double operator-(const double ii, const Int&amp; num )&#123; return ii - (double)num.getI(); &#125; friend int operator*(const int ii, const Int&amp; num )&#123; return ii * num.getI(); &#125; friend double operator*(const double ii, const Int&amp; num )&#123; return ii * (double)num.getI(); &#125; friend int operator/(const int ii, const Int&amp; num )&#123; return ii / num.getI(); &#125; friend double operator/(const double ii, const Int&amp; num )&#123; return ii / (double)num.getI(); &#125; friend int operator%(const int ii, const Int&amp; num )&#123; return ii % num.getI(); &#125;&#125;; å‚è€ƒç­”æ¡ˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118 #include &lt;iostream&gt;using namespace std;class Int&#123; int i;public: int getI() &#123; return i; &#125; //constructor Int(int a):i(a)&#123;&#125;; Int(double a)&#123;i = a;&#125;; //type transform operator int() &#123; return i; &#125; //ostream &amp;&amp; istream friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Int&amp; a) &#123; out &lt;&lt; a.i; return out; &#125; friend istream&amp; operator&gt;&gt;(istream&amp; in, Int&amp; a) &#123; in &gt;&gt; a.i; return in; &#125; //operator += Int operator +=(int a) &#123; this-&gt;i += a; return *this; &#125; Int operator +=(double a) &#123; this-&gt;i += a; return *this; &#125; //operator -= Int operator -=(int a) &#123; this-&gt;i -= a; return *this; &#125; Int operator -=(double a) &#123; this-&gt;i -= a; return *this; &#125; //operator *= Int operator *=(int a) &#123; this-&gt;i *= a; return *this; &#125; Int operator *=(double a) &#123; this-&gt;i *= a; return *this; &#125; //operator / Int operator /=(int a) &#123; this-&gt;i /= a; return *this; &#125; Int operator /=(double a) &#123; this-&gt;i /= a; return *this; &#125; //operator ++ Int&amp; operator ++() &#123; ++this-&gt;i; return *this; &#125; Int operator ++(int a) &#123; Int temp = *this; ++this-&gt;i; return temp; &#125; //operator -- Int&amp; operator --() &#123; --this-&gt;i; return *this; &#125; Int operator --(int a) &#123; Int temp = *this; --this-&gt;i; return temp; &#125; //operator = Int operator =(int a) &#123; this-&gt;i = a; return *this; &#125; Int operator =(double a) &#123; this-&gt;i = a; return *this; &#125; //add any member function needed here&#125;; çŸ¥è¯†ç‚¹ ç¬¬ä¸€ åŠ å‡ä¹˜é™¤é‡è½½è¿ç®—ç¬¦çš„åŸºæœ¬æ“ä½œ ç¬¬äºŒ äºŒå…ƒè¿ç®—ç¬¦æ¶‰åŠé¡ºåºæ—¶éœ€è¦ä½¿ç”¨å‹å…ƒå‡½æ•° 123friend double operator-(const double ii, const Int&amp; num )&#123; return ii - (double)num.getI();&#125; ç¬¬ä¸‰ ä»€ä¹ˆæ—¶å€™return thisæŒ‡é’ˆ +=,-=è¿™ç§çš„æ—¶å€™return thisæŒ‡é’ˆä¼šæ¯”è¾ƒæ–¹ä¾¿ é‡è½½&lt;&gt; 1234friend ostream&amp; operator&lt;&lt;( ostream&amp; output, const Int &amp; number)&#123;output &lt;&lt; number.getI();return output;&#125; è‡ªå¢è¿ç®—å’Œè‡ªå‡è¿ç®— é€’å¢å’Œé€’å‡åˆ†ä¸ºå‰ç½®å’Œåç½®æƒ…å†µï¼Œa = ++b;(å‰ç½®)ï¼Œ a = b++;(åç½®)ã€‚å› ä¸ºç¬¦å·ä¸€æ ·ï¼Œæ‰€ä»¥ç»™åç½®ç‰ˆæœ¬åŠ ä¸€ä¸ªint 1234567891011ca operator++()&#123; pos++; return *this;&#125;//åç½®é€’å¢å°±æ˜¯å¢åŠ å½“å‰å¯¹è±¡çš„posçš„å€¼ï¼Œå¹¶ä¸”è¿”å›å¢åŠ posä¹‹å‰çš„è¯¥å¯¹è±¡ca operator++(int)&#123; ca ret = *this; ++*this; //è¿™ä¸ªä¼šè°ƒç”¨ä¸Šé¢çš„å‡½æ•°ï¼Œå…¶å®è¿™é‡Œå¯ä»¥æ¢æˆpos++; return ret;&#125; ++ åœ¨å‰é¢å«åšå‰è‡ªå¢ï¼ˆä¾‹å¦‚ ++aï¼‰ã€‚å‰è‡ªå¢å…ˆè¿›è¡Œè‡ªå¢è¿ç®—ï¼Œå†è¿›è¡Œå…¶ä»–æ“ä½œã€‚ ++ åœ¨åé¢å«åšåè‡ªå¢ï¼ˆä¾‹å¦‚ a++ï¼‰ã€‚åè‡ªå¢å…ˆè¿›è¡Œå…¶ä»–æ“ä½œï¼Œå†è¿›è¡Œè‡ªå¢è¿ç®—ã€‚ è½¬æ¢å‡½æ•° åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/liyazhen2011/article/details/86349255 è®¾è®¡ä¸€ä¸ªç±»Fractionè¡¨ç¤ºåˆ†æ•°ï¼ŒåŒ…å«åˆ†å­å’Œåˆ†æ¯ã€‚æˆ‘ä»¬å¸Œæœ›å®ƒèƒ½è‡ªåŠ¨è½¬æ¢ä¸ºdoubleç±»å‹ï¼Œå¹¶å‚ä¸è¿ç®—ã€‚ 12345678910111213141516171819202122232425class Fraction&#123;public: Fraction(int numerator, int denominator = 1) :m_numerator(numerator), m_denominator(denominator) &#123; &#125; //è½¬æ¢å‡½æ•° operator double() const &#123; return (double)m_numerator / m_denominator; &#125; private: int m_numerator; //åˆ†å­ int m_denominator; //åˆ†æ¯&#125;; int main()&#123; Fraction f(3,5); double sum = 4 + f; std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl; //sum = 4.6 return 0;&#125; 12//æµ‹è¯•ä»£ç double sum = 4 + f; é¦–å…ˆï¼Œå®ƒä¼šå¯»æ‰¾+æ“ä½œç¬¦æ˜¯å¦æœ‰é‡è½½äº†å‚æ•°ä¸ºdoubleå’ŒFractionçš„å‡½æ•°ã€‚å¾ˆæ˜æ˜¾ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ä¸ºåˆšåˆšæ–°å»ºçš„ç±»Fractioné‡è½½+æ“ä½œç¬¦ï¼Œç¼–è¯‘å™¨çš„è¯¥æ¬¡å°è¯•ä»¥å¤±è´¥å‘Šç»ˆã€‚ æ¥ç€ï¼Œä¸è½»è¨€æ”¾å¼ƒçš„ç¼–è¯‘å™¨å‘ç°æ“ä½œç¬¦+å¯ä»¥æ¥æ”¶ä¸¤ä¸ªdoubleç±»å‹çš„å‚æ•°ï¼Œé‚£ä¹ˆæ˜¯å¦å¯ä»¥å°†Fractionè½¬æ¢ä¸ºdoubleï¼Œä»è€Œè°ƒç”¨è¯¥ç‰ˆæœ¬çš„å‡½æ•°å‘¢ï¼Ÿè¿™æ¬¡ç¼–è¯‘å™¨æˆåŠŸäº†ï¼Œå› ä¸ºæˆ‘ä»¬åˆšåˆšå®ç°äº†è½¬æ¢ä¸ºdoubleçš„å‡½æ•°ã€‚ æœ€ç»ˆï¼Œç¼–è¯‘å™¨æˆåŠŸå®ç°äº†æ±‚å’Œæ“ä½œï¼Œè¾“å‡ºäº†ç»“æœ4.6ã€‚ **å¯ä»¥å‘ç° å‚è€ƒç­”æ¡ˆä¸­,å¹¶æ²¡æœ‰é‡è½½+-*/,å› ä¸ºé€šè¿‡è½¬æ¢å‡½æ•°,ä¹Ÿèƒ½å®ç°æƒ³è¦çš„è¾“å‡º** æˆ‘è‡ªå·±çš„ç–‘æƒ‘ ä¸ºä»€ä¹ˆä»»å°ç‹—çš„ä»£ç æ²¡æœ‰é‡è½½=å·,ç¼–è¯‘å™¨ä¹Ÿä¸æŠ¥é”™ å‚è€ƒç­”æ¡ˆä¸­é‡è½½äº†=å· 1Int a=0; è¿™ä¸ªæ˜¯æ€ä¹ˆå®Œæˆèµ‹å€¼çš„å‘¢? åŸæ¥è¿™ä¸ªæ˜¯éšå¼ç±»å‹è½¬æ¢å‡½æ•°.å¦‚æœåœ¨æ„é€ å‡½æ•°ç§ä½¿ç”¨äº†explictå…³é”®è¯,è¿™ç§éšå¼ç±»å‹è½¬æ¢å°±ä¼šæŠ¥é”™ 2022.3.23è¡¥å…… å­¦äº†ä¸€äº›çŸ¥è¯†ä¹‹åæˆ‘å°±æ‡‚äº†,è¿™ä¸ªç­‰å·ä¼šè‡ªåŠ¨è°ƒç”¨æ„é€ å‡½æ•°,å‰ææ˜¯åœ¨å£°æ˜å˜é‡çš„æ—¶å€™åˆå§‹åŒ–ä¼šè°ƒç”¨,è€Œä¸æ˜¯è°ƒç”¨é‡è½½ç­‰å·çš„å‡½æ•°. è€Œä¸”c++ä¼šæœ‰ä¸€ä¸ªéšå¼ç±»å‹è½¬æ¢ 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class Point &#123;public: int x, y; Point(int x = 0, int y = 0) : x(x), y(y) &#123;&#125;&#125;;void displayPoint(const Point&amp; p) &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;int main()&#123; displayPoint(1); Point p = 1;&#125; æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå†ç®€å•ä¸è¿‡çš„Pointç±», å®ƒçš„æ„é€ å‡½æ•°ä½¿ç”¨äº†é»˜è®¤å‚æ•°. è¿™æ—¶ä¸»å‡½æ•°é‡Œçš„ä¸¤å¥è¯éƒ½ä¼šè§¦å‘è¯¥æ„é€ å‡½æ•°çš„éšå¼è°ƒç”¨. (å¦‚æœæ„é€ å‡½æ•°ä¸ä½¿ç”¨é»˜è®¤å‚æ•°, ä¼šåœ¨ç¼–è¯‘æ—¶æŠ¥é”™) æ˜¾ç„¶, å‡½æ•°displayPointéœ€è¦çš„æ˜¯Pointç±»å‹çš„å‚æ•°, è€Œæˆ‘ä»¬ä¼ å…¥çš„æ˜¯ä¸€ä¸ªint, è¿™ä¸ªç¨‹åºå´èƒ½æˆåŠŸè¿è¡Œ, å°±æ˜¯å› ä¸ºè¿™éšå¼è°ƒç”¨. å¦å¤–è¯´ä¸€å¥, åœ¨å¯¹è±¡åˆšåˆšå®šä¹‰æ—¶, å³ä½¿ä½ ä½¿ç”¨çš„æ˜¯èµ‹å€¼æ“ä½œç¬¦=, ä¹Ÿæ˜¯ä¼šè°ƒç”¨æ„é€ å‡½æ•°, è€Œä¸æ˜¯é‡è½½çš„operator=è¿ç®—ç¬¦. è¿™æ ·æ‚„æ‚„å‘ç”Ÿçš„äº‹æƒ…, æœ‰æ—¶å¯ä»¥å¸¦æ¥ä¾¿åˆ©, è€Œæœ‰æ—¶å´ä¼šå¸¦æ¥æ„æƒ³ä¸åˆ°çš„åæœ. explicitå…³é”®å­—ç”¨æ¥é¿å…è¿™æ ·çš„æƒ…å†µå‘ç”Ÿ. explicitå…³é”®å­—","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¨‹è®¾è®°å½•(ä¸€)-meow","slug":"ç¨‹è®¾/meow","date":"2022-03-07T12:58:12.259Z","updated":"2022-04-12T05:59:20.743Z","comments":true,"path":"2022/03/07/ç¨‹è®¾/meow/","link":"","permalink":"http://example.com/2022/03/07/%E7%A8%8B%E8%AE%BE/meow/","excerpt":"","text":"å‡ ä¸ªæ˜“é”™ç‚¹: ç¬¬ä¸€ const int id; è¿™ä¸ªå¸¸é‡éœ€è¦ä½¿ç”¨åˆ—è¡¨æ¥åˆå§‹åŒ– ç¬¬äºŒ stringå’Œå­—ç¬¦æ•°ç»„å¦‚ä½•ç›¸äº’è½¬æ¢ 12345678910111213141516void main()&#123; //å­—ç¬¦ä¸²è½¬å­—ç¬¦æ•°ç»„ string name = &quot;å“ˆå“ˆå“ˆå“ˆ&quot;; char buf[] = &#123;0&#125;; strcpy(buf , name.c_str());//å­—ç¬¦ä¸²è½¬å­—ç¬¦æ•°ç»„ï¼Œä½¿ç”¨strcpy cout &lt;&lt; name.c_str() &lt;&lt; endl;//name.c_str()å°†å­—ç¬¦ä¸²è½¬æ¢æˆå­—ç¬¦æ•°ç»„ cout &lt;&lt; buf &lt;&lt; endl; //å­—ç¬¦æ•°ç»„è½¬å­—ç¬¦ä¸² char buf1[]= &quot;å“ˆå“ˆå“ˆå“ˆ&quot;; string name1; name1 = buf1; cout &lt;&lt; name1 &lt;&lt; endl;&#125; ç¬¬ä¸‰ 12345678910111213141516171819202122class Meow &#123;public: //constructor Meow(int id_, string name_); //copy constructor Meow(const Meow &amp;other); //desctructor ~Meow(); //return the count of cats static int getCount(); //print some infomation void print() const &#123; cout &lt;&lt; &quot;Cat &quot; &lt;&lt; id &lt;&lt; &quot;. My name is &quot; &lt;&lt; name &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125;int Meow:: getCount()&#123; return count;&#125; è™½ç„¶getcountæ˜¯é™æ€å‡½æ•°,ä½†æ˜¯åœ¨å®šä¹‰çš„æ—¶å€™ä¸èƒ½åŠ static ç¬¬å›› â€‹ char *name; è¦ä½¿ç”¨newå’Œdelete å‚è€ƒç­”æ¡ˆ 1234567891011121314151617181920212223242526#include &quot;Meow.h&quot;#include &lt;cstring&gt;Meow::Meow(int id_, string name_) : id(id_) &#123; name = new char[name_.size()+1]; strcpy(name, name_.c_str()); count++;&#125;Meow::Meow(const Meow &amp;other) : id(other.id) &#123; name = new char[strlen(other.name)+1]; strcpy(name, other.name); count++;&#125;Meow::~Meow() &#123; delete []name; name = NULL; count--;&#125;int Meow::getCount() &#123; return count;&#125;int Meow::count = 0; æºä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class Meow &#123;public: //constructor Meow(int id_, string name_); //copy constructor Meow(const Meow &amp;other); //desctructor ~Meow(); //return the count of cats static int getCount(); //print some infomation void print() const &#123; cout &lt;&lt; &quot;Cat &quot; &lt;&lt; id &lt;&lt; &quot;. My name is &quot; &lt;&lt; name &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125;private: const int id; char *name; static int count; // the count of cats&#125;;int Meow:: count=0;Meow::Meow(int id_, string name_):id(id_),name(NULL)&#123; name=new char[100]; strcpy(name , name_.c_str()); count++;&#125;Meow::Meow(const Meow &amp;other):id(other.id),name(NULL)&#123; name=new char[100]; strcpy(name,other.name); count++;&#125;int Meow:: getCount()&#123; return count;&#125;Meow::~Meow()&#123; count--; delete [] name;&#125; void printCount() &#123; cout &lt;&lt; &quot;Number of Cat: &quot; &lt;&lt; Meow::getCount() &lt;&lt; endl;&#125;int main() &#123; string name = &quot;Madara&quot;; int num; cin &gt;&gt; num; Meow cat(0, name), *p; for (int i = 1; i &lt;= num; ++i) &#123; cin &gt;&gt; name; Meow a(i, name); if (i % 2 != 0) &#123; p = new Meow(i, name); printCount(); p-&gt;print(); delete p; &#125; else &#123; Meow b(a); printCount(); b.print(); &#125; &#125; printCount(); cat.print(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ç¬¬å››ç« -Boolean Algebra and Logic Simplification  (ä¸€)","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å››ç« (ä¸€)","date":"2022-03-07T08:11:06.361Z","updated":"2022-03-13T06:10:07.096Z","comments":true,"path":"2022/03/07/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬å››ç« (ä¸€)/","link":"","permalink":"http://example.com/2022/03/07/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E4%B8%80)/","excerpt":"","text":"æ¦‚å¿µ variable: complement:the inverse of a variable Boolean addition: or Boolean multiplication: å¸ƒå°”è¿ç®—å’Œè¡¨è¾¾å¼ å¸ƒå°”åŠ æ³• æˆ–é—¨æ˜¯å¸ƒå°”åŠ æ³•çš„è¡¨ç¤ºå½¢å¼ 0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 1 å¸ƒå°”ä¹˜æ³• ä¸é—¨æ˜¯å¸ƒå°”ä¹˜æ³•çš„è¡¨ç¤ºå½¢å¼ å¸ƒå°”ä»£æ•°å®šå¾‹å’Œæ³•åˆ™ å¸ƒå°”ä»£æ•°å®šå¾‹ äº¤æ¢å¾‹ \\[ A+B=B+A \\] \\[ AB=BA \\] ç»“åˆå¾‹ \\[ A+(B+C)=(A+B)+C \\] \\[ A(BC)=(AB)C \\] åˆ†é…å¾‹ \\[ A(B+C)=AB+AC \\] åˆ†é…å¾‹çš„åº”ç”¨ å¸ƒå°”ä»£æ•°æ³•åˆ™ ä¸ç¦»æ•£æ•°å­¦ç›¸ä¼¼ ç‹„æ‘©æ ¹å®šç† ç¬¬ä¸€å®šç†: \\[ \\overline{XY}=\\bar X+\\bar Y \\] ç¬¬äºŒå®šç†: \\[ \\overline{X+Y} =\\bar X+ \\bar Y \\] å¸ƒå°”ä»£æ•°æ³•åˆ™æ€»ç»“ ä¸ç†Ÿæ‚‰çš„å…¬å¼æ¨å¯¼: \\[ A+\\bar AB=A+AB+\\bar AB=A+B \\] \\[ A\\cdot B+A\\cdot \\bar B=A(B+\\bar B)=A \\] \\[ A\\cdot B+\\bar A \\cdot C+B\\cdot C=A\\cdot B+\\bar A \\cdot C+A\\cdot B\\cdot C+\\bar A\\cdot B\\cdot C=A\\cdot B+\\bar A \\cdot C \\] é€»è¾‘ç”µè·¯çš„ç”µè·¯åˆ†æ Standard Forms of Boolean SOP and POS The sum-of-products (SOP) form A single overbar cannot extend over more than one variable; More than one variable in a term can have an overbar The product-of-sums (POS) form A single overbar cannot extend over more than one variable More than one variable in a term can have an overbar Expressions SOP \\[ AB\\bar C \\bar D+\\bar ACD +AC \\] POS \\[ (A + B)(B + C + D)(A + C) \\] ## standard SOP Form and POS Form standard SOP Form All the variables in the domain appear in each product term in the expression ç¦»æ•£æ•°å­¦ä¸­çš„ä¸»æå–èŒƒå¼(æå°é¡¹) Standard POS Form ç¦»æ•£æ•°å­¦ä¸­çš„ä¸»åˆå–èŒƒå¼(æå¤§é¡¹) image-20220313140158717 Converting standard SOP to standard POS from truth table to boolen expression","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"æ•°å­—ç”µè·¯-ä½œä¸šé‡åˆ°çš„é—®é¢˜","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°ç”µä½œä¸šé‡åˆ°çš„é—®é¢˜","date":"2022-03-06T08:11:33.547Z","updated":"2022-03-13T05:39:02.753Z","comments":true,"path":"2022/03/06/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°ç”µä½œä¸šé‡åˆ°çš„é—®é¢˜/","link":"","permalink":"http://example.com/2022/03/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E7%94%B5%E4%BD%9C%E4%B8%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"åè¿›åˆ¶å°æ•°è½¬äºŒè¿›åˆ¶ ä¸æ–­ä¹˜äºŒ,ä¸€æ—¦ç»“æœå¤§äºä¸€,é‚£ä¹ˆå°±èˆå»è¿›ä½ äºŒè¿›åˆ¶åè¿›åˆ¶é—´å°æ•°æ€ä¹ˆè½¬æ¢ è¿™ç§ä¼šæ…¢æ…¢é€¼è¿‘,ä¿ç•™5åˆ°8ä½å³å¯ 0çš„è¡¥ç å½¢å¼ +0:000000000 -0:000000000 æµ®ç‚¹æ•°å…¬å¼ å¸¦ç¬¦å·æ•°çš„å‡æ³•ä»¥è¡¥ç å½¢å¼ BCDç ç›¸åŠ  è¦æ˜¯ä¸¤ä¸ªBCDç åŠ èµ·æ¥ä¸ºä¸‰ä½æ•°,é‚£å°±ç”¨12ä½è¡¨ç¤º è®¡ç®— 5+8ï¼š è§£ï¼šå°† 5 å’Œ 8 ä»¥ 8421 BCDè¾“å…¥æœºå™¨ï¼Œåˆ™è¿ç®—å¦‚ä¸‹ï¼š 0 1 0 1 +) 1 0 0 0 1 1 0 1 ç»“æœå¤§äº 9 +) 0 1 1 0 åŠ  6 ä¿®æ­£ 1 0 0 1 1 å³13 çš„ BCDç  ç»“æœæ˜¯ 0011ï¼Œå³åè¿›åˆ¶æ•°3ï¼Œè¿˜äº§ç”Ÿäº†è¿›ä½ã€‚5+8=13ã€‚ äºŒè¿›åˆ¶è½¬æ ¼é›·ç  Parity Method (å¥‡å¶æ ¡éªŒæ³•) açš„ascIIç¼–ç æ˜¯110001,Açš„ascIIç¼–ç æ˜¯100001 açš„ç¼–ç æœ‰å¥‡æ•°ä¸ª1,æ‰€ä»¥ä»–çš„parity bit æ˜¯0, Açš„ç¼–ç æœ‰å¥‡æ•°ä¸ª1,æ‰€ä»¥ä»–çš„parity bit æ˜¯1 Evenï¼ˆå¶ï¼‰ Parity Evenï¼ˆå¶ï¼‰ Parity Odd Parity Odd Parity P BCD P BCD 0 0000 1 0000 1 0001 0 0001 1 0010 0 0010 0 0011 1 0011 1 0100 0 0100 0 0101 1 0101 0 0110 1 0110 1 0111 0 0111 1 1000 0 1000 0 1001 1 1001 Add odd parity system received the code group, 00110111, 11110000, which one is incorrect? 00110111, has 5 1s, it is odd, this code is OK. 11110000, has 4 1s, it is even, it is incorrect aå’Œcæ˜¯é”™çš„,å› ä¸ºä»–ä»¬çš„1çš„ä¸ªæ•°æ˜¯å¶æ•°ä¸ª å¾ªç¯å†—ä½™æ ¡éªŒç  ä¸¤ç§é¢˜å‹ æ¨¡-2è¿ç®—å°±æ˜¯å¼‚æˆ–è¿ç®— image-20220306190035271","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Fixed Function Logic","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸‰ç« (äºŒ)","date":"2022-03-06T03:34:54.029Z","updated":"2022-03-06T04:04:44.653Z","comments":true,"path":"2022/03/06/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸‰ç« (äºŒ)/","link":"","permalink":"http://example.com/2022/03/06/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0(%E4%BA%8C)/","excerpt":"","text":"è¿™å—å†…å®¹æ²¡å­¦æ¨¡ç”µåŸºæœ¬å•¥éƒ½ä¸æ‡‚,ä¸æ˜¯æ•°ç”µé‡ç‚¹ ttlå’Œcmos Two major fixed function logic families are TTL and CMOS. A third technology is BiCMOS, which combines the first two. Packaging for fixed function logic is shown . CMOSæ˜¯åœºæ•ˆåº”ç®¡æ„æˆï¼ˆå•ææ€§ç”µè·¯ï¼‰ï¼Œç”µå‹æ§åˆ¶å™¨ä»¶ TTLæ˜¯åŒææ™¶ä½“ç®¡æ„æˆï¼ˆåŒææ€§ç”µè·¯ï¼‰ï¼Œç”µæµæ§åˆ¶å™¨ä»¶ (ä¾æ—§ä¸æ‡‚,æ²¡å­¦æ¨¡ç”µ) CMOSé€»è¾‘ç”µå¹³èŒƒå›´å¤§ï¼ˆ 5-15Vï¼‰ï¼ŒæŠ—å¹²æ‰°æ€§å¼ºï¼Œå™ªå£°å®¹é™å¤§ï¼Œé©±åŠ¨è´Ÿè½½èƒ½åŠ›å¼º TTLï¼ˆ 5Vä»¥ä¸‹ï¼‰ï¼ŒæŠ—å¹²æ‰°æ€§å¼ºå·®ï¼Œ å™ªå£°å®¹é™å°ï¼Œé€Ÿåº¦å¿«ï¼Œä¼ è¾“å»¶è¿ŸçŸ­ï¼ŒåŠŸè€—å¤§ CMOSç”µè·¯çš„ç‰¹ç‚¹ åŠŸè€—å°ï¼š CMOSé—¨å·¥ä½œæ—¶ï¼Œ æ€»æ˜¯ä¸€ç®¡å¯¼é€šå¦ä¸€ç®¡ æˆªæ­¢ï¼Œ å› è€Œå‡ ä¹ä¸ç”±ç”µæºå¸å–ç”µæµå…¶åŠŸè€—æå°ï¼› CMOSé›†æˆç”µè·¯åŠŸè€—ä½å†…éƒ¨å‘çƒ­é‡å°ï¼Œ é›†æˆåº¦å¯ å¤§å¤§æé«˜ï¼› æŠ—å¹…å°„èƒ½åŠ›å¼ºï¼Œ MOSç®¡æ˜¯å¤šæ•°è½½æµå­å·¥ä½œï¼Œ å°„çº¿ è¾å°„å¯¹å¤šæ•°è½½æµå­æµ“åº¦å½±å“ä¸å¤§ï¼› ç”µå‹èŒƒå›´å®½ï¼š CMOSé—¨ç”µè·¯è¾“å‡ºé«˜ç”µå¹³\\(V_{OH}\\) â‰ˆ \\(V_{DD}\\),ä½ç”µå¹³\\(V_{OL}\\) â‰ˆ 0V è¾“å‡ºé©±åŠ¨ç”µæµæ¯”è¾ƒå¤§ï¼šæ‰‡å‡ºèƒ½åŠ›è¾ƒå¤§ï¼Œ ä¸€èˆ¬å¯ ä»¥å¤§äº50ï¼› åœ¨ä½¿ç”¨å’Œå­˜æ”¾æ—¶åº”æ³¨æ„é™ç”µå±è”½ï¼Œ ç„Šæ¥æ—¶ç”µçƒ™ é“åº”æ¥åœ°è‰¯å¥½","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Logic Gate","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸‰ç« (ä¸€)","date":"2022-03-05T07:45:11.254Z","updated":"2022-03-06T03:50:45.172Z","comments":true,"path":"2022/03/05/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬ä¸‰ç« (ä¸€)/","link":"","permalink":"http://example.com/2022/03/05/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%B8%89%E7%AB%A0(%E4%B8%80)/","excerpt":"","text":"æ•°ç”µè€å¸ˆå¤ªå‚¬çœ äº†,è‡ªå­¦!! Selected Key Terms Inverter(åç›¸å™¨): A logic circuit that inverts or complements its inputs Truth table(çœŸå€¼è¡¨): A table showing the inputs and corresponding output(s) of a logic circuit. Timing diagram(æ—¶åºå›¾): A diagram of waveforms showing the proper time relationship of all of the waveforms. Boolean algebra(å¸ƒå°”ä»£æ•°): The mathematics of logic circuits. AND gate (ä¸): A logic gate that produces a HIGH output only when all of its inputs are HIGH. OR gate(æˆ–): A logic gate that produces a HIGH output when one or more inputs are HIGH . NAND gate(ä¸é): A logic gate that produces a LOW output only when all of its inputs are HIGH. NOR gate(ä¸æˆ–): A logic gate that produces a LOW output when one or more inputs are HIGH Exclusive-OR gate(å¼‚æˆ–) A logic gate that produces a HIGH output only when its two inputs are at opposite levels. Exclusive-NOR gate (åŒæˆ–): A logic gate that produces a LOW output only when its two inputs are at opposite levels. The Inverter (åç›¸å™¨) Boolean expression for an inverter is \\[X = \\bar A\\]. input output a x low(0) high(1) high(1) low(0) The AND Gate Input Input Output A B X 0 0 0 0 1 0 1 0 0 1 1 1 expression:\\[X = A \\cdot B \\]or\\[ X = AB \\] OR Gate Input Input OUTPUT A B X 0 0 0 0 1 1 1 0 1 1 1 1 \\[X = A + B \\] ä¸‹é¢å‡ ç§é—¨æˆ‘ä¸»è¦åˆ—å‡ºä¸ç†Ÿæ‚‰çš„ç¬¦å·è¡¨è¾¾å’Œé—¨é•¿ä»€ä¹ˆæ ·,çœŸå€¼è¡¨å°±ä¸åˆ—äº† The NAND Gate \\[ X = \\overline {A \\cdot B} \\] \\[ X = \\overline {AB} \\] The NOR Gate \\[ X = \\overline{A + B} \\] The XOR Gate \\[ X = A \\oplus B \\] \\[ X = \\bar A B + A\\bar B \\\\ \\] The XNOR Gate \\[ X = A \\odot B \\\\ \\] \\[ X = \\bar A\\bar B + AB \\]","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"æ•°å­—ç”µè·¯-æ•°å­—ç³»ç»Ÿ\\è¿ç®—\\ç¼–ç ","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬äºŒç« ","date":"2022-02-24T13:18:07.560Z","updated":"2022-03-13T04:42:25.230Z","comments":true,"path":"2022/02/24/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯ç¬¬äºŒç« /","link":"","permalink":"http://example.com/2022/02/24/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"åè¿›åˆ¶æ•° äºŒè¿›åˆ¶æ•° åè¿›åˆ¶è½¬æ¢äºŒè¿›åˆ¶ image-20220224215626755 äºŒè¿›åˆ¶ç®—æœ¯ åŠ æ³• image-20220224215818222 ä¸åè¿›åˆ¶åˆ—ç«–å¼åŒç† å‡æ³• å€Ÿä½ ä¹˜æ³• é™¤æ³• äºŒè¿›åˆ¶çš„åç å’Œè¡¥ç  æ— ç¬¦å·äºŒè¿›åˆ¶ åç  01è½¬æ¢ è¡¥ç  åç åŠ ä¸€ å¦ä¸€ç§æ–¹æ³•: æ”¹å˜æœ€ä½æœ‰æ•ˆ1å·¦è¾¹çš„å…¨éƒ¨ä½ å¸¦ç¬¦å·æ•° æœ€å·¦è¾¹ä¸ºç¬¦å·ä½,0ä»£è¡¨æ­£æ•°,1ä»£è¡¨è´Ÿæ•° å¸¦ç¬¦å·æ•°çš„åç  å¯¹äºæ­£æ•° æ­£æ•°çš„åç æ˜¯å…¶æœ¬èº« å³åç ç­‰äºè¡¥ç ç­‰äºåŸç  å¯¹äºè´Ÿæ•° è´Ÿæ•°çš„åç æ˜¯åœ¨å…¶åŸç çš„åŸºç¡€ä¸Š, ç¬¦å·ä½ä¸å˜ï¼Œå…¶ä½™å„ä¸ªä½å–å. è´Ÿæ•°çš„åç ä¹Ÿå¯ä»¥è¡¨ç¤ºä¸ºå¯¹åº”æ­£æ•°çš„å„ä½å–å; æ¯”å¦‚-1çš„åç ç­‰äº+1çš„åŸç çš„å„ä½å–å å¸¦ç¬¦å·æ•°çš„è¡¥ç  æ­£æ•°çš„è¡¥ç å°±æ˜¯å…¶æœ¬èº« è´Ÿæ•°çš„è¡¥ç æ˜¯åœ¨å…¶åŸç çš„åŸºç¡€ä¸Š, ç¬¦å·ä½ä¸å˜, å…¶ä½™å„ä½å–å, æœ€å+1. (å³åœ¨åç çš„åŸºç¡€ä¸Š+1) å¸¦ç¬¦å·æ•°çš„åè¿›åˆ¶ åŸç  åç  è¡¥ç  å¸¦ç¬¦å·æ•´æ•°çš„è¡¨ç¤ºèŒƒå›´ äºŒè¿›åˆ¶æ•°çš„å–å€¼èŒƒå›´å–å†³äºæ•°çš„ä½æ•°(n) å¯¹äºè¡¥ç å¸¦ç¬¦å·æ•°,nä½æ•°çš„æ•°å€¼èŒƒå›´æ˜¯\\(-2^{n-1}\\)åˆ°\\(+(2^{n-1}-1)\\) ä¾‹å¦‚:8ä½æ•°å¯ä»¥è¡¨ç¤º-128åˆ°+127 æµ®ç‚¹æ•° å•ç²¾åº¦(32)(64)(80) ä»…ä»…è®¨è®ºå•ç²¾åº¦ \\[ æ•°=(-1)^{S}(1+F)(2^{E-127}) \\] å¸¦ç¬¦å·æ•°çš„ç®—æœ¯è¿ç®— åŠ æ³• å½“ä¸¤ä¸ªæ•°ç¬¦å·ç›¸åŒæ—¶,æœ‰å¯èƒ½å‘ç”Ÿæº¢å‡º è´Ÿæ•°éƒ½æ˜¯ç”¨è¡¥ç çš„å½¢å¼è¡¨ç¤ºçš„ æº¢å‡ºæ¡ä»¶ å‡æ³• æ­£äºŒè¿›åˆ¶æˆ–è€…è´ŸäºŒè¿›åˆ¶æ•°çš„ç¬¦å·é€šè¿‡æ±‚æ­¤æ•°çš„è¡¥ç è€Œæ”¹å˜. ä¹˜æ³• è®¡ç®—æ­¥éª¤ ç¡®å®šè¢«ä¹˜æ•°å’Œä¹˜æ•°çš„ç¬¦å·æ˜¯ç›¸åŒè¿˜æ˜¯ç›¸å¼‚çš„ å°†æ‰€æœ‰çš„è´Ÿæ•°å˜ä¸ºåŸç å½¢å¼ ç±»æ¯”åè¿›åˆ¶ä¹˜æ³•,åˆ—ç«–å¼ å¦‚æœæ­¥éª¤ä¸€ç¡®å®šçš„ç¬¦å·æ˜¯è´Ÿçš„,é‚£å°±å¯¹ç§¯å–è¡¥ç ,å¦‚æœæ˜¯æ­£çš„,é‚£å°±ä¿æŒåŸç  è¡¥å……ç¬¦å·ä½ ä¾‹å­ é™¤æ³• æ­¥éª¤ åå…­è¿›åˆ¶æ•° äºŒ-åè¿›åˆ¶ç¼–ç (BCD) æ•°å­—ç¼–ç  æ ¼é›·ç  ç‰¹å¾ï¼šä¸¤ä¸ªç›¸é‚»ç å­—ä¹‹é—´åªæœ‰ä¸€ä½ä¸åŒ å¯ä»¥å‡å°‘å‡ºé”™æ¦‚ç‡ Binary-to-Gray Code Conversion ç¬¬ä¸€è¡Œæ˜¯äºŒè¿›åˆ¶ç¬¬äºŒè¡Œæ˜¯æ ¼é›·ç  æœ€é«˜æœ‰æ•ˆä½ç›¸åŒ,ä»å·¦åˆ°å³,é€é¡¹å¼‚æˆ– æ¯”å¦‚è¯´æ ¼é›·ç çš„ç¬¬äºŒä½æ˜¯äºŒè¿›åˆ¶çš„ç¬¬ä¸€ä½å’Œç¬¬äºŒä½å¼‚æˆ–äº§ç”Ÿçš„æ•° Gray Code-to-Binary Conversion äºŒè¿›åˆ¶æœ€é«˜ä½å’Œæ ¼é›·ç æœ€é«˜ä½ç›¸åŒï¼Œéƒ½æ˜¯ 1ï¼Œæ¬¡é«˜ä½ä¸ºäºŒè¿›åˆ¶çš„é«˜ä½å’Œæ¬¡é«˜ä½æ ¼é›·ç ç›¸å¼‚æˆ–å¾—åˆ°ï¼Œå³ bit2 ä¸º 0=1^1ã€‚ ASCIIç  é”™è¯¯æ£€æµ‹ç  Parity Method (å¥‡å¶æ ¡éªŒæ³•) açš„ascIIç¼–ç æ˜¯110001,Açš„ascIIç¼–ç æ˜¯100001 açš„ç¼–ç æœ‰å¥‡æ•°ä¸ª1,æ‰€ä»¥ä»–çš„parity bit æ˜¯0, Açš„ç¼–ç æœ‰å¥‡æ•°ä¸ª1,æ‰€ä»¥ä»–çš„parity bit æ˜¯1 CRC (cyc;ic redundancy check)å¾ªç¯å†—ä½™æ ¡éªŒ ç”¨äºæ£€éªŒå¤§è§„æ¨¡çš„æ•°æ® åç»­è¡¥å……: æœ€é«˜æœ‰æ•ˆä½ï¼Œè‹±æ–‡å…¨ç§°æ˜¯ï¼šthe Most Significant Bitï¼Œç¼©å†™ä¸ºï¼šmsbï¼Œæ˜¯æŒ‡ä¸€ä¸ªnä½äºŒè¿›åˆ¶æ•°å­—ä¸­çš„n-1ä½ï¼Œå…·æœ‰æœ€é«˜çš„æƒå€¼2^(n-1)ã€‚ä¸ä¹‹ç›¸åçš„ç§°ä¹‹ä¸ºæœ€ä½æœ‰æ•ˆä½ã€‚åœ¨å¤§ç«¯åºä¸­ï¼Œmsbå³æŒ‡æœ€å·¦ç«¯çš„ä½ã€‚","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Lumericalè„šæœ¬è¯­è¨€å­¦ä¹ ( å››)-Simulation region","slug":"Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 4","date":"2022-02-23T12:27:01.187Z","updated":"2022-02-23T14:12:55.548Z","comments":true,"path":"2022/02/23/Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 4/","link":"","permalink":"http://example.com/2022/02/23/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A04/","excerpt":"","text":"å‚è€ƒäº†csdnçš„æ–‡ç« ,å±äºè½¬è½½ è‡ªåŠ¨ç²¾åº¦ 12345678910111213addfdtd;set(&quot;dimension&quot;,2);#ä¸‰ç»´ä»¿çœŸåŒºåŸŸ(é‡ç‚¹)set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z min&quot;,-10*nm);set(&quot;z max&quot;,2*um);set(&quot;x span&quot;,0.2*um);set(&quot;y span&quot;,0.4*um);set(&quot;x min bc&quot;,&quot;periodic&quot;);#è®¾ç½®xæ–¹å‘å‘¨æœŸè¾¹ç•Œæ¡ä»¶(é‡ç‚¹)set(&quot;y min bc&quot;,&quot;periodic&quot;);#è®¾ç½®yæ–¹å‘å‘¨æœŸè¾¹ç•Œæ¡ä»¶set(&quot;Mesh type&quot;,&quot;auto non-uniform&quot;);#ä»¿çœŸç½‘æ ¼ä¸ºè‡ªåŠ¨ç²¾åº¦set(&quot;Mesh accuracy&quot;,3);#é«˜ç²¾åº¦ set(â€œdimensionâ€,2)ï¼šä»¿çœŸç©ºé—´ç»´åº¦ï¼Œâ€œdimensionâ€å‚æ•°ä¸€èˆ¬æœ‰ä¸¤ä¸ªå€¼ï¼š1å’Œ2ï¼Œå…¶ä¸­1è¡¨ç¤ºä»¿çœŸçš„åŒºåŸŸæ˜¯äºŒç»´åŒºåŸŸï¼Œ2è¡¨ç¤ºä»¿çœŸä¸‰ç»´åŒºåŸŸã€‚è¿™é‡Œè®¾ç½®ä¸º2ï¼Œè¡¨ç¤ºæˆ‘ä»¬ä»¿çœŸçš„æ˜¯ä¸€ä¸ªä¸‰ç»´åŒºåŸŸ set(â€œx min bcâ€,â€œperiodicâ€)ï¼šè¾¹ç•Œæ¡ä»¶ï¼Œæ ¹æ®å®é™…çš„ä»¿çœŸåŒºåŸŸï¼ˆç»´åº¦ï¼‰è®¾ç½®ï¼Œæœ‰\"x max bc\"ï¼Œâ€œx min bcâ€ï¼Œâ€œy max bcâ€ç­‰å¤šä¸ªè¾¹ç•Œï¼Œå¯é€‰ç”¨çš„è¾¹ç•Œæ¡ä»¶è§ä¸‹è¡¨ï¼š è¾¹ç•Œæ¡ä»¶ è¯´æ˜ PML(100% absorption, 0% reflection) å®Œç¾åŒ¹é…å±‚ Metal(0% absorption, 100% reflection) é‡‘å±è¾¹ç•Œ Periodic å‘¨æœŸè¾¹ç•Œ Symmetric å¯¹ç§°è¾¹ç•Œ Anti-Symmetric éå¯¹ç§°è¾¹ç•Œ Bloch é€‚åˆæ–œå…¥å°„ PMC ç†æƒ³ç£å¯¼ä½“ set(â€œMesh typeâ€,â€œauto non-uniformâ€)ï¼šç½‘æ ¼ç±»å‹ï¼Œæœ‰â€œauto non-uniformâ€ã€â€œcustom non-uniformâ€ã€\"uniform\"ä¸‰ç§å¯é€‰ï¼Œä¸€èˆ¬é»˜è®¤ä¸ºâ€œauto non-uniformâ€ï¼Œè‹¥ä¸éœ€æ›´æ”¹ç½‘æ ¼ç±»å‹ï¼Œæœ¬æ¡ä»£ç å¯ä¸å†™ã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯é»˜è®¤çš„è‡ªåŠ¨ç²¾åº¦ set(â€œMesh accuracyâ€,3)ï¼šè‡ªåŠ¨ç½‘æ ¼ç²¾åº¦ï¼Œåœ¨â€œauto non-uniformâ€æ¨¡å¼ä¸‹è®¾ç½®ã€‚æœ‰1~8ä¸€å…±8ä¸ªç­‰çº§ï¼Œç²¾åº¦éšç€æ•°å­—çš„å¢å¤§è€Œæé«˜ï¼Œä¸€èˆ¬é»˜è®¤ä¸º2ï¼Œä¸å»ºè®®å¤ªé«˜ï¼Œå®¹æ˜“ç»™CPUå¸¦æ¥å¾ˆå¤§çš„è´Ÿæ‹…ã€‚è¿™é‡Œè®¾ç½®ä¸º3ï¼Œå±äºé«˜ç²¾åº¦ä»¿çœŸ.","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"æ•°å­—ç”µè·¯-introduction concept","slug":"æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯(ä¸€)","date":"2022-02-21T08:18:33.708Z","updated":"2022-02-21T10:08:15.670Z","comments":true,"path":"2022/02/21/æ•°å­—ç”µè·¯æ±‡æ€»/æ•°å­—ç”µè·¯(ä¸€)/","link":"","permalink":"http://example.com/2022/02/21/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E6%B1%87%E6%80%BB/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF(%E4%B8%80)/","excerpt":"","text":"Key terms: Analog æ¨¡æ‹Ÿ Digital æ•°å­— Inverter: é€†å˜å™¨? Pulse: è„‰å†² Duty cycle: å ç©ºæ¯” Integrated circuit(IC) é›†æˆç”µè·¯ Fixed-function logic å›ºå®šåŠŸèƒ½é€»è¾‘ Timing diagram æ—¶åºå›¾ Troubleshooting æ•…éšœ æ’é™¤ Serial ä¸²è¡Œ Parallelå¹¶è¡Œ SPLD ( Simple Programmable Logic Device) ç®€å•å¯ç¼–ç¨‹é€»è¾‘å™¨ä»¶ CPLD (Complex Programming logic device) å¤æ‚å¯ç¼–ç¨‹é€»è¾‘å™¨ä»¶ FPGA ï¼ˆField-Programmable Gate Arrayï¼‰ ç°åœºå¯ç¼–ç¨‹é€»è¾‘é—¨é˜µåˆ— Compiler ç¼–è¯‘å™¨ 1.1 digital and analogy quantities definition æ¨¡æ‹Ÿé‡å…·æœ‰è¿ç»­çš„æ•°å€¼ï¼Œæ•°å­—é‡å…·æœ‰ç¦»æ•£çš„æ•°å€¼ã€‚ the digital advantage(æ•°å­—é‡ä¼˜ç‚¹) æ•°å­—é‡çš„ä¼˜ç‚¹ åœ¨ç”µå­¦åº”ç”¨æ–¹é¢ï¼Œæ•°å­—é‡è¡¨ç¤ºæ³•å’Œæ¨¡æ‹Ÿé‡è¡¨ç¤ºæ³•ç›¸æ¯”æœ‰ä¸€å®šçš„ä¼˜åŠ¿ã€‚ æ•°å­—æ•°æ®å’Œæ¨¡æ‹Ÿæ•°æ®ç›¸æ¯”ï¼Œå‰è€…åœ¨å¤„ç†å’Œä¼ è¾“æ–¹é¢æ›´æœ‰æ•ˆã€æ›´å¯é ã€‚ æ•°å­—æ•°æ®åœ¨éœ€è¦ä¿å­˜æ—¶ï¼Œæ›´æ˜¾ç¤ºäº†å®ƒçš„ä¼˜è¶Šæ€§ã€‚ä¾‹å¦‚ï¼Œè½¬æ¢æˆæ•°å­—å½¢å¼çš„éŸ³ä¹ï¼Œè¦æ¯”ç›¸å¯¹åº”çš„æ¨¡æ‹Ÿå½¢å¼æ›´ç®€æ´ï¼Œå¤åˆ¶æ—¶æ›´ç²¾ç¡®ã€æ›´æ¸…æ™°ã€‚å™ªå£°ï¼ˆä¸éœ€è¦çš„ç”µå‹æ³¢åŠ¨ï¼‰å‡ ä¹ä¸ä¼šå½±å“æ•°å­—æ•°æ®ï¼Œä½†ä¼šå½±å“æ¨¡æ‹Ÿä¿¡å·ã€‚ 1.2 binary digits,logic levels,and digital waveforms(äºŒè¿›åˆ¶æ•°ã€é€»è¾‘ç”µå¹³å’Œæ•°å­—æ³¢å½¢) 1.2.1 binary digits positive logic (æ­£é€»è¾‘): HIGH=1,LOW=0 1.2.2 logic levels 1.2.3 digital waveforms ç†æƒ³è„‰å†² The Pulse A pulse has two edges: a leading edge that occurs first at time to and a trailing edge that occurs last at time éç†æƒ³è„‰å†² \\[ f=\\frac{1}{T}\\\\ duty cycle(å ç©ºæ¯”)=(\\frac{t_w}{T})\\times100\\% \\] 1.2.4 A Digital Waveform Carries Binary Information(æ•°å­—æ³¢å½¢æºå¸¦äºŒè¿›åˆ¶ä¿¡æ¯) ä¾‹å­ timing diagram 1.2.5 data transfer(æ•°æ®è½¬æ¢) ä¸¤ç§æ–¹å¼:serial and parallel(ä¸²è¡Œå’Œå¹¶è¡Œ) 1.3 basic logic operations(åŸºæœ¬é€»è¾‘æ“ä½œ) image-20220221175827593 image-20220221175845207","categories":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"}]},{"title":"Lumericalè„šæœ¬è¯­è¨€å­¦ä¹ (ä¸‰)-ç»“æ„æ­å»º","slug":"Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 3","date":"2022-02-20T08:13:58.028Z","updated":"2022-02-20T09:03:43.612Z","comments":true,"path":"2022/02/20/Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 3/","link":"","permalink":"http://example.com/2022/02/20/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A03/","excerpt":"","text":"å‚è€ƒæ–‡æ¡£(61æ¡æ¶ˆæ¯) FDTDå¿«é€Ÿå…¥é—¨ä¹‹Lumericalè„šæœ¬è¯­è¨€Pickupï¼ˆä¸‰ï¼‰ç»“æ„(Structure)æ­å»º_ArcSightçš„åšå®¢-CSDNåšå®¢ FDTD solutionä¸­çš„ä»¿çœŸæ¨¡å‹åŒ…å«ä¸¤ä¸ªæ ¸å¿ƒéƒ¨åˆ†ï¼šææ–™(material)å’Œå‡ ä½•ç»“æ„(structure)ã€‚é€šå¸¸ç”¨åŒ…å«å¸æ”¶å‚æ•°çš„ææ–™çš„å¤æŠ˜å°„ç‡æ§åˆ¶materialå±æ€§ï¼Œè€Œç”¨3Dæ¨¡å‹å‚æ•°æ§åˆ¶structureå±æ€§ã€‚ä¸‹é¢ä»‹ç»å‡ ç§å¸¸ç”¨çš„structureã€‚ ä¸€ã€ï¼ˆé•¿æ–¹ä½“ï¼‰çŸ©å½¢ï¼ˆRectangleï¼‰ 12345678910111213addrect;set(&quot;name&quot;,&quot;rect&quot;);#åç§° set(&quot;material&quot;,&quot;SiO2 (Glass) - Palik&quot;);#ææ–™set(&quot;render type&quot;,&quot;wireframe&quot;); # æ¸²æŸ“æ–¹å¼ï¼šçº¿æ¡†ï¼Œå‡å°æ˜¾å¡å‹åŠ›set(&quot;x&quot;,0);#è®¾ç½®xä¸­å¿ƒç‚¹åæ ‡ set(&quot;y&quot;,0);#è®¾ç½®yä¸­å¿ƒç‚¹åæ ‡set(&quot;x span&quot;,1e-6);#è®¾ç½®xæ–¹å‘å®½åº¦set(&quot;y span&quot;,1e-6);#è®¾ç½®yæ–¹å‘å®½åº¦set(&quot;z max&quot;,1e-7);#è®¾ç½®zæ–¹å‘æœ€å¤§å€¼set(&quot;z min&quot;,-1e-6);#è®¾ç½®zæ–¹å‘æœ€å°å€¼set(&quot;first axis&quot;,&quot;x&quot;);#è®¾ç½®ç¬¬ä¸€è½¬è½´set(&quot;rotation 1&quot;,45);#è®¾ç½®ç¬¬ä¸€æ—‹è½¬è§’ æ•ˆæœå±•ç¤º ä¸‹é¢è¯¦ç»†ä»‹ç»æ¯æ®µä»£ç çš„ç”¨é€”ï¼š addrectï¼šéšæœºç”Ÿæˆä¸€ä¸ªä¸€å®šå¤§å°ï¼Œææ–™ä¸ºä¸€å®šæŠ˜å°„ç‡ä»‹ç”µææ–™çš„çŸ©å½¢æ¨¡å‹ã€‚ set(â€œnameâ€,â€œrectâ€)ï¼šåç§°ã€‚è®¾å®šçŸ©å½¢çš„åç§°ä¸ºâ€œrectâ€ set(â€œmaterialâ€,â€œSiO2 (Glass) - Palikâ€)ï¼šææ–™â€”â€”è¿™é‡Œçš„ææ–™å¿…é¡»æ˜¯ææ–™åº“ä¸­å­˜åœ¨çš„ï¼Œä¸”å¿…é¡»æŒ‰ç…§ææ–™åº“ä¸­åŸæœ‰çš„åå­—å‘½åã€‚è®¾å®šçŸ©å½¢çš„ææ–™ä¸ºäºŒæ°§åŒ–ç¡… set(â€œrender typeâ€,â€œwireframeâ€)ï¼šæ¸²æŸ“æ–¹å¼â€”â€”æœ‰detailedå’Œwireframeä¸¤ç§ï¼Œç³»ç»Ÿé»˜è®¤ä¸ºdetailedï¼Œå¦‚æœ‰éœ€è¦ï¼Œå¯æ”¹ä¸ºwireframeã€‚è®¾å®šçŸ©å½¢çš„æ¸²æŸ“æ–¹å¼ä¸ºçº¿æ¡† set(â€œxâ€,â€œ0â€)ï¼šä¸­å¿ƒåæ ‡(xè½´)ï¼Œç±»ä¼¼åœ°è¿˜å¯è®¾ç½®yå’Œzçš„ä¸­å¿ƒåæ ‡ã€‚è®¾å®šçŸ©å½¢çš„ä¸­å¿ƒåæ ‡ï¼ˆxè½´ï¼‰ä¸º0 set(â€œx spanâ€,â€œ1e-6â€)ï¼šxè½´å‘å®½åº¦ï¼ˆæˆ–èŒƒå›´ï¼‰ï¼Œç±»ä¼¼åœ°è¿˜å¯è®¾ç½®yå’Œzçš„è½´å‘å®½åº¦ã€‚è®¾å®šçŸ©å½¢çš„xè½´å‘å®½åº¦ä¸º1e-6ï¼Œå³1å¾®ç±³ set(â€œz maxâ€,â€œ1e-7â€)ï¼šzæ–¹å‘æœ€å¤§å€¼ï¼Œç±»ä¼¼åœ°è¿˜æœ‰z minã€x maxã€x minã€y maxã€y minã€‚è®¾å®šçŸ©å½¢çš„zæ–¹å‘æœ€å¤§ä¸º1e-7ï¼Œå³100çº³ç±³ set(â€œfirst axisâ€,â€œxâ€)ï¼šç¬¬ä¸€è½¬è½´ã€‚è®¾å®šçŸ©å½¢çš„ç¬¬ä¸€è½¬è½´(first axis)ä¸ºxè½´ set(â€œrotation 1â€,45)ï¼šç»•ç¬¬ä¸€è½¬è½´çš„æ—‹è½¬è§’ã€‚è®¾å®šçŸ©å½¢ç»•xè½´çš„è½¬è§’ä¸º45Â° äºŒã€å¤šè¾¹å½¢æŸ±ä½“ï¼ˆPloygonï¼‰ 1.å¤šè¾¹å½¢æŸ± 123456789101112um=1e-6;nm=1e-9;vtx=[2,0;1,1;-1,1; -2,0;-1,-1;1,-1]*um; #å‘é‡ç»„addpoly;set(&quot;name&quot;,&quot;poly&quot;);#åç§°set(&quot;index&quot;,1.5);#æŠ˜å°„ç‡set(&quot;vertices&quot;,vtx);#æ§åˆ¶å‘é‡ç»„set(&quot;x&quot;,0.5*um);#ä¸­å¿ƒåæ ‡set(&quot;y&quot;,1*um);set(&quot;z&quot;,-0.5*um);set(&quot;z span&quot;,0.4*um);#zæ–¹å‘å®½åº¦ addpolyï¼šæ·»åŠ ä¸€ä¸ªå‚æ•°éšæœºçš„å¤šè¾¹å½¢ç»“æ„ã€‚ set(â€œindexâ€,1.5)ï¼šæŠ˜å°„ç‡ã€‚å¤šè¾¹å½¢ææ–™ä¸ºä»‹ç”µææ–™ï¼ŒæŠ˜å°„ç‡ä¸º1.5 set(â€œverticesâ€,vtx)ï¼šå‘é‡ç»„ã€‚è®¾ç½®å¤šè¾¹å½¢çš„xyé¢äºŒç»´å½¢çŠ¶ï¼Œç”±ä¼ å…¥çš„å‘é‡ç»„vtxä¸­çš„å‚æ•°æ§åˆ¶ 2.ä¸‰è§’å½¢æŸ± 123456789101112um=1e-6;nm=1e-9;vtx=[3,0;0,4;-2,0]*um; #å‘é‡ç»„addtriangle;set(&quot;name&quot;,&quot;triangle&quot;);#åç§°set(&quot;index&quot;,1.5);#æŠ˜å°„ç‡set(&quot;vertices&quot;,vtx);#æ§åˆ¶å‘é‡ç»„set(&quot;x&quot;,0.5*um);#ä¸­å¿ƒåæ ‡set(&quot;y&quot;,1*um);set(&quot;z&quot;,-0.5*um);set(&quot;z span&quot;,0.4*um);#zæ–¹å‘å®½åº¦ ä¸‰ã€ï¼ˆæ¤­ï¼‰åœ†æŸ±ä½“ï¼ˆCircleï¼‰ 1234567891011121314um=1e-6;nm=1e-9;addcircle;set(&quot;name&quot;,&quot;circle&quot;);set(&quot;material&quot;,&quot;Au (Gold) - Palik&quot;);set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,0);set(&quot;z span&quot;,400*nm);set(&quot;radius&quot;,600*nm);#åŠå¾„/xè½´åŠå¾„set(&quot;make ellipsoid&quot;,1);#ç”Ÿæˆæ¤­åœ†set(&quot;radius 2&quot;,800*nm);#yè½´åŠå¾„ set(â€œradiusâ€,600nm)ï¼šåŠå¾„/xè½´åŠå¾„ã€‚è‹¥æ˜¯åœ†æŸ±ä½“ï¼Œradiusä¸ºåœ†çš„åŠå¾„ï¼›è‹¥æ˜¯æ¤­åœ†æŸ±ä½“ï¼Œradiusä¸ºæ¤­åœ†åœ¨xè½´æ–¹å‘çš„åŠè½´é•¿ï¼ˆå¯èƒ½æ˜¯é•¿åŠè½´æˆ–çŸ­åŠè½´ï¼Œç”±radiuså’Œradiusçš„ç›¸å¯¹å¤§å°å†³å®šï¼‰ã€‚è¿™é‡Œè¡¨ç¤ºæ¤­åœ†çŸ­åŠè½´ä¸º600nm set(â€œmake ellipsoidâ€,1)ï¼šç”Ÿæˆæ¤­åœ†ã€‚â€œmake ellipsoidâ€å¯å–ä¸¤ä¸ªå€¼ï¼š0å’Œ1ã€‚å…¶ä¸­ï¼Œ0è¡¨ç¤ºç”Ÿæˆçš„ä¸ºåœ†æŸ±ä½“ï¼Œ1è¡¨ç¤ºç”Ÿæˆæ¤­åœ†æŸ±ä½“ï¼ˆä¹Ÿå¯ä»¥è®¤ä¸º1æ˜¯enableæ¤­åœ†å‚æ•°radius 2ï¼Œä¸º0åˆ™radius 2è¢«disableï¼Œåªç”ŸæˆåŠå¾„ä¸ºradiusçš„åœ†æŸ±ï¼‰ã€‚è¿™é‡Œå‚æ•°ä¸º1è¡¨ç¤ºç”Ÿæˆä¸€ä¸ªæ¤­åœ†æŸ±ä½“ã€‚ set(â€œradius 2â€,800nm)ï¼šyè½´åŠå¾„ï¼Œæ¤­åœ†çš„ç¬¬äºŒåŠè½´é•¿ã€‚ç”Ÿæˆä¸€ä¸ªç¬¬äºŒåŠè½´é•¿ä¸º800nmçš„æ¤­åœ†æŸ±ä½“ã€‚ å››ã€ï¼ˆæ¤­ï¼‰çƒä½“ï¼ˆSphereï¼‰ 1234567891011121314um=1e-6;nm=1e-9;addsphere;set(&quot;name&quot;,&quot;sphere&quot;);set(&quot;index&quot;,1.5);set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,0);set(&quot;radius&quot;,200*nm);#åŠå¾„/xè½´åŠå¾„set(&quot;make ellipsoid&quot;,1);#ç”Ÿæˆæ¤­çƒset(&quot;radius 2&quot;,400*nm);#yè½´åŠå¾„set(&quot;radius 3&quot;,2*um);#zè½´åŠå¾„ çƒä½“çš„ä»£ç å’Œæ¤­åœ†æŸ±çš„ä»£ç ååˆ†ç›¸ä¼¼ï¼ŒåŒºåˆ«ä»…åœ¨äºå¤šäº†ä¸€ä¸ªç¬¬ä¸‰åŠå¾„ï¼ˆradius 3ï¼‰ï¼ˆäº‹å®ä¸Šæ˜¯æ§åˆ¶äº†zè½´æ–¹å‘çš„å¤§å°ï¼‰ äº”ã€åœ†ç¯ï¼ˆä½“ï¼‰ï¼ˆRingï¼‰ 123456789101112131415um=1e-6;nm=1e-9;addring;set(&quot;name&quot;,&quot;ring&quot;);set(&quot;index&quot;,1.5);set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,0);set(&quot;z span&quot;,600*nm);set(&quot;outer radius&quot;,400*nm);#å¤–åœ†åŠå¾„set(&quot;inner radius&quot;,200*nm);#å†…åœ†åŠå¾„set(&quot;theta start&quot;,0);#èµ·å§‹è§’set(&quot;theta stop&quot;,135);#ç»ˆæ­¢è§’ å…­ã€è§’æ¤ä½“ï¼ˆPyramidï¼‰ 123456789101112131415um=1e-6;nm=1e-9;addpyramid;set(&quot;name&quot;,&quot;pyramid&quot;);set(&quot;index&quot;,1.5);set(&quot;x&quot;,0);set(&quot;x span bottom&quot;,600*nm);#æ¢¯å½¢ä¸‹åº•é•¿ï¼ˆxè½´å‘ï¼‰set(&quot;x span top&quot;,100*nm);#æ¢¯å½¢ä¸Šåº•é•¿ï¼ˆxè½´å‘ï¼‰set(&quot;y&quot;,0);set(&quot;y span bottom&quot;,400*nm);#æ¢¯å½¢ä¸‹åº•é•¿ï¼ˆyè½´å‘ï¼‰set(&quot;y span top&quot;,200*nm);#æ¢¯å½¢ä¸Šåº•é•¿ï¼ˆyè½´å‘ï¼‰set(&quot;z&quot;,0);set(&quot;z span&quot;,600*nm); å…¶ä¸­å‚æ•°\"x span bottom\"ã€â€œy span bottomâ€ã€â€œx span topâ€ã€\"y span top\"åˆ†åˆ«æ§åˆ¶è¯¥è§’é”¥ä½“ä¸‹ã€ä¸Šåº•é¢çš„çŸ©å½¢å¤§å°ã€‚","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"Lumericalè„šæœ¬è¯­è¨€å­¦ä¹ (äºŒ)","slug":"Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 2","date":"2022-02-20T08:06:26.848Z","updated":"2022-02-20T08:10:43.686Z","comments":true,"path":"2022/02/20/Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 2/","link":"","permalink":"http://example.com/2022/02/20/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02/","excerpt":"","text":"å‚è€ƒäº†(61æ¡æ¶ˆæ¯) FDTDå¿«é€Ÿå…¥é—¨ä¹‹Lumericalè„šæœ¬è¯­è¨€Pickupï¼ˆäºŒï¼‰å®ç”¨æŠ€å·§_ArcSightçš„åšå®¢-CSDNåšå®¢_fdtdè„šæœ¬ æŠ€å·§å’Œä¹ æƒ¯ FDTDæ²¡æœ‰ä¸“é—¨çš„é•¿åº¦å•ä½å¸¸é‡ï¼Œé»˜è®¤çš„é•¿åº¦å•ä½æ˜¯ç±³(m)ï¼Œæ‰€ä»¥ä¸€èˆ¬ç”¨1e-6å’Œ1e-9åˆ†åˆ«è¡¨ç¤ºå¾®ç±³(um)å’Œçº³ç±³(nm)ã€‚ æ³¨é‡Šç¬¦å·ï¼š# è¿è¡Œè„šæœ¬å¿«æ·é”®ï¼šF5 è¿è¡Œé€‰ä¸­ä»£ç æ®µå¿«æ·é”®ï¼šF9 æ³¨é‡Šå¿«æ·é”®ï¼šCtrl+R å–æ¶ˆæ³¨é‡Šå¿«æ·é”®ï¼šCtrl+T è¿ç®—ç¬¦","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"Lumericalè„šæœ¬è¯­è¨€å­¦ä¹ (ä¸€)","slug":"Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 1","date":"2022-02-20T07:51:30.952Z","updated":"2022-03-20T08:24:24.312Z","comments":true,"path":"2022/02/20/Lumerical/lumericalè„šæœ¬è¯­è¨€å­¦ä¹ 1/","link":"","permalink":"http://example.com/2022/02/20/Lumerical/lumerical%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01/","excerpt":"","text":"è¿™æ˜¯ä¸€æ®µç”¨äºéªŒè¯å…‰ä»å…‰ç–ä»‹è´¨å…¥å°„åˆ°å…‰å¯†ä»‹è´¨æ—¶ï¼Œåå°„æ³¢ä¸­å­˜åœ¨åŠæ³¢æŸå¤±çš„å®Œæ•´ä»¿çœŸä»£ç ã€‚å®ƒåŒ…å«äº†ä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š ä»¿çœŸç»“æ„(structure) ä»¿çœŸåŒºåŸŸ(FDTD) å…‰æº(source) ç›‘è§†å™¨ï¼ˆmonitorï¼‰ ä»¿çœŸç»“æœåˆ†æ(Analysis) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677switchtolayout;selectall;delete;nm=1e-9;#çº³ç±³å•ä½um=1e-6;#å¾®ç±³å•ä½#æ·»åŠ çŸ©å½¢addrect;set(&quot;name&quot;,&quot;SiO2&quot;);#åç§°ä¸ºSiO2 set(&quot;material&quot;,&quot;SiO2 (Glass) - Palik&quot;);#ææ–™ä¸ºäºŒæ°§åŒ–ç¡…ï¼ˆç»ç’ƒï¼‰set(&quot;x&quot;,0);#è®¾ç½®xä¸­å¿ƒç‚¹åæ ‡ set(&quot;y&quot;,0);#è®¾ç½®yä¸­å¿ƒç‚¹åæ ‡set(&quot;x span&quot;,1*um);#è®¾ç½®xæ–¹å‘å®½åº¦set(&quot;y span&quot;,1*um);#è®¾ç½®yæ–¹å‘å®½åº¦set(&quot;z max&quot;,100*nm);#è®¾ç½®zæ–¹å‘æœ€å¤§å€¼set(&quot;z min&quot;,-1*um);#è®¾ç½®zæ–¹å‘æœ€å°å€¼#æ·»åŠ FDTDä»¿çœŸåŒºåŸŸaddfdtd;set(&quot;dimension&quot;,2);#ä»¿çœŸåŒºåŸŸä¸ºä¸‰ç»´åŒºåŸŸset(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z min&quot;,-10*nm);set(&quot;z max&quot;,2*um);set(&quot;x span&quot;,0.2*um);set(&quot;y span&quot;,0.22*um);set(&quot;x min bc&quot;,&quot;periodic&quot;);#è®¾ç½®xæ–¹å‘å‘¨æœŸè¾¹ç•Œæ¡ä»¶set(&quot;y min bc&quot;,&quot;periodic&quot;);#è®¾ç½®yæ–¹å‘å‘¨æœŸè¾¹ç•Œæ¡ä»¶set(&quot;Mesh type&quot;,&quot;uniform&quot;);#ä»¿çœŸç½‘æ ¼ä¸ºè‡ªå®šä¹‰æ–¹å¼Mesh_size=10*nm;#ç½‘æ ¼ç²¾åº¦10nmsetnamed(&quot;FDTD&quot;,&quot;dx&quot;,Mesh_size);setnamed(&quot;FDTD&quot;,&quot;dy&quot;,Mesh_size);#æ·»åŠ å¹³é¢æ³¢addplane;set(&quot;injection axis&quot;,&quot;z&quot;);#å…¥å°„è½´ä¸zè½´å¹³è¡Œset(&quot;direction&quot;,&quot;backward&quot;);#æœå‘åæ–¹å…¥å°„set(&quot;x&quot;,0);set(&quot;x span&quot;,0.4*um);set(&quot;y&quot;,0);set(&quot;y span&quot;,0.4*um);set(&quot;z&quot;,1*um);set(&quot;wavelength start&quot;,1.5*um);#æ³¢é•¿ï¼ˆæœ€å°ï¼‰set(&quot;wavelength stop&quot;,1.5*um);#æ³¢é•¿ï¼ˆæœ€å¤§ï¼‰#æ·»åŠ ç‚¹ç›‘è§†å™¨addprofile;set(&quot;name&quot;,&quot;R&quot;);set(&quot;monitor type&quot;,1);#ç‚¹ç›‘è§†å™¨set(&quot;x&quot;,0);set(&quot;y&quot;,0);set(&quot;z&quot;,1.5*um);#æ·»åŠ æ—¶é—´ç›‘è§†å™¨addtime;set(&quot;name&quot;,&quot;time&quot;);run;#è¿è¡Œä»¿çœŸ#è·å–ç»“æœå¹¶åˆ†æselect(&quot;SiO2&quot;);surface_z=get(&quot;z max&quot;);select(&quot;source&quot;);source_z=get(&quot;z&quot;);select(&quot;R&quot;);monitor_z=get(&quot;z&quot;);ex=getdata(&quot;R&quot;,&quot;Ex&quot;);R_z=getdata(&quot;R&quot;,&quot;z&quot;);f=getdata(&quot;R&quot;,&quot;f&quot;);f=pinch(f);lambda=c/f*1e6;phase=pinch(angle(ex));phai=phase-2*pi*(source_z+monitor_z-2*surface_z)*f/c;phai=mod(phai*180/pi,360);plot(lambda,phai,&quot;lambda um&quot;,&quot;phase&quot;);","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"Lumericalä»¿çœŸå®ä¾‹(ä¸€)-å¾®ç¯è°ƒåˆ¶å™¨","slug":"Lumerical/Lumericalä»¿çœŸå®ä¾‹(ä¸€)-å¾®ç¯è°ƒåˆ¶å™¨","date":"2022-01-31T08:03:35.165Z","updated":"2022-02-17T12:28:46.888Z","comments":true,"path":"2022/01/31/Lumerical/Lumericalä»¿çœŸå®ä¾‹(ä¸€)-å¾®ç¯è°ƒåˆ¶å™¨/","link":"","permalink":"http://example.com/2022/01/31/Lumerical/Lumerical%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B(%E4%B8%80)-%E5%BE%AE%E7%8E%AF%E8%B0%83%E5%88%B6%E5%99%A8/","excerpt":"","text":"å¤ç°è®ºæ–‡ç»“æœ è®ºæ–‡æ ‡é¢˜: Ultra-low voltage, ultra-small mode volume silicon microring modulator å‡ ä¸ªé‡è¦å‚æ•° å¾®ç¯è°ƒåˆ¶å™¨ç¤ºæ„å›¾ å¾®ç¯åŠå¾„: 2.5 Âµm å¾®ç¯å®½åº¦: 500nm ç›´æ³¢å¯¼å®½åº¦: 350nm å¾®ç¯å’Œç›´æ³¢å¯¼é«˜åº¦: 50nm å¤–å±‚ææ–™ä¸º:\\(SIO_2\\) image-20220131165029262 åœ†ç¯æœ€åè°æŒ¯æ³¢é•¿ä¸º1564nm æ“ä½œæ­¥éª¤ è¿›å…¥FDTD è¿›å…¥FDTD å¯ä»¥åœ¨componentç›´æ¥å¯¼å…¥ç»“æ„æˆ–è€…åœ¨structureè‡ªå®šä¹‰ è®¾ç½®å‚æ•° è¿›å…¥Edit object è®¾ç½®å‚æ•° æ·»åŠ å…‰æº--ä¸ºæ¨¡å¼å…‰æº è®¾ç½®å…‰æºå‚æ•° æ³¢é•¿è®¾ç½®ä¸º:1.5åˆ°1.6 æ·»åŠ ç›‘è§†å™¨ éœ€è¦æ£€æµ‹é€å°„ç‡ä¸æ³¢é•¿å…³ç³» å› æ­¤æ·»åŠ frequency-domain field and power è®¾ç½®ç›‘è§†å™¨ è®¾ç½®æ–¹å‘ä¸º2dx-normal frequency points é‡è¦å‚æ•° æ·»åŠ ä»¿çœŸåŒºåŸŸ xæ–¹å‘å’Œzæ–¹å‘æœ‰å…‰,yæ–¹å‘æ²¡æœ‰å…‰ å› æ­¤å°†yæ–¹å‘è®¾ç½®ä¸ºmetal,xå’Œzæ–¹å‘è®¾ç½®ä¸ºpml å¯ä»¥åŠ å¿«è®¡ç®—é€Ÿåº¦ å¯ä»¥æ·»åŠ meshåœ¨è€¦åˆåŒºåŸŸ,å¢åŠ è¯¥åŒºåŸŸçš„è®¡ç®—ç²¾åº¦ è®¾ç½®èƒŒæ™¯ææ–™ä¸º\\(sio_2\\) æœ¬æ¬¡ä»¿çœŸè¿›è¡Œçš„æ˜¯2Dä»¿çœŸ,æœ€åæ‰€å¾—å‚æ•°è·Ÿè®ºæ–‡ç»“æœè¿‘ä¹ç›¸åŒ,æœ‰äº›å‚æ•°æ²¡æœ‰ä»”ç»†è°ƒ,ä¸»è¦æ˜¯ç†Ÿæ‚‰FDTDçš„ä¸€äº›æ“ä½œ","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"},{"name":"ä»¿çœŸå®ä¾‹","slug":"Lumerical/ä»¿çœŸå®ä¾‹","permalink":"http://example.com/categories/Lumerical/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"ä»¿çœŸå®ä¾‹","slug":"ä»¿çœŸå®ä¾‹","permalink":"http://example.com/tags/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"}]},{"title":"Lumerical è½¯ä»¶å­¦ä¹ (ä¸€)-FDTD","slug":"Lumerical/Lumericalè½¯ä»¶å­¦ä¹ (ä¸€)","date":"2022-01-29T13:29:14.835Z","updated":"2022-01-30T08:19:38.326Z","comments":true,"path":"2022/01/29/Lumerical/Lumericalè½¯ä»¶å­¦ä¹ (ä¸€)/","link":"","permalink":"http://example.com/2022/01/29/Lumerical/Lumerical%E8%BD%AF%E4%BB%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)/","excerpt":"","text":"Theory of Lumerical Solvers-FDTD commonly used software FDTD solutions MODE solutions CHARGE solutions HEAT solutions INTERCONNECT etc FDTD: finite-difference time -domain method Maxwell's equations: ç­‰æˆ‘å­¦å®Œå†å†™(å…ˆæŒ–ä¸ªå‘) Discretize the fields in time and space An important parameter: point per wavelength Defined by\"Mesh arruracy\",ranging from 1-10.Usually set to 2 The frequency domain response is calculated by Fourier transform. Many quantities are derived from the frequency domain fields, such as the Poynting vector, transmission and reflection spectrum, the field power profile,etc. frequency domain: é¢‘åŸŸ Poynting vector: å¡å°äº­çŸ¢é‡ field power profile: åœºå¼ºåˆ†å¸ƒ Essential components of FDTD simulation: Structure(å‡ ä½•ç»“æ„) Material(ææ–™) Source(å…‰æº) Simulation region(ä»¿çœŸåŒºåŸŸ) Monitor(ç›‘è§†å™¨) Sorce Dipole source: utilized as point source (å¶æå­å…‰æº,ç”¨äºä»¿çœŸç‚¹å…‰æº) Plane wave: ideal source with infinite size (å¹³é¢æ³¢,å¤§å°æ— é™å¤§,é€šå¸¸ç”¨äºå‘¨æœŸæ€§ç»“æ„) TPSF(total-field scatter-field source): inside the source region -incident light(å…¥å°„å…‰) and scattering light(æ•£å°„å…‰) outside the source region -only scatter light TPSFç¤ºæ„å›¾ (ç²‰è‰²ç®­å¤´è¡¨ç¤ºå…¥å°„å…‰å…¥å°„æ–¹å‘,è“è‰²ç®­å¤´è¡¨ç¤ºç”µåœºæŒ¯åŠ¨æ–¹å‘) (ç™½è‰²åŒºåŸŸå†…åŒ…å«å…¥å°„åœºå’Œæ•£å°„åœº,ç™½è‰²åŒºåŸŸå¤–åªæœ‰æ•£å°„åœº,æ–¹ä¾¿è®¡ç®—) Gaussian source: represnts light from laser source(æ¿€å…‰å™¨) or light from anobjective lens(ç‰©é•œ) with a given NA (nonperiodic) (Grating Coupler) Mode source: represents eigen modes (e.g. TE/TM) in waveguides(è¡¨ç¤ºæ³¢å¯¼ä¸­çš„æœ¬å¾æ¨¡å¼) è¡¥å……: è¡¥å…… Simulation region Boundary condition PML: perfectly matched layer, 100% absorption, 0% reflection Metal: perfect electric conductor (PEC) 100% reflection, 0% absorption (usually used when there is nearly no light at the boundaries of simulation region, because it takes the shortest time to simulate using Metal boundaries) Periodic boundaries: used when the structures and field prolife are periodic ,for vertical incident light Bloch boundaries: similar to periodic boundaries, but for angled incident light (periodic/bloch boundaries work with plane wave) Symmetric/anti-symmetric boundaries: used when the structures and field are symmetric or anti-symmetric (e.g. TE mode, positive electric field against negative electric field) tips A tip for set-up: apply symmetric conditions to the boundaries which are parallel to theblue arrow of light (representing the electric field) symmetric/anti-symmetric boundaries å¹³è¡Œäºè“è‰²çº¿è®¾ç½®å¯¹ç§°çš„è¾¹ç•Œæ¡ä»¶ å‚ç›´äºè“è‰²çº¿è®¾ç½®è®¾ç½®åå¯¹ç§°çš„è¾¹ç•Œæ¡ä»¶ PML boundaries and dipole sources PML boundaries and dipole sources Materials and Monitor material and monitor åå°„è°±å’Œé€å°„è°±(å¾®ç¯ç»“æ„) åå°„è°±å’Œé€å°„è°±(å¾®ç¯ç»“æ„) Applications of FDTD: nanophotonic devices with aribitrary shape application Intergrated Optics: é›†æˆå…‰å­¦ CMOs image sensors: å›¾åƒä¼ æ„Ÿå™¨ Solar Cells: å¤ªé˜³èƒ½ç”µæ±  OLEDs(OrganicLight-Emitting Diode): æœ‰æœºå‘å…‰äºŒæç®¡ Nanoparticles: çº³ç±³ç²’å­ Plasmonics: ç­‰ç¦»å­ä½“ Liquid crystals: æ¶²æ™¶ photonic crystals: å…‰å­æ™¶ä½“ Grating devices: å…‰æ …å™¨ä»¶ Lithography: å…‰åˆ» Metamaterials: è¶…ææ–™ Defect detection: ç¼ºé™·æ£€æµ‹ é¢„å‘Š: ä¸‹æ¬¡å†™MODE","categories":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"}],"tags":[{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"}]},{"title":"æ–‡çŒ®é˜…è¯»(äºŒ)ç¡…åŸºå…‰æ …è€¦åˆå™¨","slug":"æ–‡çŒ®é˜…è¯»è®°å½•/æ–‡çŒ®é˜…è¯»-äºŒ-ç¡…åŸºå…‰æ …è€¦åˆå™¨","date":"2022-01-29T12:20:49.000Z","updated":"2022-02-14T15:41:31.124Z","comments":true,"path":"2022/01/29/æ–‡çŒ®é˜…è¯»è®°å½•/æ–‡çŒ®é˜…è¯»-äºŒ-ç¡…åŸºå…‰æ …è€¦åˆå™¨/","link":"","permalink":"http://example.com/2022/01/29/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB-%E4%BA%8C-%E7%A1%85%E5%9F%BA%E5%85%89%E6%A0%85%E8%80%A6%E5%90%88%E5%99%A8/","excerpt":"","text":"å…‰æ …è€¦åˆå™¨ä¸»è¦æ€§èƒ½æŒ‡æ ‡å’Œä¼˜ç‚¹ (ä¸ªäººç†è§£) 1ï¼‰è€¦åˆæ•ˆç‡(coupling efficiency)(è¡¨ç¤ºèƒ½é‡æŸè€—) 2ï¼‰å¸¦å®½(bandwidth)(è¡¨ç¤ºä¿¡æ¯ä¼ è¾“çš„èƒ½åŠ›) 3ï¼‰åæŒ¯ä¾èµ–æ€§(polarization dependency) (åæŒ¯ä¾èµ–æŸè€—ï¼ˆPDLï¼‰æ˜¯æŒ‡å…·æœ‰åæŒ¯ç‰¹æ€§çš„å…‰ä¿¡å·ï¼Œåœ¨å…‰çº¤ã€å…‰å™¨ä»¶æˆ–ç”±å®ƒä»¬ç»„æˆçš„ç½‘ç»œä¼ è¾“è¿‡ç¨‹ä¸­ï¼Œç”±äºå…‰çš„åæŒ¯ç‰¹æ€§å˜åŒ–è€Œå¼•èµ·çš„å…‰åŠŸç‡å˜åŒ–) 4ï¼‰å¯¹å‡†å®¹å·®(alignment tolerance)(ä¸å®é™…ç”Ÿäº§å·¥è‰ºæœ‰å…³) ä¼˜ç‚¹ å…‰æ …è€¦åˆå™¨çš„ä¸»è¦ä¼˜ç‚¹åœ¨äºå…¶ä½ç½®æ¯”è¾ƒçµæ´»ï¼Œå¯ä½äºèŠ¯ç‰‡ä¸­çš„ä»»æ„ä½ç½®ï¼Œå› è€Œå¯ç”¨äºæ™¶åœ†çº§çš„åœ¨çº¿æµ‹è¯•ï¼Œå¦å¤–å…¶è€¦åˆçš„å¯¹å‡†å®¹å·®è¾ƒå¤§ï¼Œä¾¿äºå°è£…ã€‚ä½†æ˜¯å…¶è€¦åˆæ•ˆç‡ä¸å¤ªé«˜ï¼Œå¹¶ä¸”å¸¦å®½è¾ƒå°(1dBå¸¦å®½çº¦30-40nm)ï¼Œ1ç»´GCæ˜¯åæŒ¯æ•æ„Ÿçš„ã€‚ å…‰æ …è€¦åˆå™¨ç±»å‹å’Œç‰¹æ€§ å…‰æ …è€¦åˆå™¨çš„ä¸»è¦ç ”ç©¶å†…å®¹åŒ…æ‹¬è€¦åˆæ•ˆç‡ã€è€¦åˆè§’åº¦ã€å·¥ä½œæ³¢é•¿å¸¦å®½ã€åæŒ¯ç›¸å…³æ€§ç­‰ å…‰æ …è€¦åˆå™¨çš„è€¦åˆæ•ˆç‡æ˜¯ç”±è¡å°„å¼ºåº¦ã€æ–¹å‘æ€§æ•ˆç‡å’Œè€¦åˆå…‰åœºé‡å ç§¯åˆ†ä¸‰ä¸ªéƒ¨åˆ†å…±åŒå†³å®šçš„ åæŒ¯ç›¸å…³æ€§æ¦‚å¿µ? ç¡…åŸºå…‰æ …è€¦åˆå™¨ä»¶å¯åˆ†ä¸ºä¸€ç»´ç»“æ„å’ŒäºŒç»´ç»“æ„, æ ¹æ®å…‰æ …å•å…ƒçš„å‘¨æœŸã€å ç©ºæ¯”ã€åˆ»èš€æ·±åº¦ã€åˆ»èš€è§’åº¦çš„ä¸åŒåˆå¯åˆ†ä¸ºå‡åŒ€å…‰æ …è€¦åˆå™¨ã€éå‡åŒ€å…‰æ …è€¦åˆå™¨ä»¥åŠé—ªè€€å…‰æ …è€¦åˆå™¨ç­‰ å•å•¾çš„æœ€ç®€å•å®šä¹‰æ˜¯ä¿¡å·é¢‘ç‡éšæ—¶é—´å˜åŒ–ï¼Œåœ¨è„‰å†²å‰åæ²¿ç”±äºè°ƒåˆ¶äº§ç”Ÿé¢‘ç‡å˜åŒ–ï¼Œä½¿ä¿¡å·é¢‘è°±å±•å®½ é«˜æ•ˆç‡éå‡åŒ€è€¦åˆç»“æ„ å‡åŒ€å…‰æ …è€¦åˆå™¨æ˜¯æŒ‡æ¯ä¸ªå…‰æ …çš„å•å…ƒå‘¨æœŸã€å ç©ºæ¯”ã€åˆ»èš€æ·±åº¦å‡ä¸ºæ’å®šå€¼ ,ä½†æ˜¯å‡åŒ€å…‰æ …è€¦åˆå™¨å¯¹çš„é‡å ç§¯åˆ†å—åˆ°é™åˆ¶,è€¦åˆæ•ˆç‡è¾ƒä½ å‡åŒ€å…‰æ …è€¦åˆå™¨çš„ä¼˜ç‚¹ CMOS å·¥è‰ºå…¼å®¹, å·¥è‰ºç›¸å¯¹ç®€å• å¯¹å‡åŒ€ç»“æ„çš„ç ”ç©¶æ¯”è¾ƒå…¨é¢, åŠ å·¥æ–¹æ³•æ¯”è¾ƒæˆç†Ÿ éå‡åŒ€å…‰æ …è€¦åˆå™¨, æ˜¯æŒ‡å‘¨æœŸå’Œå ç©ºæ¯”ç”šè‡³åˆ»èš€æ·±åº¦éšå…‰ä¼ æ’­æ–¹å‘æ”¹å˜çš„ä¸€ç§å‡†å‘¨æœŸç»“æ„ ç”±äºå·¥è‰ºä¸Šçš„éš¾é¢˜, è¿™ç§å…‰æ …è€¦åˆå™¨ç»“æ„ä»ç†è®ºæå‡ºä»¥åå‘å±•ç¼“ æ…¢ å‚ç›´è€¦åˆç»“æ„ ä¸€ç›´ä»¥æ¥, ä¸ºäº†é™ä½äºŒé˜¶åå°„, ä»è€Œæé«˜è€¦åˆæ•ˆç‡, å…‰æ …è€¦åˆå™¨çš„è¡å°„æ–¹å‘å‘ˆ 10â—¦ å·¦å³çš„åè§’ é™åˆ¶å®é™…åº”ç”¨å’Œå°è£…å›°éš¾ å‚ç›´è€¦åˆæˆä¸ºäº†ç»§è€¦åˆæ•ˆç‡ä¹‹åé™åˆ¶å…‰æ …è€¦åˆå™¨å®ç”¨åŒ–çš„å¦ä¸€å¾…è§£éš¾é¢˜ æœ€ç†æƒ³çš„æ¶ˆé™¤äºŒé˜¶åå°„çš„æ–¹æ³•æ˜¯é—ªè€€å…‰æ … ,ä½†åŠ å·¥è¦æ±‚é«˜,ä¸CMOSå·¥è‰ºä¸å…¼å®¹ æ–‡çŒ®ä¸­çš„è¯¾é¢˜ç»„æå‡ºäº†ä¸€ç§ç¼“å˜é˜¶æ¢¯å‹é—ªè€€å…‰æ …è€¦åˆå™¨,ç”¨å¤šé˜¶æ¢¯ç»“æ„æ›¿ä»£é—ªè€€å…‰æ …çš„å€¾æ–œé¢ (è¿™æ˜¯å±äºæ­£å‘è®¾è®¡) äºŒç»´å…‰æ …è€¦åˆå™¨ äºŒç»´å…‰æ …è€¦åˆå™¨å¤§è‡´å¯åˆ†ä¸ºä¸¤ç§, ä¸€ç§æ˜¯ç±»ä¼¼å…‰å­æ™¶ä½“ç»“æ„çš„å…‰æ …è€¦åˆå™¨, å¦ä¸€ç§æ˜¯å¼§å½¢å…‰æ …è€¦åˆå™¨ 2D å…‰å­æ™¶ä½“å…‰æ …è€¦åˆå™¨ äºŒç»´å…‰å­æ™¶ä½“å…‰æ …è€¦åˆå™¨æ˜¯ä¸ºäº†è§£å†³å…‰æ …æ³¢å¯¼å†…çš„åæŒ¯é—®é¢˜æå‡ºçš„ å…·ä½“å†…å®¹è¿˜æ¬ ç¼ºå¾ˆå¤šåŸºç¡€çŸ¥è¯†... å¤§å¸¦å®½å•å•¾å…‰æ … åŸºæœ¬æ¦‚å¿µ é¢‘ç‡éšæ—¶é—´å˜åŒ–çš„æ³¢å«å•å•¾æ³¢ å¦‚æœé¢‘ç‡éšæ—¶é—´å¢åŠ ï¼Œå…ˆçœ‹åˆ°ä½é¢‘æ³¢åçœ‹åˆ°é«˜é¢‘æ³¢ï¼Œä¸ºæ­£å•å•¾ï¼Œä¹Ÿå°±æ˜¯ä¸Šå‡çš„å‰æ²¿æ˜¯ä½é¢‘ï¼Œä¸‹é™çš„åæ²¿æ˜¯é«˜é¢‘ã€‚åä¹‹ä¸ºè´Ÿå•å•¾ã€‚ éå‡åŒ€å…‰æ …è€¦åˆå™¨ä¸­çš„å•å•¾ç»“æ„, å°±æ˜¯ä¸ºäº†æé«˜å¸¦å®½è€Œæ å‡ºçš„. ç›¸æ¯”å‡åŒ€å…‰æ …è€¦åˆå™¨, å•å•¾å…‰æ …å¢åŠ äº†ä¸€ä¸ªå•å•¾é‡çš„æ¦‚å¿µ, é€šå¸¸æ˜¯å…‰æ …å•å…ƒå‘¨æœŸçš„å˜åŒ–. å¸¦å®½çš„å¢åŠ ä¸»è¦æ˜¯ç”±å•å•¾é‡å†³å®šçš„ (æš‚æ—¶è¿˜ä¸æ˜¯ç‰¹åˆ«æ‡‚) çŸ¥è¯†è¡¥å…… TEå«åšæ¨ªç”µæ¨¡ï¼ŒæŒ‡çš„æ˜¯ç”µåœºæ–¹å‘ä¸ä¼ æ’­æ–¹å‘å‚ç›´çš„ã€‚ TMå«åšæ¨ªç£æ¨¡ï¼ŒæŒ‡çš„æ˜¯ç£åœºæ–¹å‘ä¸ä¼ æ’­æ–¹å‘å‚ç›´çš„ã€‚ TEå’ŒTMå¯ä»¥åˆç§°LPï¼Œçº¿æ€§åæŒ¯æ¨¡ã€‚ TEMå«åšæ¨ªç”µç£æ¨¡ï¼ŒæŒ‡çš„æ˜¯ç”µåœºã€ç£åœºæ–¹å‘éƒ½å’Œä¼ æ’­æ–¹å‘å‚ç›´çš„ã€‚ å‚è€ƒ TEã€TMã€TEMæ¨¡çš„åŒºåˆ«ï¼Ÿ - çŸ¥ä¹ (zhihu.com) img è¯·æƒ³è±¡ä¸€ä¸‹ï¼Œå…‰çº¿ä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œå¾®è§‚çš„ä¼ æ’­æ–¹å‘ï¼ˆç›¸é€Ÿåº¦æ–¹å‘ï¼‰æ˜¯æ²¿ç€çº¢çº¿çš„æ–¹å‘çš„ï¼Œå¦‚æœç”µåœºæ–¹å‘å‚ç›´äºçº¸é¢å‘å†…æˆ–å‘å¤–ï¼Œç£åœºæ–¹å‘å°±æ˜¯åœ¨çº¸é¢å†…ï¼Œä¸çº¢çº¿å‚ç›´çš„ã€‚é‚£ä¹ˆï¼Œç”µåœºçš„æ–¹å‘ä¸çº¸é¢å‚ç›´ï¼Œå°±å’Œçº¸é¢å†…çš„ä»»æ„ä¸€æ¡çº¿å‚ç›´ï¼Œå°±å’Œå…‰çº¤çš„ä¸­å¿ƒçº¿ï¼ˆé‚£æ¡è™šçº¿ï¼Œç¾¤é€Ÿåº¦æ–¹å‘ï¼‰å‚ç›´ï¼Œè€Œç£åœºæ–¹å‘åˆ™æ˜¯ä¸ä¸è¿™æ¡çº¿å‚ç›´ï¼Œè¿™å°±æ˜¯TEæ¨¡ã€‚åŒç†ï¼Œä¹Ÿå¯ç†è§£TMæ¨¡å§ã€‚ ä¼ è¾“ç‰¹æ€§æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢? å¯¹äºTEæ¨¡æ¥è¯´ï¼Œä¸´ç•Œåå°„è§’è¦å¤§ä¸€äº›ï¼ˆå¯ä»¥åˆ°90Â°ï¼Ÿï¼‰ï¼Œå³å¯ä»¥æ›´å¹³ä¸€äº›ï¼Œæ‰€ä»¥åœ¨å°ºå¯¸å‡å°åˆ°ä¸€å®šç¨‹åº¦æ—¶ï¼Œåªæœ‰TEæ¨¡è¿˜å¯ä»¥å­˜åœ¨ã€‚","categories":[{"name":"å¤§åˆ›æ–‡çŒ®","slug":"å¤§åˆ›æ–‡çŒ®","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"}],"tags":[{"name":"å¤§åˆ›","slug":"å¤§åˆ›","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"æ–‡çŒ®","slug":"æ–‡çŒ®","permalink":"http://example.com/tags/%E6%96%87%E7%8C%AE/"}],"author":"John Doe"},{"title":"æ–‡çŒ®é˜…è¯»(ä¸€):ç¡…åŸºå…‰æ …è€¦åˆå™¨çš„ç ”ç©¶è¿›å±•","slug":"æ–‡çŒ®é˜…è¯»è®°å½•/æ–‡çŒ®é˜…è¯»ï¼ˆä¸€ï¼‰ç¡…åŸºå…‰æ …è€¦åˆå™¨çš„ç ”ç©¶è¿›å±•","date":"2022-01-28T15:47:17.000Z","updated":"2022-06-05T14:20:34.180Z","comments":true,"path":"2022/01/28/æ–‡çŒ®é˜…è¯»è®°å½•/æ–‡çŒ®é˜…è¯»ï¼ˆä¸€ï¼‰ç¡…åŸºå…‰æ …è€¦åˆå™¨çš„ç ”ç©¶è¿›å±•/","link":"","permalink":"http://example.com/2022/01/28/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89%E7%A1%85%E5%9F%BA%E5%85%89%E6%A0%85%E8%80%A6%E5%90%88%E5%99%A8%E7%9A%84%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/","excerpt":"","text":"æ–‡çŒ®æ ‡é¢˜: ç¡…åŸºå…‰æ …è€¦åˆå™¨çš„ç ”ç©¶è¿›å±• ç ”ç©¶èƒŒæ™¯: ç”µäº’è¿ç”±äºç”µå­ç‰©ç†ç‰¹æ€§çš„å±€é™,æ— æ³•é€‚åº”ç›®å‰æ—¥ç›Šè†¨èƒ€æ•°æ®ä¼ è¾“éœ€æ±‚. å…‰å­åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¿¡å·è¾ƒç¨³å®š,ä¼ è¾“å®¹é‡å¤§,ç¡…åŸºå…‰å­å™¨ä»¶ä¸CMOSå·¥è‰ºå…¼å®¹ã€æŠ—è¾å°„å¤šç§ä¼˜ç‚¹. æ¦‚å¿µè¡¥å……çŸ¥è¯†: å…‰ä¼ é€’ä¿¡å·çš„æœºç†æ˜¯æ³¢é˜»æŠ—å˜æ¢: å…‰è€¦åˆç»“æ„å¸¸ç”¨ä¸¤ç§è€¦åˆæ–¹å¼: ç«¯é¢æ°´å¹³è€¦åˆç»“æ„ ç‰‡ä¸Šå‚ç›´è€¦åˆç»“æ„ è€¦åˆå™¨æ ¹æ®å…‰çº¤å’Œç¡…èŠ¯ç‰‡çš„ç›¸å¯¹ä½ç½®ï¼Œä¸€èˆ¬å¯åˆ†ä¸ºä¸¤ç§ã€‚ä¸€ç§æ˜¯å¹³é¢è€¦åˆï¼Œä¹Ÿç§°è¾¹ç¼˜è€¦åˆ(Edge Coupler)ï¼ŒæŒ‡å…‰çº¤å’Œç¡…èŠ¯ç‰‡ä½äºåŒä¸€å¹³é¢ï¼Œä½äºèŠ¯ç‰‡çš„ä¾§é¢ï¼Œé€šè¿‡é”¥å½¢æ³¢å¯¼ç­‰æ–¹å¼è¿›è¡Œè€¦åˆã€‚å¦ä¸€ç§æ˜¯å‚ç›´è€¦åˆï¼Œä¹Ÿå°±æ˜¯æ‰€è®²çš„å…‰æ …è€¦åˆ(Grating Couplerï¼ŒGC)ã€‚ å…‰æ …è€¦åˆå™¨çš„åŸºæœ¬åŸç† å…¥å°„ä»‹å€¼å’Œå‡ºå°„ä»‹å€¼æŠ˜å°„ç‡åˆ†åˆ«ä¸º\\(n_1\\),\\(n_2\\) å…‰æ …çŸ¢é‡ä¸º\\(K\\),å¤§å°ä¸º\\(K=\\frac{2\\pi}{p}\\),å…¶ä¸­\\(p\\)ä¸ºå…‰æ …çš„å‘¨æœŸ å…¥å°„å…‰æ³¢çŸ¢ä¸º\\(K_{in}\\),å¤§å°ä¸º\\(K_{in}=\\frac{2\\pi n_1}{\\lambda}\\),\\(\\lambda\\)ä¸ºå…‰æ³¢é•¿ \\(K_{in}\\)åœ¨zæ–¹å‘çš„æŠ•å½±åˆ†é‡ä¸º\\(K_{in,z}\\),å¤§å°ä¸º\\(K_{in,z}=K_{in}sinÎ¸\\), \\(Î¸\\)ä¸ºå…¥å°„å…‰æ³¢çŸ¢åç¦»å…‰æ …æ³•çº¿çš„è§’åº¦ æ­¤æ—¶å„çº§è¡å°„å…‰æ³¢çŸ¢åœ¨zæ–¹å‘çš„æŠ•å½±å¯ä»¥é€šè¿‡å¸ƒæ‹‰æ ¼æ¡ä»¶è¡¨ç¤ºä¸º: \\[ K_{m,z}= K_{in,z}+mK (m = 0;Â±1;Â±2;Â±3;Â·Â·Â·) \\] \\(m\\)è¡¨ç¤ºè¡¨ç¤ºè¡å°„çº§æ•°. è¯¥å…¬å¼çš„å…·ä½“å«ä¹‰ä¸º: mçº§è¡å°„æ³¢çŸ¢åœ¨zæ–¹å‘çš„æŠ•å½±åˆ†é‡ç­‰äºå…¥å°„æ³¢çŸ¢åœ¨zæ–¹å‘çš„æŠ•å½±åˆ†é‡ä¸må€çš„å…‰æ …çŸ¢é‡ä¹‹å’Œ å› æ­¤é€šè¿‡è¡å°„æ³¢çŸ¢åœ¨zæ–¹å‘çš„æŠ•å½±åˆ†é‡å¤§å°å’Œè¡å°„æ³¢çŸ¢æœ¬èº«çš„å¤§å°å¯ä»¥æ±‚å‡ºå„çº§è¡å°„æ³¢çŸ¢çš„è¡å°„è§’åº¦ image-20220128233206175 å…‰æ …æœ‰æ•ˆæŠ˜å°„ç‡\\(n_{eff}\\)çš„ç¡®å®š æ ¹æ®ä¸‹å¼: \\[ n_{eff}=dc*n_{eff1}+(1-dc)*n_{eff2} \\] \\(dc\\)(duty cycl)è¡¨ç¤ºå ç©ºæ¯”,\\(n_{eff1}\\)è¡¨ç¤ºæœªåˆ»èš€éƒ¨åˆ†æ³¢å¯¼çš„æœ‰æ•ˆæŠ˜å°„ç‡, \\(n_{eff2}\\)è¡¨ç¤ºåˆ»èš€éƒ¨åˆ†æ³¢å¯¼çš„æœ‰æ•ˆæŠ˜å°„ç‡ img å½±å“å…‰æ …è€¦åˆå™¨æ€§èƒ½çš„å‡ ä¸ªå› ç´  å…‰çš„åæŒ¯æ–¹å‘ TM modeå’ŒTE modeåœ¨æ³¢å¯¼ä¸­ä¼ è¾“æ—¶å…·æœ‰ä¸åŒçš„æœ‰æ•ˆæŠ˜å°„ç‡ï¼Œå› æ­¤å…‰æ …åªèƒ½è€¦åˆç‰¹å®šåæŒ¯æ–¹å‘çš„å…‰ã€‚ å…‰æ …å‘¨æœŸ æ ¹æ®ä¹‹å‰å…¬å¼ï¼Œå…‰æ …å‘¨æœŸè¶Šå¤§ï¼Œè¡å°„çš„ä¸­å¿ƒæ³¢é•¿(åˆšå¥½æ»¡è¶³Braggæ¡ä»¶çš„æ³¢é•¿)ä¹Ÿè¶Šå¤§ã€‚ å ç©ºæ¯” å ç©ºæ¯”è¶Šå¤§ï¼Œæœ‰æ•ˆæŠ˜å°„ç‡ä¹Ÿè¶Šå¤§(å®½æ³¢å¯¼è¾ƒçª„æ³¢å¯¼ï¼Œæ›´æ¥è¿‘ä¸è‡ªç”±ä¼ æ’­ï¼Œå› æ­¤æœ‰æ•ˆæŠ˜å°„ç‡å¤§)ï¼Œå› æ­¤ä¸­å¿ƒæ³¢é•¿ä¹Ÿè¶Šå¤§ã€‚ åˆ»èš€æ·±åº¦ åˆ»èš€æ·±åº¦èƒ½å½±å“ \\(n_{eff2}\\)ï¼Œåˆ»èš€è¶Šæ·±,\\(n_{eff2}\\) è¶Šå°ï¼Œ\\(n_{eff}\\) ä¹Ÿå‡å°ï¼Œå¯¼è‡´ä¸­å¿ƒæ³¢é•¿å‡å°ã€‚ å…¥å°„è§’ å…¥å°„è§’è¶Šå¤§ï¼Œä¸­å¿ƒæ³¢é•¿è¶Šå°ã€‚ å¤ä¹ å†…å®¹: å…‰æ …è¡å°„ å…‰æ …å¸¸é‡:\\(d=a+b\\) å…‰æ …æ–¹ç¨‹(æ˜çº¹):$dsin=k,k=0,1,2... $ ç¼ºçº§\\(k=k&#39;\\frac{d}{a},k&#39;=1,2,3...\\) ç¼ºçº§åŸå› : è¿™æ˜¯å› ä¸ºå…‰ç»è¿‡å…‰æ …æ—¶ï¼Œä¸ä»…æ¯ä¸ªç‹­ç¼å‘ç”Ÿè¡å°„ï¼Œè€Œä¸”ç¼ä¸ç¼ä¹‹é—´çš„è¡å°„å…‰æ³¢ç›¸é‡å åŠ æ—¶è¿˜è¦å‘ç”Ÿå¹²æ¶‰ã€‚ å€¾æ–œå…¥å°„çš„å…‰æ …å…¬å¼ï¼š\\(d(sin\\varphi\\pm sin\\theta)=\\pm k \\lambda ,k=0,1,2...\\) å¸ƒæ‹‰æ ¼è¡å°„ å¸ƒæ‹‰æ ¼è¡å°„å…¬å¼:\\(2dsin\\theta=n\\lambda\\),å…¶ä¸­næ˜¯è¡å°„çº§æ•°ï¼Œdæ˜¯ä¸åŒå±‚ä¹‹é—´çš„é—´è·ã€‚","categories":[{"name":"å¤§åˆ›æ–‡çŒ®","slug":"å¤§åˆ›æ–‡çŒ®","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"}],"tags":[{"name":"å¤§åˆ›","slug":"å¤§åˆ›","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"æ–‡çŒ®","slug":"æ–‡çŒ®","permalink":"http://example.com/tags/%E6%96%87%E7%8C%AE/"}]},{"title":"å¤šå…ƒå‡½æ•°æ¦‚å¿µåŠæé™","slug":"å¤šå…ƒå‡½æ•°æ¦‚å¿µåŠæé™","date":"2022-01-24T09:34:14.344Z","updated":"2022-01-25T17:32:01.374Z","comments":true,"path":"2022/01/24/å¤šå…ƒå‡½æ•°æ¦‚å¿µåŠæé™/","link":"","permalink":"http://example.com/2022/01/24/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9E%81%E9%99%90/","excerpt":"","text":"å¤šå…ƒå‡½æ•°æ¦‚å¿µ å¹³é¢ç‚¹é›† \\[ (x, y) \\text { çš„ å…¨ ä½“ } R^{2}=\\{(x, y) \\mid x \\in R, y \\in R\\} \\] å®šä¹‰ï¼šåæ ‡å¹³é¢ä¸Šå…·æœ‰æŸç§æ€§è´¨çš„ç‚¹é›† \\[ \\varepsilon =\\left\\{ \\left( x,y \\right) |x^2+y^2&lt;1 \\right\\} \\] \\[ \\varepsilon =\\left\\{ \\left( x,y \\right) |x^2+y^2=1 \\right\\} \\] é‚»åŸŸ \\[ è®¾ P_{0}\\left(x_{0}, y_{0}\\right) æ˜¯ xoy å¹³é¢ä¸€ä¸ªç‚¹ï¼Œ \\delta ,\\\\\\quad u\\left(p_{0}, \\delta\\right)=\\left\\{\\left|p p_{0}\\right|&lt;\\delta\\right\\} ä¸º p_{0}çš„é‚»åŸŸ \\] ç‚¹æ¦‚å¿µ å†…ç‚¹ï¼š $ PE $ På‘¨è¾¹æ‰€æœ‰çš„ç‚¹éƒ½å±äºEã€‚ å¤–ç‚¹ï¼š \\(P\\notin E\\) På‘¨è¾¹æ‰€æœ‰çš„ç‚¹éƒ½ä¸å±äºEã€‚ è¾¹ç•Œç‚¹ï¼š På‘¨è¾¹å’ŒPè‡ªå·±æ—¢æœ‰å±äºEçš„ï¼Œåˆæœ‰ä¸å±äºEçš„ã€‚ æ‰€æœ‰è¾¹ç•Œç‚¹çš„é›†åˆè®°ä½œ\\(\\partial \\text{E}\\) èšç‚¹: å¯¹äºä»»ç»™çš„\\(\\delta&gt;0\\),ç‚¹pçš„å»å¿ƒé‚»åŸŸ\\(\\stackrel{\\circ}{U}\\left(P_{0}, \\delta\\right)\\) å†…æ€»æœ‰Eä¸­çš„ç‚¹ï¼Œé‚£ä¹ˆç§°Pæ˜¯Eçš„èšç‚¹ã€‚ å‡½æ•°æé™ è®¾äºŒå…ƒå‡½æ•°\\(f(p)=f(x,y)\\)çš„å®šä¹‰åŸŸä¸º\\(D\\),\\(P_{0}\\left(x_{0}, y_{0}\\right)\\)æ˜¯\\(D\\)çš„èšç‚¹ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•°\\(A\\)ï¼Œå¯¹äºä»»æ„ç»™å®šçš„æ­£æ•°\\(\\epsilon\\) ,æ€»å­˜åœ¨æ­£æ•°\\(\\delta\\)ï¼Œä½¿å¾—å½“ç‚¹\\(p(x,y)âˆˆDâˆ©\\stackrel{\\circ}{U}\\left(P_{0}, \\delta\\right)\\)éƒ½æœ‰ \\[ |f(P)-A|=|f(x, y)-A|&lt;\\varepsilon \\] æˆç«‹ï¼Œé‚£ä¹ˆå°±ç§°å¸¸æ•°\\(A\\)ä¸ºå‡½æ•°\\(f(x,y)\\)å½“\\((x,y)\\rightarrow(x_0,y_0)\\)çš„æé™,è®°ä½œ \\[ \\lim _{(x, y) \\rightarrow\\left(x_{0}, y_{0}\\right)} f(x, y)=A \\] å‡½æ•°è¿ç»­ å®šä¹‰: è®¾äºŒå…ƒå‡½æ•°\\(f(P)=f(x,y)\\)çš„å®šä¹‰åŸŸä¸º\\(D\\) ,\\(P_{0}\\left(x_{0}, y_{0}\\right)\\)ä¸º\\(D\\)çš„èšç‚¹,ä¸”\\(P_{0}\\in D\\) å¦‚æœ \\[ \\lim _{(x, y) \\rightarrow\\left(x_{0}, y_{0}\\right)} f(x, y)=f(x_0,y_0) \\] é‚£ä¹ˆç§°å‡½æ•°\\(f(x,y)\\)åœ¨ç‚¹\\(p_0(x_0,y_0)\\)è¿ç»­.","categories":[{"name":"é«˜æ•°","slug":"é«˜æ•°","permalink":"http://example.com/categories/%E9%AB%98%E6%95%B0/"}],"tags":[{"name":"é«˜æ•°","slug":"é«˜æ•°","permalink":"http://example.com/tags/%E9%AB%98%E6%95%B0/"}]},{"title":"markdown åŸºæœ¬è¯­æ³•","slug":"markdown åŸºæœ¬è¯­æ³•","date":"2022-01-24T05:46:50.120Z","updated":"2022-01-24T09:06:09.752Z","comments":true,"path":"2022/01/24/markdown åŸºæœ¬è¯­æ³•/","link":"","permalink":"http://example.com/2022/01/24/markdown%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"æ ‡é¢˜è¯­æ³• 123# ä¸€çº§æ ‡é¢˜## äºŒçº§æ ‡é¢˜### ä¸‰çº§æ ‡é¢˜ æ®µè½è¯­æ³• åˆ›å»ºæ®µè½æ—¶ä½¿ç”¨ç©ºç™½è¡Œå°†å¤šè¡Œæ–‡æœ¬åˆ†éš” ä¸è¦ä½¿ç”¨ç©ºæ ¼æˆ–é”è¿›åºœç¼©è¿›æ®µè½ 123I really like using Markdown.I think I&#x27;ll use it to format all of my documents from now on. æ¢è¡Œè¯­æ³• 1&lt;br&gt; or ä¸¤ä¸ªæˆ–å¤šä¸ªç©ºæ ¼è¿›è¡Œæ¢è¡Œ å¼ºè°ƒè¯­æ³• 123456789101112è®¾ç½®ç²—ä½“ä¸¤ä¸ªæ˜Ÿå·æˆ–ä¸¤ä¸ªä¸‹åˆ’çº¿**å†…å®¹**ï¼ˆæ¨èä½¿ç”¨ï¼‰__å†…å®¹__è®¾ç½®æ–œä½“ä¸€ä¸ªæ˜Ÿå·æˆ–ä¸€ä¸ªä¸‹åˆ’çº¿*å†…å®¹*ï¼ˆæ¨èä½¿ç”¨ï¼‰_å†…å®¹_åŒæ—¶æ·»åŠ ç²—ä½“å’Œæ–œä½“ä¸‰ä¸ªæ˜Ÿå·æˆ–ä¸‰ä¸ªä¸‹åˆ’çº¿ å¼•ç”¨è¯­æ³• åˆ›å»ºå—å¼•ç”¨ï¼Œåœ¨æ®µè½å‰æ·»åŠ ä¸€ä¸ª&gt;ç¬¦å· å—å¼•ç”¨å¯ä»¥åŒ…å«å¤šä¸ªæ®µè½ã€‚ä¸ºæ®µè½ä¹‹é—´çš„ç©ºç™½è¡Œæ·»åŠ ä¸€ä¸ª &gt; ç¬¦å·ã€‚ å®é™…æ•ˆæœï¼š åµŒå¥—æ•ˆæœï¼š åˆ—è¡¨è¯­æ³• åˆ†ä¸ºæœ‰åºåˆ—è¡¨å’Œæ— åºåˆ—è¡¨ æœ‰åºåˆ—è¡¨ åºå·åŠ ä¸Š.å’Œç©ºæ ¼ 1231. first2. second3. third 1. first 2. second 3. third æ— åºåˆ—è¡¨ è¯­æ³•ï¼š*ã€+ã€- first second third indented ä»£ç è¯­æ³• å°†å•è¯è¡¨ç¤ºä¸ºä»£ç ï¼Œå°†å•è¯åŒ…è£¹åœ¨åå¼•å·`ä¸­ ä»£ç å— å°†ä»£ç å—çš„æ¯ä¸€è¡Œç¼©è¿›è‡³å°‘å››ä¸ªç©ºæ ¼æˆ–ä¸€ä¸ªåˆ¶è¡¨ç¬¦ ä»£ç å— â€‹ åˆ†éš”çº¿ 123***---________ é“¾æ¥è¯­æ³• 1è¿™æ˜¯ä¸€ä¸ªé“¾æ¥ [Markdownè¯­æ³•](https://markdown.com.cn)ã€‚ è¶…é“¾æ¥Markdownè¯­æ³•ä»£ç ï¼š[è¶…é“¾æ¥æ˜¾ç¤ºå](è¶…é“¾æ¥åœ°å€ \"è¶…é“¾æ¥title\") å›¾ç‰‡è¯­æ³• æ’å…¥å›¾ç‰‡Markdownè¯­æ³•ä»£ç ï¼š![å›¾ç‰‡alt](å›¾ç‰‡é“¾æ¥ \"å›¾ç‰‡title\")ã€‚ page","categories":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}],"categories":[{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/categories/IELTS/"},{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/categories/Lumerical/"},{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"},{"name":"æ±‡ç‡","slug":"æ±‡ç‡","permalink":"http://example.com/categories/%E6%B1%87%E7%8E%87/"},{"name":"é‡å­åŠ›å­¦","slug":"é‡å­åŠ›å­¦","permalink":"http://example.com/categories/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"},{"name":"å¤§åˆ›æ–‡çŒ®","slug":"å¤§åˆ›æ–‡çŒ®","permalink":"http://example.com/categories/%E5%A4%A7%E5%88%9B%E6%96%87%E7%8C%AE/"},{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"ä»¿çœŸå®ä¾‹","slug":"Lumerical/ä»¿çœŸå®ä¾‹","permalink":"http://example.com/categories/Lumerical/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"},{"name":"é«˜æ•°","slug":"é«˜æ•°","permalink":"http://example.com/categories/%E9%AB%98%E6%95%B0/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"writing task2","slug":"writing-task2","permalink":"http://example.com/tags/writing-task2/"},{"name":"Lumerical","slug":"Lumerical","permalink":"http://example.com/tags/Lumerical/"},{"name":"inverse design","slug":"inverse-design","permalink":"http://example.com/tags/inverse-design/"},{"name":"æŸ¯è¥¿å…¬å¼","slug":"æŸ¯è¥¿å…¬å¼","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%85%AC%E5%BC%8F/"},{"name":"ä¸å®šç§¯åˆ†","slug":"ä¸å®šç§¯åˆ†","permalink":"http://example.com/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"},{"name":"æŸ¯è¥¿å®šç†","slug":"æŸ¯è¥¿å®šç†","permalink":"http://example.com/tags/%E6%9F%AF%E8%A5%BF%E5%AE%9A%E7%90%86/"},{"name":"å¤å˜å‡½æ•°","slug":"å¤å˜å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"æ±‡ç‡","slug":"æ±‡ç‡","permalink":"http://example.com/tags/%E6%B1%87%E7%8E%87/"},{"name":"è–›å®šè°”æ–¹ç¨‹","slug":"è–›å®šè°”æ–¹ç¨‹","permalink":"http://example.com/tags/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B/"},{"name":"å¤šå€¼å‡½æ•°","slug":"å¤šå€¼å‡½æ•°","permalink":"http://example.com/tags/%E5%A4%9A%E5%80%BC%E5%87%BD%E6%95%B0/"},{"name":"æ•°å­¦ç‰©ç†æ–¹æ³•","slug":"æ•°å­¦ç‰©ç†æ–¹æ³•","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"},{"name":"é‡å­åŠ›å­¦ä½œä¸š","slug":"é‡å­åŠ›å­¦ä½œä¸š","permalink":"http://example.com/tags/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E4%BD%9C%E4%B8%9A/"},{"name":"å¾·å¸ƒç½—æ„æ³¢","slug":"å¾·å¸ƒç½—æ„æ³¢","permalink":"http://example.com/tags/%E5%BE%B7%E5%B8%83%E7%BD%97%E6%84%8F%E6%B3%A2/"},{"name":"æ³¢å°”ç†è®º","slug":"æ³¢å°”ç†è®º","permalink":"http://example.com/tags/%E6%B3%A2%E5%B0%94%E7%90%86%E8%AE%BA/"},{"name":"é»‘ä½“è¾å°„\\å…‰ç”µæ•ˆåº”\\åº·æ™®é¡¿æ•£å°„","slug":"é»‘ä½“è¾å°„-å…‰ç”µæ•ˆåº”-åº·æ™®é¡¿æ•£å°„","permalink":"http://example.com/tags/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84-%E5%85%89%E7%94%B5%E6%95%88%E5%BA%94-%E5%BA%B7%E6%99%AE%E9%A1%BF%E6%95%A3%E5%B0%84/"},{"name":"script","slug":"script","permalink":"http://example.com/tags/script/"},{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"},{"name":"Grating Coupler","slug":"Grating-Coupler","permalink":"http://example.com/tags/Grating-Coupler/"},{"name":"æ•°å­—ç”µè·¯","slug":"æ•°å­—ç”µè·¯","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"ç¦»æ•£æ•°å­¦","slug":"ç¦»æ•£æ•°å­¦","permalink":"http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"ä»¿çœŸå®ä¾‹","slug":"ä»¿çœŸå®ä¾‹","permalink":"http://example.com/tags/%E4%BB%BF%E7%9C%9F%E5%AE%9E%E4%BE%8B/"},{"name":"å¤§åˆ›","slug":"å¤§åˆ›","permalink":"http://example.com/tags/%E5%A4%A7%E5%88%9B/"},{"name":"æ–‡çŒ®","slug":"æ–‡çŒ®","permalink":"http://example.com/tags/%E6%96%87%E7%8C%AE/"},{"name":"é«˜æ•°","slug":"é«˜æ•°","permalink":"http://example.com/tags/%E9%AB%98%E6%95%B0/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]}